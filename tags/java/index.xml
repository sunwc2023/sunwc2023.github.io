<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on Sunwc&#39;s Blog</title>
    <link>https://sunwc2023.github.io/tags/java/</link>
    <description>Recent content in Java on Sunwc&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-tw</language>
    <lastBuildDate>Mon, 03 Apr 2023 11:30:00 +0800</lastBuildDate><atom:link href="https://sunwc2023.github.io/tags/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Java - Reflection</title>
      <link>https://sunwc2023.github.io/blog/reflection/reflection/</link>
      <pubDate>Mon, 03 Apr 2023 11:30:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/reflection/reflection/</guid>
      <description>為什麼要使用 Reflection？ 有時候我們無法確定，當程式執行起來時，對應不同時機要使用什麼物件來幫我們做事，就會使用 Reflection 機制，在需要的時候才建立對應的物件來處理當前要做的事，所以我們可以說 Reflection 擁有一種 機動性 建物件的功能
Reflection 與 Encapsulation(封裝) 是衝突的嗎？ 基本上封裝性的核心在於定義物件的成員時，要設定物件成員的存取權限，因此設定權限的本質，就是告訴開發人員，哪些是適合直接去使用的，若某些物件成員，在建立類別時就定義為不想直接被存取，撇開安全性的問題，有時更像是定義的人認定這個物件成員是不需要被開發人員使用到的，因為那些公開可以直接被使用的物件成員，其實就已經完全提供了這個物件應該實現的功能；而映射的出現，雖然說能夠存取私有的物件成員，但是也不代表我們使用映射就是為了去存取那些被定義為私有的物件成員；更多的使用只是為了能夠在需要動態產生對應物件做事時，使用這個映射的方式取得物件罷了。</description>
    </item>
    
    <item>
      <title>Java - 網路通信</title>
      <link>https://sunwc2023.github.io/blog/networkprogramming/network/</link>
      <pubDate>Sun, 02 Apr 2023 07:23:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/networkprogramming/network/</guid>
      <description>通信雙方地址 IP：網路定位的唯一一台主機，Java中表示 IP 地址，為 InetAddress 類；
分為IPv4(例如 192.168.0.1)、IPv6(例如 3ffe:3201:1401:1280:c8ff:fe4d:db39:1984)；私有IP地址(局部網域)範圍即為192.168.0.0 ~ 192.</description>
    </item>
    
    <item>
      <title>Java - System.in、 System.out, PrintStream, Data Stream</title>
      <link>https://sunwc2023.github.io/blog/io/other-stream/</link>
      <pubDate>Fri, 31 Mar 2023 20:12:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/io/other-stream/</guid>
      <description>System類 System.in：標準輸入，默認s從鍵盤輸入；其類別為InputStream System.out：標準輸出，默認從console輸出；其類別為PrintStream，為OutputStream的子類 練習一 System.in(return InputStream 類) 讀取鍵盤輸入的兩種方式 從鍵盤輸入字串，要求將讀取到的整行字串轉成大寫輸出。然後繼續進行輸入操作，直至當輸入“e”或“exit”時，退出程式
public static void main(String[] args) { // 方法一 使用Scanner實現 // Scanner scan = new Scanner(System.</description>
    </item>
    
    <item>
      <title>Java - InputStream, OutputStream &amp; Reader, Writer</title>
      <link>https://sunwc2023.github.io/blog/io/read-write/</link>
      <pubDate>Fri, 31 Mar 2023 19:12:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/io/read-write/</guid>
      <description>流的分類 1.操作資料單位：字節流、字符流
2.資料的流向：輸入流、輸出流
3.流的角色：節點流、處理流
流的體系結構 文件輸入字符流(FileReader)：read() @Test public void fileReaderTest() { FileReader fr = null; try { File file = new File(&amp;#34;hello.</description>
    </item>
    
    <item>
      <title>Java - File</title>
      <link>https://sunwc2023.github.io/blog/io/file/</link>
      <pubDate>Thu, 30 Mar 2023 10:26:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/io/file/</guid>
      <description>File 類的使用 1.File 類的一個物件，代表一個文件或一個文件目錄(俗稱：文件夾)
2.File 類宣告在 java.io package下
3.File 類涉及到關於文件或文件目錄的創建、刪除、重命名、修改時間、取得文件大小等方法，並未涉及到寫入或讀取文件內容的操作。如果需要讀取或寫入文件內容，必須使用IO流來完成</description>
    </item>
    
    <item>
      <title>Java - Collections - 操作 Collection、Map 工具類</title>
      <link>https://sunwc2023.github.io/blog/collection/collections-list-set-map/</link>
      <pubDate>Wed, 29 Mar 2023 14:28:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/collection/collections-list-set-map/</guid>
      <description>Collections 工具類 常用方法 reverse(List) ：反轉 List 中的元素 shuffle(List)：對 List 集合元素進行隨機排序 sort(List)：根據元素的自然順序對指定 List 集合元素按升冪排序 sort(List, Comparator)：根據指定的 Comparator 產生的順序對 List 集合元素進行排序 swap(List, int, int)：將指定 list 集合中的 index i元素 與 index j元素進行交換 Object max(Collection)：根據元素的自然排序，回傳給定集合中的最大元素 Object max(Collection, Comparator)：根據 Comparator 指定的順序，回傳給訂集合中的最大元素 Object min(Collection) Object min(Collection, Comparator) int frequency(Collection, Object)：回傳指定集合中指定元素的出現次數 void copy(List dest, List src)：將 src 中的內容複製到 dest 中 /** * @author sunwc * @create 2023-03-29 下午 03:20 */ public class CollectionsTest { @Test public void testCollections() { List list = new ArrayList(); list.</description>
    </item>
    
    <item>
      <title>Java - Collection(二)</title>
      <link>https://sunwc2023.github.io/blog/collection/map/</link>
      <pubDate>Wed, 29 Mar 2023 08:53:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/collection/map/</guid>
      <description>JDK 1.8 Collection 框架 - interface Map 架構 interface Map：雙列資料，儲存key-value對的資料</description>
    </item>
    
    <item>
      <title>Java - Collection(一)</title>
      <link>https://sunwc2023.github.io/blog/collection/list-set/</link>
      <pubDate>Tue, 28 Mar 2023 13:47:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/collection/list-set/</guid>
      <description>JDK 1.8 Collection 框架 - interface List, interface Set 架構 interface Collection：單列集合，用來儲存一個一個的物件 interface List：儲存有序的、可重複的資料 =&amp;gt; &amp;ldquo;動態&amp;quot;陣列，替換原有的陣列</description>
    </item>
    
    <item>
      <title>Java - Collection - iterator 方法</title>
      <link>https://sunwc2023.github.io/blog/collection/collection-iterator/</link>
      <pubDate>Tue, 28 Mar 2023 12:41:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/collection/collection-iterator/</guid>
      <description>/** * @author sunwc * @create 2023-03-28 上午 09:56 */ public class CollectionTest { @Test public void testCollection() { Collection collection = new ArrayList&amp;lt;&amp;gt;(); Person person = new Person(&amp;#34;Jerry&amp;#34;, 20); collection.</description>
    </item>
    
    <item>
      <title>Java - enum class</title>
      <link>https://sunwc2023.github.io/blog/enum/enum-class/</link>
      <pubDate>Mon, 27 Mar 2023 16:05:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/enum/enum-class/</guid>
      <description>為什麼要使用列舉類？ 當我們在開發中，有一組常數對應不同的狀態來顯示時，就可以考慮使用 enum class
方式一、自定義列舉類 /** * 自定義列舉類 * @author sunwc * @create 2023-03-27 下午 03:53 */ public class Season { // 1.</description>
    </item>
    
    <item>
      <title>Java - interface Comparator vs. interface Comparable</title>
      <link>https://sunwc2023.github.io/blog/compare/comparator-comparable/</link>
      <pubDate>Mon, 27 Mar 2023 11:05:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/compare/comparator-comparable/</guid>
      <description>interface java.lang.Comparable override compartTo() 自然排序 override compareTo(obj) 的規則： 如果當前物件this大於傳入物件obj，則回傳正整數 如果當前物件this小於傳入物件obj，則回傳負整數 如果當前物件this等於傳入物件obj，則回傳0 實現 interface Comparable 的有String, wrapper class, java.</description>
    </item>
    
    <item>
      <title>Java - StringBuffer, StringBuilder</title>
      <link>https://sunwc2023.github.io/blog/string/string-buffer/</link>
      <pubDate>Sun, 26 Mar 2023 15:50:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/string/string-buffer/</guid>
      <description>String：不可變的 CharSequence
StringBuffer：可變的 CharSequence、且thread-safety，所以效率較低
StringBuilder：可變的 CharSequence、非thread-safety，所以效率較高
執行效率：StringBuilder &amp;gt; StringBuffer &amp;gt; String</description>
    </item>
    
    <item>
      <title>Java - 時間相關API</title>
      <link>https://sunwc2023.github.io/blog/datetime/datetime-api/</link>
      <pubDate>Sun, 26 Mar 2023 15:50:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/datetime/datetime-api/</guid>
      <description>JDK 8 以前日期時間API java.lang.System.currentTimeMillis()：回傳(long值)當前時間與1970年1月1日0時0分0秒之間以毫秒為單位的時間差(時間戳)
UTC 統一標準時間 GMT 格林威治標準時間 CST 中央標準時間 java.</description>
    </item>
    
    <item>
      <title>Java - String 不可變的</title>
      <link>https://sunwc2023.github.io/blog/string/unchangeable-string/</link>
      <pubDate>Sat, 25 Mar 2023 15:48:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/string/unchangeable-string/</guid>
      <description>例子 /** * String 代表不可變的CharSequence，簡稱不可變性 * @author sunwc * @create 2023-03-25 下午 02:51 */ public class StringTest { private String str = new String(&amp;#34;good&amp;#34;); private char[] ch = {&amp;#39;t&amp;#39;,&amp;#39;e&amp;#39;,&amp;#39;s&amp;#39;,&amp;#39;t&amp;#39;}; private void change(String str, char[] ch) { str = &amp;#34;test ok&amp;#34;; ch[0] = &amp;#39;b&amp;#39;; } public static void main(String[] args) { StringTest stringTest = new StringTest(); stringTest.</description>
    </item>
    
    <item>
      <title>Java -  Thread 執行緒(四) Thread Pool</title>
      <link>https://sunwc2023.github.io/blog/thread/thread-pool/</link>
      <pubDate>Fri, 24 Mar 2023 21:34:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/thread/thread-pool/</guid>
      <description>Thread Pool 特性 背景：經常創建和銷毀、使用量特別大的資源，例如併發情況下的執行緒，對效能影響很大 思路：提前創建 Multi thread，放入 Thread Pool中，使用時直接取得，使用完後放回池中。可以避免頻繁創建與銷毀、實現重複利用。類似生活中大眾交通工具 好處： 提高響應速度(減少了創建新 Thread 的時間) 降低資源消耗(重複利用Thread Pool中的Thread，不需要每次都創建) 便於 Thread 管理 corePoolSize: 核心池的大小 maximumPoolSize: 最大 Thread 數 keepAliveTime: Thread 在沒有任務時最多保持多長時間後會終止 Thread Pool 相關 API JDK 5.</description>
    </item>
    
    <item>
      <title>Java - Thread 執行緒(三) - interface Callable</title>
      <link>https://sunwc2023.github.io/blog/thread/implements-callable/</link>
      <pubDate>Fri, 24 Mar 2023 20:44:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/thread/implements-callable/</guid>
      <description>JDK 5.0 新增
新執行緒的創建 (Multi-threading) - 實現 interface Callable 之步驟 1.</description>
    </item>
    
    <item>
      <title>Java - 多執行緒 通訊</title>
      <link>https://sunwc2023.github.io/blog/thread/concurrent-product/</link>
      <pubDate>Fri, 24 Mar 2023 15:51:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/thread/concurrent-product/</guid>
      <description>題目 生產者(Producer)將產品將給店員(Clerk)，而消費者(Consumer)從店員出取走商品，店員一次只能持有固定數量的產品(例如:20)，如果生產者試圖生產更多的產品，店員會較生產者暫停一下，如果店中有空位可以放產品了在通知生產者繼續生產；如果店中沒有產品了，店員會告知消費者等一下，如果店中有產品了再通知消費者來取走產品
/** * @author sunwc * @create 2023-03-24 下午 03:49 */ public class ConcurrentProduct { public static void main(String[] args) { // 共享資源 Clerk clerk = new Clerk(); // 第一個生產者 Producer producer1 = new Producer(clerk); // 第一個消費者 Consumer consumer1 = new Consumer(clerk); Consumer consumer2 = new Consumer(clerk); producer1.</description>
    </item>
    
    <item>
      <title>Java - 執行緒 交互輸出1-50的數字</title>
      <link>https://sunwc2023.github.io/blog/thread/wait-notify/</link>
      <pubDate>Fri, 24 Mar 2023 15:20:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/thread/wait-notify/</guid>
      <description>執行緒通訊 Multi-threading 中 如何讓執行緒可以交互執行 會涉及到三個方法：
java.lang.Object.wait()：一但執行此方法，當前執行緒就會進入阻塞狀態，並釋放同步鎖 java.lang.Object.notify()：一但執行此方法，就會喚醒正在wait()中的執行緒。如果有多個執行緒wait()中，就先喚醒優先級較高的 java.lang.Object.notifyAll()：一但執行此方法，就會喚醒所有wait()中的執行緒 wait(),notify(),notifyAll()使用前提 這三個方法只能使用在synchronized修飾的區塊 或 同步方法中 這三個方法的調用者必須是同步鎖this；若調用此三個方法的物件與同步鎖不一致，會出現IllegalMonitorStateException 例子 /** * @author sunwc * @create 2023-03-24 下午 03:02 */ public class PrintNumberInteraction { public static void main(String[] args) { Number number = new Number(); Thread t1 = new Thread(number); Thread t2 = new Thread(number); t1.</description>
    </item>
    
    <item>
      <title>Java - Lock &amp; synchronized 使用</title>
      <link>https://sunwc2023.github.io/blog/thread/deposit-concurrent-example/</link>
      <pubDate>Fri, 24 Mar 2023 12:49:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/thread/deposit-concurrent-example/</guid>
      <description>方式一、 使用鎖 import java.util.concurrent.locks.ReentrantLock; /** * 演示案例：銀行有一個帳戶 * 有兩個存戶分別向同一個帳戶存3000元，每次存1000，存3次。 * 每次存完輸出帳戶餘額 * @author sunwc * @create 2023-03-24 下午 12:23 */ public class ConcurrentAccount { public static void main(String[] args) { // 帳戶為共享資源，只new一次 Account account = new Account(); Depositor depositor = new Depositor(account); Thread t1 = new Thread(depositor); Thread t2 = new Thread(depositor); t1.</description>
    </item>
    
    <item>
      <title>Java - Lock - 解決執行緒不安全</title>
      <link>https://sunwc2023.github.io/blog/thread/lock-reentrantlock/</link>
      <pubDate>Fri, 24 Mar 2023 12:04:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/thread/lock-reentrantlock/</guid>
      <description>為什麼要用鎖(Lock)？ 鎖 相對於 synchronized 機制，是更加靈活的，它一樣能夠解決執行緒不安全的問題；
不同點在於：synchronized機制在執行完相應的區塊後，會自動釋放同步鎖；而Lock就需要手動啟動同步 以及 手動結束同步 java.util.concurrent.locks.ReentrantLock; 是JDK 5.</description>
    </item>
    
    <item>
      <title>Java - Thread 的 Deadlock</title>
      <link>https://sunwc2023.github.io/blog/thread/thread-deadlock/</link>
      <pubDate>Thu, 23 Mar 2023 15:37:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/thread/thread-deadlock/</guid>
      <description>什麼是死鎖？ 當不同執行緒分別占用對方需要的同步資源不放棄，都在等待對方放棄自己需要的同步資源，就形成了執行緒的死鎖
死鎖出現後的現象？ 出現死鎖後，不會出現例外，也不會有提示，只是所有執行緒都處於阻塞的狀態；因此我們在使用 synchronized 的時候，要避免死鎖的情況發生
如何避免死鎖？ 盡量減少同步資源的宣告，例如 有 static 關鍵字 避免嵌套synchronized(同步鎖){} 例子 /** * 演示執行緒死鎖問題 * @author sunwc * @create 2023-03-24 上午 10:49 */ public class DeadlockTest { public static void main(String[] args) { // 1.</description>
    </item>
    
    <item>
      <title>Java - Thread 的 生命週期</title>
      <link>https://sunwc2023.github.io/blog/thread/thread-lifecycle/</link>
      <pubDate>Thu, 23 Mar 2023 15:37:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/thread/thread-lifecycle/</guid>
      <description>JDK中用Thread.State類定義了執行緒的幾種狀態如下：
public enum State { NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED } Java語言使用 Thread 類及其子類別的物件來表示執行緒，在它一個完整的生命週期中通常要經歷如下五個狀態：</description>
    </item>
    
    <item>
      <title>Java - Thread 執行緒(二) - interface Runnable</title>
      <link>https://sunwc2023.github.io/blog/thread/implements-runnable/</link>
      <pubDate>Thu, 23 Mar 2023 15:35:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/thread/implements-runnable/</guid>
      <description>有關創建多執行緒 (Multi-threading) 的方式 - 繼承 Thread 類，可以參考我的另一篇文章 Java - Thread 執行緒(一)</description>
    </item>
    
    <item>
      <title>Java - Thread 執行緒(一)</title>
      <link>https://sunwc2023.github.io/blog/thread/thread/</link>
      <pubDate>Thu, 23 Mar 2023 09:00:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/thread/thread/</guid>
      <description>什麼是Process？ 通常一個應用程序執行起來，就會在記憶體加載一個 Process ，對應到工作管理員(上圖)來看，一個 Process 就會對應到一個 PID (Process Identification)； 而一個 Process 會有 Multi-threading (Thread)，代表這個應用程序支持我們能夠使用它 同時在裡面做很多事情</description>
    </item>
    
    <item>
      <title>Java - 例外處理 (Exception)</title>
      <link>https://sunwc2023.github.io/blog/exception/exception-example/</link>
      <pubDate>Wed, 22 Mar 2023 14:09:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/exception/exception-example/</guid>
      <description>Error：此錯誤是 Java虛擬機 (JVM) 無法解決的嚴重問題。例如 JVM系統內部錯誤、資源耗盡等嚴重情況 java.lang.StackOverflowError堆疊溢出 =&amp;gt; 例如 recursion終止條件沒寫好 java.</description>
    </item>
    
    <item>
      <title>Java - interface</title>
      <link>https://sunwc2023.github.io/blog/abstract/interface/</link>
      <pubDate>Wed, 22 Mar 2023 10:26:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/abstract/interface/</guid>
      <description>interface 特性 interface 可以定義全局常量、抽象方法、靜態方法與默認方法
interface 沒有 constructor，因此也不可以實例化
Java類可以 implements 多個 interface ，彌補了 Java 單繼承的侷限性 (先寫繼承後寫實現)</description>
    </item>
    
    <item>
      <title>Java - 抽象類別 抽象方法</title>
      <link>https://sunwc2023.github.io/blog/abstract/abstract/</link>
      <pubDate>Wed, 22 Mar 2023 09:12:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/abstract/abstract/</guid>
      <description> 有關的例子，可以參考我的另一篇文章 Java - 多型 繼承
abstract的特性 abstract 關鍵字只可以修飾 非final 的類別、 非private、非static、非final 的方法 抽象類別不可以實例化，抽象類別一定有constructor，以便讓子類別實例化的時候可以進行調用 抽象方法只有方法的宣告、沒有方法體 總結： 包含 抽象方法 的類別，一定是抽象類別；反之，抽象類別中可以無抽象方法 若子類別覆寫父類別的所有抽象方法後，此子類別可以實例化；若子類別沒有覆寫父類的所有抽象方法，則此子類別也是一個抽象類別，需要使用 abstract 修飾 </description>
    </item>
    
    <item>
      <title>Java - static 關鍵字 vs. 單例 (Singleton) 設計模式</title>
      <link>https://sunwc2023.github.io/blog/static/static-example/</link>
      <pubDate>Tue, 21 Mar 2023 17:55:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/static/static-example/</guid>
      <description>static 關鍵字： 有些時候，我們希望「某些特定資料在記憶體中只有一份」，且這份資料是大家共享的，而不會隨著物件而不同的，例如：存款利率、最低存款金額、工具類
access 靜態變數 實例變數類別 Yes No物件 Yes Yesstatic 特性： static 可以修飾 屬性、方法、程式區塊、內部類 靜態程式區塊 (static block)：(用於類別初始化) 隨著類別加載時，就會執行，且只會執行一次 static { System.</description>
    </item>
    
    <item>
      <title>Java - equals 方法</title>
      <link>https://sunwc2023.github.io/blog/compare/equals/</link>
      <pubDate>Tue, 21 Mar 2023 14:17:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/compare/equals/</guid>
      <description>Object 的 euqals() 與 == 作用是相同的 是比較兩個物件的記憶體地址是否相同
public boolean equals(Object obj) { return (this == obj); } String, java.</description>
    </item>
    
    <item>
      <title>Java - final, finally, finalize 的區別</title>
      <link>https://sunwc2023.github.io/blog/final/final-finally-finalize/</link>
      <pubDate>Tue, 21 Mar 2023 14:11:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/final/final-finally-finalize/</guid>
      <description>finalize 方法 一般來說，在物件被回收之前會先存取 物件.finalize()，但是我們不要主動去調finalize()，gc回收機制會主動去調 物件.finalize()
final 關鍵字 * final 修飾類別： 代表本類別就不能被繼承，例如 String, System, StringBuffer 類別* final 修飾方法： 代表本方法不能被覆寫 (Override)，例如Object類別的getClass()* final 修飾變數： 代表本變數為常量，不能做修改；可以考慮指定值的位置有：顯示初始化、non-static-block 中初始化、constructor 中初始化```javapublic class SingletonTest2 {final int WIDTH;final int HEIGHT;final double PI;// non-static-block{PI = Math.</description>
    </item>
    
    <item>
      <title>Java - OOP 物件導向特性</title>
      <link>https://sunwc2023.github.io/blog/abstract/oop/</link>
      <pubDate>Mon, 20 Mar 2023 17:35:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/abstract/oop/</guid>
      <description>encapsulation封裝性： Java提供了4種存取修飾符private ,不寫(default), protected , public來修飾類別及類別的內部結構，體現類別及內部結構在被存取時的可見性(visible)的大小
inheritance繼承性： 減少程式碼的冗餘，也方便功能的擴展，先有一個類別(子)去繼承另一個類別(父)，而有了父類與子類的關係，子類可以使用父類的所有功能，且子類還可以在父類的基礎之上擴展其他功能 =&amp;gt; is-a 關係(子類 is a 父類)</description>
    </item>
    
    <item>
      <title>Java - 陣列快速排序法 Quick Sort</title>
      <link>https://sunwc2023.github.io/blog/array/quick-sort/</link>
      <pubDate>Sun, 19 Mar 2023 21:36:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/array/quick-sort/</guid>
      <description>值轉換數字失敗，會拋出NumberFormatException，詳情請看private static Double isNumeric(Object obj) function
題目 取得一個Object Array，包含不同data types，排除不是數字、不是浮點型的值</description>
    </item>
    
    <item>
      <title>Java - 陣列二分搜尋</title>
      <link>https://sunwc2023.github.io/blog/array/array-search/</link>
      <pubDate>Sun, 19 Mar 2023 11:15:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/array/array-search/</guid>
      <description>public static void main(String[] args) { // 二分搜尋 // 前提：所要搜尋的陣列必須有序 int[] arr = {-98,-34,2,34,54,66,79,105,210,333}; int target = 34; int startInx = 0; int endInx = arr.</description>
    </item>
    
    <item>
      <title>Java - 陣列反轉/字串反轉</title>
      <link>https://sunwc2023.github.io/blog/reversion/array-reversion/</link>
      <pubDate>Sun, 19 Mar 2023 11:15:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/reversion/array-reversion/</guid>
      <description>陣列反轉 public static void main(String[] args) { String[] arr = new String[] {&amp;#34;PP&amp;#34;,&amp;#34;BB&amp;#34;,&amp;#34;MM&amp;#34;,&amp;#34;GG&amp;#34;,&amp;#34;JJ&amp;#34;,&amp;#34;DD&amp;#34;,&amp;#34;MM&amp;#34;}; String temp; // 方式一、交換arr.</description>
    </item>
    
    <item>
      <title>Java - 找1-100中所有質數</title>
      <link>https://sunwc2023.github.io/blog/exmaple/find-prime-number/</link>
      <pubDate>Sat, 18 Mar 2023 11:37:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/exmaple/find-prime-number/</guid>
      <description>public static void main(String[] args) { for (int i = 2; i &amp;lt;= 100; i++) { boolean flag = true; // 質數是只能被1與自己整除，所以判斷非質數範圍就只能是 2 ~ (i-1) // for (int j = 2; j &amp;lt; i ; j++) { for (int j = 2; j &amp;lt;= Math.</description>
    </item>
    
    <item>
      <title>Java - 打印菱形</title>
      <link>https://sunwc2023.github.io/blog/exmaple/print-diamond/</link>
      <pubDate>Sat, 18 Mar 2023 10:09:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/exmaple/print-diamond/</guid>
      <description>public static void main(String[] args) { /* 內層迴圈每次執行10次 第1行(i=5) 印星號 j=5 第2行(i=4) 印星號 j=4、6 第3行(i=3) 印星號 j=3、5、7 第4行(i=2) 印星號 j=2、4、6、8 第5行(i=1) 印星號 j=1、3、5、7、9 j其餘情況印一個空白 輸出上半部： * * * * * * * * * * * * * * * */ for (int i = 5; i &amp;gt; 0; i--) { // 計算當前是第幾行，第0行即不用找下一個印星號的位置 int line = 5 - i; int nextPosition = 0; for (int j = 1; j &amp;lt; 10; j++) { // 當 內層迴圈 第一次 i == j 的時候，就先去找下一個印*號的位置 // j == nextPosition(下一個印星號的位置)，就印星號 if (line &amp;gt;= 0 &amp;amp;&amp;amp; (j == i || nextPosition == j)) { System.</description>
    </item>
    
    <item>
      <title>Java - Switch-case 計算X年X月X日為第X年第幾天</title>
      <link>https://sunwc2023.github.io/blog/exmaple/days-of-year/</link>
      <pubDate>Fri, 17 Mar 2023 13:01:23 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/exmaple/days-of-year/</guid>
      <description>思路：越下面的 case 被執行的機率越高，因此要從最下面的 case 1 倒著累加至第一個 case 12；由於沒有 break 語句，因此進入某個 case 後，其 case 下面的所有 case 都會被執行</description>
    </item>
    
    <item>
      <title>Java - Math.random 使用</title>
      <link>https://sunwc2023.github.io/blog/exmaple/math-random/</link>
      <pubDate>Fri, 17 Mar 2023 11:37:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/exmaple/math-random/</guid>
      <description>原始random區間為包含0.0且不包含1.0 =&amp;gt; [0.0,1.0)
我們可以透過公式Math.random*(b-a+1)+a 取得區間[a,b)的一個數字
例子 public static void main(String[] args) { // 原始random區間為包含0.</description>
    </item>
    
    <item>
      <title>Java - 多型 繼承</title>
      <link>https://sunwc2023.github.io/blog/abstract/abstract-human/</link>
      <pubDate>Thu, 16 Mar 2023 14:32:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/abstract/abstract-human/</guid>
      <description>學習目標: 多型 繼承 --多型-- 撰寫一個 Human 類別 代表人 在這裡我們有兩個衍伸類別 Man 與 Woman 他們用不同的規則活著： Man : 吃飯時 印出&amp;#34;好好吃&amp;#34; 睡覺時 印出&amp;#34;zzz&amp;#34; Woman: 吃飯時 印出&amp;#34;Orzz&amp;#34; 睡覺時 印出&amp;#34;:)&amp;#34; (印出代表用System.</description>
    </item>
    
    <item>
      <title>Java - ThreadLocal 實際應用</title>
      <link>https://sunwc2023.github.io/blog/thread/thread-local-example/</link>
      <pubDate>Wed, 15 Mar 2023 14:45:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/thread/thread-local-example/</guid>
      <description>有關如何使用 ThreadLocal 確保 Thread-safety，可以參考我的另一篇文章 Java - ThreadLocal 類的使用
筆者曾經在不了解 ThreadLocal 類的情況下，錯用 ThreadLocal 客製Log物件的工具類，後來理解 ThreadLocal 運作原理後，在這裡特別記錄下來</description>
    </item>
    
    <item>
      <title>Java - ThreadLocal 類的使用</title>
      <link>https://sunwc2023.github.io/blog/thread/thread-local/</link>
      <pubDate>Wed, 15 Mar 2023 13:01:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/thread/thread-local/</guid>
      <description>有關在實際工作上使用到 ThreadLocal 的例子，可以參考我的另一篇文章 Java - ThreadLocal 實際應用
ThreadLocal 實現原理 ThreadLocal 從字面義直翻，就是執行緒 (Thread) 的局部變數，是每一個執行緒所單獨持有，其他執行緒不能對其進行存取</description>
    </item>
    
  </channel>
</rss>
