<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on Sunwc&#39;s Blog</title>
    <link>https://sunwc2023.github.io/tags/java/</link>
    <description>Recent content in Java on Sunwc&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-tw</language>
    <lastBuildDate>Thu, 23 Mar 2023 15:37:00 +0800</lastBuildDate><atom:link href="https://sunwc2023.github.io/tags/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Java - Thread 的生命週期</title>
      <link>https://sunwc2023.github.io/blog/thread-lifecycle/</link>
      <pubDate>Thu, 23 Mar 2023 15:37:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/thread-lifecycle/</guid>
      <description>JDK中用Thread.State類定義了執行緒的幾種狀態
想實現多執行緒，必須在主執行緒中創建新的執行緒物件。
Java語言使用 Thread 類及其子類的物件來表示執行緒，在它一個完整的生命週期中通常要經歷如下五個狀態：
1. 新建：當一個 Thread 類或其子類的物件被宣告並創建時，新生的執行緒物件處於新建狀態2. 就緒：處於新建狀態的執行緒被start()後，將進入執行緒隊列等待CPU時間片，此時它已具備了執行的條件，只是沒分配到CPU資源3.</description>
    </item>
    
    <item>
      <title>Java - Thread 執行緒(二) - interface Runnable</title>
      <link>https://sunwc2023.github.io/blog/implements-runnable/</link>
      <pubDate>Thu, 23 Mar 2023 15:35:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/implements-runnable/</guid>
      <description>有關創建多執行緒的方式 - 繼承 Thread類，可以參考我的另一篇文章 Java - Thread 執行緒(一)
除了上述說的這個方式創建執行緒，更好的方式是透過實現 interface Runnable 來做</description>
    </item>
    
    <item>
      <title>Java - Thread 執行緒(一)</title>
      <link>https://sunwc2023.github.io/blog/thread/</link>
      <pubDate>Thu, 23 Mar 2023 09:00:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/thread/</guid>
      <description>什麼是Process？ 通常一個應用程序執行起來，就會在記憶體加載一個 Process ，對應到工作管理員來看，一個 Pross 就會對應到一個 PID (Process Identification)； 而一個 Process 會有多個執行緒 (Thread)，代表這個應用程序支持我們能夠使用它自身 同時在裡面做很多事情</description>
    </item>
    
    <item>
      <title>Java - 例外處理 (Exception)</title>
      <link>https://sunwc2023.github.io/blog/exception-example/</link>
      <pubDate>Wed, 22 Mar 2023 14:09:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/exception-example/</guid>
      <description>Error：Java虛擬機(JVM)無法解決的嚴重問題。例如JVM系統內部錯誤、資源耗盡等嚴重情況 java.lang.StackOverflowError堆疊溢出 =&amp;gt; recursion終止條件沒寫好 java.lang.OutOfMemoryError 堆積溢出 =&amp;gt; Integer[] arr = new Integer[1024*1024*1024]; Exception：因為程式編輯錯誤或偶然的外在因素的一般性問題，可以使用針對性的程式進行處理 請看以下error/ exception 架構圖進行了解：</description>
    </item>
    
    <item>
      <title>Java - interface</title>
      <link>https://sunwc2023.github.io/blog/interface/</link>
      <pubDate>Wed, 22 Mar 2023 10:26:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/interface/</guid>
      <description>interface 可以定義全局常量、抽象方法、靜態方法與默認方法 interface 沒有 constructor，因此也不可以實例化 Java類可以 implements 多個 interface ，彌補了 Java 單繼承的侷限性 (先寫繼承後寫實現) 格式類似如下： public final class String extends Object implements java.</description>
    </item>
    
    <item>
      <title>Java - 抽象類別 抽象方法</title>
      <link>https://sunwc2023.github.io/blog/abstract/</link>
      <pubDate>Wed, 22 Mar 2023 09:12:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/abstract/</guid>
      <description>有關的例子，可以參考我的另一篇文章 Java - 多型 繼承
abstract
abstract 關鍵字只可以修飾 非final 類別, 非private、非static、非final 方法 抽象類別不可以實例化，抽象類別一定有constructor，以便讓子類別實例化的時候可以進行調用 抽象方法只有方法的宣告、沒有方法體 結論：</description>
    </item>
    
    <item>
      <title>Java - static 關鍵字 vs. 單例 (Singleton) 設計模式</title>
      <link>https://sunwc2023.github.io/blog/static-example/</link>
      <pubDate>Tue, 21 Mar 2023 17:55:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/static-example/</guid>
      <description>static 關鍵字：有些時候，我們希望「某些特定資料在記憶體中只有一份」，且這份資料是大家共享的，而不會隨著物件而不同的，例如：存款利率、最低存款金額、工具類
access 靜態變數 實例變數類別 Yes No物件 Yes Yesstatic 可以修飾 屬性、方法、程式區塊、內部類 靜態程式區塊 (static block)：(用於類別初始化) 隨著類別加載時，就會執行，且只會執行一次 static { System.</description>
    </item>
    
    <item>
      <title>Java - equals 方法</title>
      <link>https://sunwc2023.github.io/blog/equals/</link>
      <pubDate>Tue, 21 Mar 2023 14:17:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/equals/</guid>
      <description>Object 的 euqals() 與 == 作用是相同的，是比較兩個物件的記憶體地址是否相同 public boolean equals(Object obj) { return (this == obj); } String, java.</description>
    </item>
    
    <item>
      <title>Java - final, finally, finalize 的區別</title>
      <link>https://sunwc2023.github.io/blog/final-finally-finalize/</link>
      <pubDate>Tue, 21 Mar 2023 14:11:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/final-finally-finalize/</guid>
      <description>finalize 方法： 一般來說，在物件被回收之前會先存取 物件.finalize()，但是我們不要主動去調finalize()，gc回收機制會主動去調 物件.finalize()
final 關鍵字
final 修飾類別： 代表本類別就不能被繼承，例如 String, System, StringBuffer 類別 final 修飾方法： 代表本方法不能被覆寫 (Override)，例如Object類別的getClass() final 修飾變數： 代表本變數為常量，不能做修改；可以考慮指定值的位置有：顯示初始化、non-static-block 中初始化、constructor 中初始化 public class SingletonTest2 { final int WIDTH; final int HEIGHT; final double PI; // non-static-block { PI = Math.</description>
    </item>
    
    <item>
      <title>Java - OOP 物件導向特性</title>
      <link>https://sunwc2023.github.io/blog/oop/</link>
      <pubDate>Mon, 20 Mar 2023 17:35:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/oop/</guid>
      <description>encapsulation封裝性：Java提供了4種存取修飾符(private ,不寫(default), protected , public )來修飾類別及類別的內部結構，體現類別及內部結構在被存取時的可見性(visible)的大小
inheritance繼承性：減少程式碼的冗餘，也方便功能的擴展，先有一個類別(子)去繼承另一個類別(父)，而有了父類與子類的關係，子類可以使用父類的所有功能，且子類還可以在父類的基礎之上擴展其他功能 =&amp;gt; is-a 關係(子類 is a 父類)</description>
    </item>
    
    <item>
      <title>Java - 陣列快速排序法 Quick Sort</title>
      <link>https://sunwc2023.github.io/blog/quick-sort/</link>
      <pubDate>Sun, 19 Mar 2023 21:36:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/quick-sort/</guid>
      <description>值轉換數字失敗，會拋出NumberFormatException，詳情請看private static Double isNumeric(Object obj) function
/** * 題目：取得一個Object Array，包含不同data types，排除不是數字、不是浮點型的值 * 再將剩下的值使用quick sort進行排序(不可使用Arrays.</description>
    </item>
    
    <item>
      <title>Java - 陣列二分搜尋</title>
      <link>https://sunwc2023.github.io/blog/array-search/</link>
      <pubDate>Sun, 19 Mar 2023 11:15:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/array-search/</guid>
      <description>public static void main(String[] args) { // 二分搜尋 // 前提：所要搜尋的陣列必須有序 int[] arr = {-98,-34,2,34,54,66,79,105,210,333}; int target = 34; int startInx = 0; int endInx = arr.</description>
    </item>
    
    <item>
      <title>Java - 陣列反轉/字串反轉</title>
      <link>https://sunwc2023.github.io/blog/array-reversion/</link>
      <pubDate>Sun, 19 Mar 2023 11:15:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/array-reversion/</guid>
      <description>陣列反轉 public static void main(String[] args) { String[] arr = new String[] {&amp;#34;PP&amp;#34;,&amp;#34;BB&amp;#34;,&amp;#34;MM&amp;#34;,&amp;#34;GG&amp;#34;,&amp;#34;JJ&amp;#34;,&amp;#34;DD&amp;#34;,&amp;#34;MM&amp;#34;}; String temp; // 方式一、交換arr.</description>
    </item>
    
    <item>
      <title>Java - 找1-100中所有質數</title>
      <link>https://sunwc2023.github.io/blog/find-prime-number/</link>
      <pubDate>Sat, 18 Mar 2023 11:37:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/find-prime-number/</guid>
      <description>public static void main(String[] args) { for (int i = 2; i &amp;lt;= 100; i++) { boolean flag = true; // 質數是只能被1與自己整除，所以判斷非質數範圍就只能是 2 ~ (i-1) // for (int j = 2; j &amp;lt; i ; j++) { for (int j = 2; j &amp;lt;= Math.</description>
    </item>
    
    <item>
      <title>Java - 打印菱形</title>
      <link>https://sunwc2023.github.io/blog/print-diamond/</link>
      <pubDate>Sat, 18 Mar 2023 10:09:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/print-diamond/</guid>
      <description>public static void main(String[] args) { /* 內層迴圈每次執行10次 第1行(i=5) 印星號 j=5 第2行(i=4) 印星號 j=4、6 第3行(i=3) 印星號 j=3、5、7 第4行(i=2) 印星號 j=2、4、6、8 第5行(i=1) 印星號 j=1、3、5、7、9 j其餘情況印一個空白 輸出上半部： * * * * * * * * * * * * * * * */ for (int i = 5; i &amp;gt; 0; i--) { // 計算當前是第幾行，第0行即不用找下一個印星號的位置 int line = 5 - i; int nextPosition = 0; for (int j = 1; j &amp;lt; 10; j++) { // 當 內層迴圈 第一次 i == j 的時候，就先去找下一個印*號的位置 // j == nextPosition(下一個印星號的位置)，就印星號 if (line &amp;gt;= 0 &amp;amp;&amp;amp; (j == i || nextPosition == j)) { System.</description>
    </item>
    
    <item>
      <title>Java - Switch-case 計算X年X月X日為第X年第幾天</title>
      <link>https://sunwc2023.github.io/blog/days-of-year/</link>
      <pubDate>Fri, 17 Mar 2023 13:01:23 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/days-of-year/</guid>
      <description>思路：越下面的 case 被執行的機率越高，因此要從最下面的 case 1 倒著累加至第一個 case 12；由於沒有 break 語句，因此進入某個 case 後，其 case 下面的所有 case 都會被執行</description>
    </item>
    
    <item>
      <title>Java - Math.random 使用</title>
      <link>https://sunwc2023.github.io/blog/math-random/</link>
      <pubDate>Fri, 17 Mar 2023 11:37:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/math-random/</guid>
      <description>原始random區間為包含0.0且不包含1.0 =&amp;gt; [0.0,1.0)
我們可以透過公式Math.random*(b-a+1)+a 取得區間[a,b)的一個數字
public static void main(String[] args) { // 原始random區間為包含0.</description>
    </item>
    
    <item>
      <title>Java - 多型 繼承</title>
      <link>https://sunwc2023.github.io/blog/abstract-human/</link>
      <pubDate>Thu, 16 Mar 2023 14:32:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/abstract-human/</guid>
      <description>學習目標: 多型 繼承 --多型-- 撰寫一個 Human 類別 代表人 在這裡我們有兩個衍伸類別 Man 與 Woman 他們用不同的規則活著： Man : 吃飯時 印出&amp;#34;好好吃&amp;#34; 睡覺時 印出&amp;#34;zzz&amp;#34; Woman: 吃飯時 印出&amp;#34;Orzz&amp;#34; 睡覺時 印出&amp;#34;:)&amp;#34; (印出代表用System.</description>
    </item>
    
    <item>
      <title>Java - ThreadLocal 實際應用</title>
      <link>https://sunwc2023.github.io/blog/thread-local-example/</link>
      <pubDate>Wed, 15 Mar 2023 14:45:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/thread-local-example/</guid>
      <description>有關如何使用 ThreadLocal 確保 Thread-safety，可以參考我的另一篇文章 Java - ThreadLocal 類的使用
筆者曾經在不了解 ThreadLocal 類的情況下，錯用 ThreadLocal 客製Log物件的工具類，後來理解 ThreadLocal 運作原理後，在這裡特別記錄下來</description>
    </item>
    
    <item>
      <title>Java - ThreadLocal 類的使用</title>
      <link>https://sunwc2023.github.io/blog/thread-local/</link>
      <pubDate>Wed, 15 Mar 2023 13:01:00 +0800</pubDate>
      
      <guid>https://sunwc2023.github.io/blog/thread-local/</guid>
      <description>有關在實際工作上使用到 ThreadLocal 的例子，可以參考我的另一篇文章 Java - ThreadLocal 實際應用
ThreadLocal 實現原理 ThreadLocal 從字面義直翻，就是執行緒 (Thread) 的局部變數，是每一個執行緒所單獨持有，其他執行緒不能對其進行存取</description>
    </item>
    
  </channel>
</rss>
