[{"categories":["Practice"],"contents":" public static void main(String[] args) { /* 內層迴圈每次執行10次 第1行(i=5) 印星號 j=5 第2行(i=4) 印星號 j=4、6 第3行(i=3) 印星號 j=3、5、7 第4行(i=2) 印星號 j=2、4、6、8 第5行(i=1) 印星號 j=1、3、5、7、9 j其餘情況印一個空白 輸出上半部： * * * * * * * * * * * * * * * */ for (int i = 5; i \u0026gt; 0; i--) { // 計算當前是第幾行，第0行即不用找下一個印星號的位置 int line = 5 - i; int nextPosition = 0; for (int j = 1; j \u0026lt; 10; j++) { // 當 內層迴圈 第一次 i == j 的時候，就先去找下一個印*號的位置 // j == nextPosition(下一個印星號的位置)，就印星號 if (line \u0026gt;= 0 \u0026amp;\u0026amp; (j == i || nextPosition == j)) { System.out.print(\u0026#34;*\u0026#34;); if (line \u0026gt; 0) { // 當印出當前星號後，就開始找到再下個印星號的位置 nextPosition = j + 2; // 當line=0，代表當前這行的星號已經印完了 line--; } } else { // 印空白 System.out.print(\u0026#34; \u0026#34;); } } // 換行 System.out.println(); } /* 內層迴圈每次執行7次 第1行(i=5) 印星號 j=8、6、4、2 第2行(i=4) 印星號 j=7、5、3 第3行(i=3) 印星號 j=6、4 第4行(i=2) 印星號 j=5 j其餘情況印一個空白 輸出下半部： * * * * * * * * * * */ for (int i = 5; i \u0026gt; 1; i--) { // 每行開頭先印一個空白 System.out.print(\u0026#34; \u0026#34;); // 計算當前是第幾行，第0行即不用找下一個印星號的位置 int line = i - 2; int nextPosition = 0; for (int j = 8; j \u0026gt; 1; j--) { // 當 內層迴圈 第一次(i+3) == j 的時候，就先去找下一個印*號的位置 // j == nextPosition(下一個印星號的位置)，就印星號 if (line \u0026gt;= 0 \u0026amp;\u0026amp; (j == (i+3) || nextPosition == j)) { System.out.print(\u0026#34;*\u0026#34;); if (line \u0026gt; 0) { // 當印出當前星號後，就開始找到再下個印星號的位置 nextPosition = j - 2; // 當line=0，代表當前這行的星號已經印完了 line--; } } else { // 印空白 System.out.print(\u0026#34; \u0026#34;); } } // 換行 System.out.println(); } } 輸出結果：\n* * * * * * * * * * * * * * * * * * * * * * * * * ","permalink":"https://sunwc2023.github.io/blog/print-diamond/","tags":["Java"],"title":"Java - 打印菱形"},{"categories":["Practice"],"contents":" 思路：越下面的 case 被執行的機率越高，因此要從最下面的 case 1 倒著累加至第一個 case 12；由於沒有 break 語句，因此進入某個 case 後，其 case 下面的所有 case 都會被執行\n判斷該年份是否為閏年標準： 可以被4整除，但不可以被100整除 可以被400整除 public static void main(String[] args) { System.out.println(\u0026#34;請輸入年份 : \u0026#34;); Scanner scanner = new Scanner(System.in); int year = scanner.nextInt(); System.out.println(\u0026#34;請輸入月份 : \u0026#34;); int month = scanner.nextInt(); System.out.println(\u0026#34;請輸入日期 : \u0026#34;); int date = scanner.nextInt(); int result = 0; switch (month) { case 12: result += 30; case 11: result += 31; case 10: result += 30; case 9: result += 31; case 8: result += 31; case 7: result += 30; case 6: result += 31; case 5: result += 30; case 4: result += 31; case 3: // 判斷是否為閏年: true:29天 false:28天 int daysOfFeb = ((year % 4 == 0 \u0026amp;\u0026amp; year % 100 != 0) || year % 400 == 0) ? 29 : 28; result += daysOfFeb; case 2: result += 31; case 1: result += date; } System.out.println(month+\u0026#34;月\u0026#34;+date+\u0026#34;日為\u0026#34;+year+\u0026#34;年的第\u0026#34;+result+\u0026#34;天\u0026#34;); } 輸出結果： 請輸入年份 : 2008 請輸入月份 : 3 請輸入日期 : 17 3月17日為2008的第77天 ","permalink":"https://sunwc2023.github.io/blog/days-of-year/","tags":["Java"],"title":"Java - Switch-case 計算X年X月X日為X年第幾天"},{"categories":["Java"],"contents":" 原始random區間為包含0.0且不包含1.0 =\u0026gt; [0.0,1.0)\n我們可以透過公式Math.random*(b-a+1)+a 取得區間[a,b)的一個數字\npublic static void main(String[] args) { // 原始random區間為包含0.0且不包含1.0 double random = Math.random();// [0.0,1.0) // [10-99] 如何取得10-99之間的數：公式 - (b-a+1)+a int result = (int)(Math.random() * (99 - 10) + 1 + 10); System.out.println(result); // [888-999] 如何取得888-999之間的數： result = (int)(Math.random() * (999 - 888 + 1) + 888); System.out.println(result); } ","permalink":"https://sunwc2023.github.io/blog/math-random/","tags":["Java"],"title":"Java - Math.random 使用"},{"categories":["Practice"],"contents":"學習目標: 多型 繼承 --多型-- 撰寫一個 Human 類別 代表人 在這裡我們有兩個衍伸類別 Man 與 Woman 他們用不同的規則活著： Man : 吃飯時 印出\u0026#34;好好吃\u0026#34; 睡覺時 印出\u0026#34;zzz\u0026#34; Woman: 吃飯時 印出\u0026#34;Orzz\u0026#34; 睡覺時 印出\u0026#34;:)\u0026#34; (印出代表用System.our.println(...)) 使用者會輸入一個字串 代表 男人與女人 的順序 ( b -\u0026gt; 男 g -\u0026gt; 女 大小寫皆可) 像是: bgGGBgb 代表 男人有3位 女人有4位 照這個順序排列 (左到右) 之後照著順序印出所有人 吃飯 及 睡覺 的情況 需使用多型 沒頭緒的話就讀熟多型的章節 Example Input bgGGBgb output 輸入字串： bgGGBgb 好好吃 Orzz Orzz Orzz 好好吃 Orzz 好好吃 zzz :) :) :) zzz :) zzz 題目來源\n建立Human抽象類別 public abstract class Human { abstract String eating(); abstract String sleeping(); } 建立男人類別繼承Human class Man extends Human { @Override String eating() { return \u0026#34;好好吃\u0026#34;; } @Override String sleeping() { return \u0026#34;zzz\u0026#34;; } } 建立女人類別繼承Human class Woman extends Human { @Override String eating() { return \u0026#34;Orzz\u0026#34;; } @Override String sleeping() { return \u0026#34;:)\u0026#34;; } } 讓使用者輸入字串，最後照著字串順序印出所有人 吃飯 及 睡覺 的情況 mport java.util.LinkedList; import java.util.List; import java.util.Locale; import java.util.Scanner; public abstract class Human { abstract String eating(); abstract String sleeping(); public static void main(String[] args) { System.out.println(\u0026#34;請輸入一個字串 代表 男人與女人 的順序 ( b -\u0026gt; 男 g -\u0026gt; 女 大小寫皆可)\\n\u0026#34; + \u0026#34;像是: bgGGBgb 代表 男人有3位 女人有4位 照這個順序排列 (左到右)\u0026#34;); // 取得使用者的輸入 Scanner scanner = new Scanner(System.in); // 將取得的字串轉英文小寫 String bgString = scanner.next().toLowerCase(Locale.ROOT); printHumanRoutine(bgString); } /** * 照著順序印出所有人 吃飯 及 睡覺 的情況 * @param bgString */ public static void printHumanRoutine(String bgString) { List\u0026lt;Human\u0026gt; humanList = new LinkedList\u0026lt;\u0026gt;(); // 遍歷字串將男人或女人放入human集合 for (int i = 0; i \u0026lt; bgString.length(); i++) { String str = bgString.charAt(i) + \u0026#34;\u0026#34;; Human human = null; if (\u0026#34;b\u0026#34;.equals(str)) { human = new Man(); } else if (\u0026#34;g\u0026#34;.equals(str)) { human = new Woman(); } System.out.println(human.eating()); humanList.add(human); } for (int i = 0; i \u0026lt; humanList.size(); i++) { Human human = humanList.get(i); System.out.println(human.sleeping()); } } } 結論 最後我覺得 水球潘 對於這個範例的解釋太好了，所以我決定放在這裡讓這個觀念好好住在心裡:)\n在這邊 男人跟女人 是 具體的子類別 因為很清楚 這是男人 這是女人 所以稱為\u0026#34;具體\u0026#34; 那人類呢? 人類具體嗎? Human 你不知道他是哪種人 因此稱之為 \u0026#34;抽象\u0026#34;，抽象的類別 就不該把具體的內容打清楚 所以在定義Human的函數時 會不知道要打什麼內容 抽象類別是不可以被new的 因為他是抽象的 抽象類別 可以定義抽象方法 就是只跟程式說 人類會吃飯 會睡覺 但我不說清楚其具體內容 你必須告訴我你是哪個具體子類別 我才知道你 在睡覺跟吃飯時要做什麼 參考來源\n","permalink":"https://sunwc2023.github.io/blog/abstract-human/","tags":["Java"],"title":"Java - 多型 繼承"},{"categories":["Experience"],"contents":" 有關如何使用 ThreadLocal 確保 Thread-safety，可以參考我的另一篇文章 Java - ThreadLocal 類的使用\n筆者曾經在不了解 ThreadLocal 類的情況下，錯用 ThreadLocal 客製Log物件的工具類，後來理解 ThreadLocal 運作原理後，在這裡特別記錄下來\n客製 LogBox 類 import java.text.SimpleDateFormat; import java.util.Date; import java.util.LinkedList; import java.util.List; public class LogBox { private static final ThreadLocal\u0026lt;LogBox\u0026gt; currentThreadLogBox = new ThreadLocal\u0026lt;\u0026gt;(); private static final ThreadLocal\u0026lt;SimpleDateFormat\u0026gt; currentThreadSDF = new ThreadLocal\u0026lt;\u0026gt;(); private final String title; private final static String timeType = \u0026#34;yyyy-MM-dd HH:mm:ss.SSS\u0026#34;; private final List\u0026lt;String\u0026gt; logMsgList = new LinkedList\u0026lt;\u0026gt;(); public LogBox(String title) { this.title = title; } /** * 日誌訊息層級 */ public enum MessageType { MESSAGE, DEBUG, WARNING, ERROR } /** * 建立當前執行緒logBox * @param title * @return */ public static LogBox createCurrentThreadLogBox(String title) { LogBox logBox = new LogBox(title); currentThreadLogBox.set(logBox); return logBox; } /** * 取得當前執行緒logBox * 當某個request流程跨function時 * 則可以使用同一個logBox * @return */ public static LogBox getCurrentThreadLogBox() { if (currentThreadLogBox.get() == null) { createCurrentThreadLogBox(\u0026#34;title unset\u0026#34;); } return currentThreadLogBox.get(); } /** * 清除當前執行緒LogBox * 清除當前執行緒SimpleDateTimeFormat * 並取得log字串 * @return */ public String removeLogBoxAndGetLog() { removeCurrentThreadSDF(); currentThreadLogBox.remove(); StringBuilder sb = new StringBuilder(); if (logMsgList.size() \u0026gt; 0) { sb.append(\u0026#34;Log Title : \u0026#34;).append(title); logMsgList.forEach(eachLine -\u0026gt; { sb.append(\u0026#34;\\n\u0026#34;).append(\u0026#34;\\t\u0026#34;).append(eachLine); }); } sb.append(\u0026#34;\\n\u0026#34;).append(\u0026#34;=========================================================\u0026#34;); return sb.toString(); } /** * 簡略示意客製添加 info 層級 log 訊息 * @param msg */ public void info(String msg) { SimpleDateFormat simpleDateFormat = currentThreadSDF.get(); String now = simpleDateFormat.format(new Date()); msg = String.format(\u0026#34;[%s] \u0026#39;%s\u0026#39; %s\u0026#34;, MessageType.MESSAGE, now, msg); logMsgList.add(msg); } // 接收 debug、warn、error 等 log 訊息 function...... /** * 建立當前執行緒SimpleDateFormat * @return */ public static SimpleDateFormat createCurrentThreadSDF() { SimpleDateFormat sdf = new SimpleDateFormat(timeType); currentThreadSDF.set(sdf); return sdf; } /** * 取得當前執行緒SimpleDateFormat * @return */ public static SimpleDateFormat getCurrentThreadSDF() { if (currentThreadSDF.get() == null) { createCurrentThreadSDF(); } return currentThreadSDF.get(); } /** * 清除當前執行緒SimpleDateFormat */ public void removeCurrentThreadSDF() { currentThreadSDF.remove(); } } LogBox 類使用情境 情境一、這個 LogBox 類實際上是可以應用在 Filter interface\n透過建立一個客製類實作 Filter 並實現 doFilter 方法，一開始透過 createCurrentThreadLogBox(title) 建立屬於該 request (該執行緒) 的 ThreadLocal\u0026lt;LogBox\u0026gt; 物件，中間還可以從 request 中取得 requestURI、requestParams 並取得 response 等資訊都加入 ThreadLocal\u0026lt;LogBox\u0026gt; ，等程式從controller層回到 doFilter 再 removeLogBoxAndGetLog() 清除當前執行緒 ThreadLocal\u0026lt;LogBox\u0026gt;\n因為有上面提及的這層操作，因此在SpringBoot framework 的 Controller 或 Service 層的 function 中，就只需要getCurrentThreadLogBox() 取得當前執行緒的 LogBox，並將當前API、業務邏輯所需顯示的 log 內容，透過 log.info(\u0026quot;xxxx\u0026quot;), log.error(exeption message),\u0026hellip; 將不同層級訊息加到 LogBox 中\n圖片來源\n情境二、這個 LogBox 類實際上是可以應用在 quartz 排程\n透過建立一個客製類繼承 QuartzJobBean 並覆寫 executeInternal 方法，一開始透過 createCurrentThreadLogBox(title) 建立屬於該排程 (該執行緒) 的 ThreadLocal\u0026lt;LogBox\u0026gt; 物件；不過，此方法可能會再存取 ScheduleService 類的方法，因此在 ScheduleService 層就只需要　getCurrentThreadLogBox() 取得當前執行緒的 LogBox ，並添加業務邏輯所需顯示的 log 內容，透過 log.info(\u0026quot;xxxx\u0026quot;), log.error(exeption message),\u0026hellip; 將不同層級訊息加到 LogBox 中，等排程快結束時程式回到 executeInternal 方法，再 removeLogBoxAndGetLog() 清除當前執行緒 ThreadLocal\u0026lt;LogBox\u0026gt;\n筆者在理解 ThreadLocal 後，但是卻在下面例子的當程式走到 callTransferLimitUpPer30Mins()內部時，該 function 的 log 都印不出來；\n原來的寫法： 在 callTransferLimitUpPer30Mins() function 的內部，才 getCurrentThreadLogBox() 取得當前執行緒的 LogBox，最後才發現這個坑是跟 ExecutorService interface 有關；\n改善後的寫法： 將 LogBox 物件當作傳參送到 callTransferLimitUpPer30Mins(logBox) ，才解決了問題，請看以下例子：\n@Slf4j @DisallowConcurrentExecution public class RaiseupTransferLimitJob extends QuartzJobBean { @Autowired CancelRaiseupLimitTask cancelRaiseupLimitTask; public static final String TASK_NAME = QuartzTaskNameConstants.raiseupTransferLimt; public static final String PROP_NAME = \u0026#34;quartz.findBeforeSystemTimeLessThan1Day\u0026#34;; public RaiseupTransferLimitJob() { QuartzJobService.descriptionMap.put(TASK_NAME, \u0026#34;re-send raiseupTransferLimit\u0026#34;); QuartzJobService.taskDisplayNameMap.put(TASK_NAME, TASK_NAME); } @Override public void executeInternal(JobExecutionContext jobExecutionContext) { String logTitle = new Exception().getStackTrace()[0].getClassName()+\u0026#34;.\u0026#34;+new Exception().getStackTrace()[0].getMethodName(); LogBox logBox = LogBox.createCurrentThreadLogBox(logTitle); logBox.info(\u0026#34;start running callTransferLimitUpPer30Mins\u0026#34;); try { cancelRaiseupLimitTask.cancelTaskPer60MINS(); } catch (Exception e) { logBox.error(e); } finally { logBox.info(\u0026#34;end run callTransferLimitUpPer30Mins\u0026#34;); String logString = logBox.removeLogBoxAndGetLog(); if (logString != null \u0026amp;\u0026amp; logString.trim().length() \u0026gt; 0) { log.info(logString); } } } } public void cancelTaskPer60MINS() throws Exception { LogBox logBox = LogBox.getThreadLocalLogBox(); ExecutorService executor = Executors.newSingleThreadExecutor(); Future\u0026lt;String\u0026gt; future = executor.submit(() -\u0026gt; { // 需求是若排程有timeout情況產生，單一排程至多執行60分鐘\tcallTransferLimitUpPer30Mins(logBox); // 排程業務邏輯 logBox.info(\u0026#34;callTransferLimitUpPer30Mins is completed!\u0026#34;); return \u0026#34;Ready!\u0026#34;; }); try { logBox.info(\u0026#34;Every 60 minutes is started..\u0026#34;); // 設置最大等待時間 logBox.info(future.get(60, TimeUnit.MINUTES)); logBox.info(\u0026#34;Every 60 minutes is finished!\u0026#34;); } catch (TimeoutException e) { // 允許取消正在運行的執行緒——以拋出異常的方式中斷 future.cancel(true); logBox.info(\u0026#34;callTransferLimitUpPer30Mins is terminated!\u0026#34;); } executor.shutdownNow(); logBox.info(\u0026#34;cancelTaskPer60MINS shutdown now\u0026#34;); } 圖片參考\n關於 log 印不出來，我的想法是 原來在主執行緒的 LogBox ，與 Executors 建立的單一執行緒裡的 LogBox 彼此之間是不互相影響的；但是只有主執行緒的 LogBox 可以印出 log (因為最後有 removeLogBoxAndGetLog() )，所以我就必須將主執行緒產生出來的 LogBox 當作傳參送入 callTransferLimitUpPer30Mins(logBox)，這樣就沒問題啦！\n","permalink":"https://sunwc2023.github.io/blog/thread-local-example/","tags":["Java"],"title":"Java - ThreadLocal 實際應用"},{"categories":["Java"],"contents":" 有關在實際工作上使用到 ThreadLocal 的例子，可以參考我的另一篇文章 Java - ThreadLocal 實際應用\nThreadLocal 實現原理 ThreadLocal 從字面義直翻，就是執行緒 (Thread) 的局部變數，是每一個執行緒所單獨持有，其他執行緒不能對其進行存取\nThreadLocal 支持泛型，也就是支持 value 是可以設置的，像是 ThreadLocal\u0026lt;Integer\u0026gt; 就是設置 value 為 Integer 類型\n每個執行緒會有自己一份 ThreadLocalMap 副本，去儲存這個執行緒自己想存放的 ThreadLocal\u0026lt;T\u0026gt; 變數們，ThreadLocalMap 副本內部儲存的是一個 key-value 對，其中 key 是某個 ThreadLocal\u0026lt;T\u0026gt; 物件實例 ， value 就是這個執行緒、該 ThreadLocal\u0026lt;T\u0026gt; 物件實例 set 的值，所以對一個執行緒來說，一個 ThreadLocal\u0026lt;T\u0026gt; 只能存一個值，而一個執行緒可以存放多個 ThrealLocal\u0026lt;T\u0026gt;\npublic class Thread implements Runnable { // Thread 類裡的threadLocals 存放此執行緒的專有 ThreadLocalMap 副本 ThreadLocal.ThreadLocalMap threadLocals = null; } public class ThreadLocal\u0026lt;T\u0026gt; { // 根據執行緒，取得那個執行緒自己的 ThreadLocalMap ThreadLocalMap getMap(Thread t) { return t.threadLocals; } static class ThreadLocalMap { // ThreadLocalMap 的 key 是使用 \u0026#34;弱引用\u0026#34; 的 ThreadLocal\u0026lt;T\u0026gt; static class Entry extends WeakReference\u0026lt;ThreadLocal\u0026lt;?\u0026gt;\u0026gt; { Object value; // ThreadLocalMap 中的 key 就是 ThreadLocal\u0026lt;T\u0026gt;，value 就是設置的值 Entry(ThreadLocal\u0026lt;?\u0026gt; k, Object v) { super(k); value = v; } } } public T get() { // 取得當前執行緒 Thread t = Thread.currentThread(); // 每個執行緒 都有一個自己的 ThreadLocalMap // ThreadLocalMap 裡就保存著所有的ThreadLocal\u0026lt;T\u0026gt;變數 ThreadLocalMap map = getMap(t); if (map != null) { // ThreadLocalMap 的 key 就是當前 ThreadLocal\u0026lt;T\u0026gt; 物件實例 // 多個 ThreadLocal\u0026lt;T\u0026gt; 變數都是放在這個 map 中的 ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) // 從 map 裡取出來的值就是我們需要的這個 ThreadLocal\u0026lt;T\u0026gt; 變數 T result = (T)e.value; return result; } } // 如果 map 沒有初始化，那麼在這裡初始化一下 return setInitialValue(); } public void set(T value) { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) { map.set(this, value); } else { createMap(t, value); } } public void remove() { ThreadLocalMap map = getMap(Thread.currentThread()); if (map != null) { map.remove(this); } } } ThreadLocal 常用方法 set(x) : 設置此執行緒的想要放的值 x get() : 取得此執行緒當初存放的值，如果沒有存放過則返回 null remove() : 刪除此執行緒的 key-value 對，也就是如果先執行 remove 再執行 get，會返回 null 可以創建多個 ThreadLocal\u0026lt;T\u0026gt; 物件，對每個 ThreadLocal\u0026lt;T\u0026gt; 都設置不同的值\n像是以下的例子，在 main 執行緒中的 ThreadLocalMap ，就有兩個 key-value 的映射，userIdThreadLocal -\u0026gt; 100、userNameThreadLocal -\u0026gt; hello public class Main { public static void main(String[] args){ ThreadLocal\u0026lt;Integer\u0026gt; userIdThreadLocal = new ThreadLocal\u0026lt;\u0026gt;(); ThreadLocal\u0026lt;String\u0026gt; userNameThreacLocal = new ThreadLocal\u0026lt;\u0026gt;(); userId.set(100); userName.set(\u0026#34;hello\u0026#34;); } } ThreadLocal 存在內存洩露 這邊不多去探討這個議題，內存洩漏是可以避免的，只要當前執行緒要結束前記得即時的remove()，也就是是使得 ThreadLocalMap 中不要存在這個 key-value 對，這樣才能確保 GC 能正確回收\n以下有更多的文章，仔細地談論 ThreadLocal 內存洩漏問題 與 Java 自身解決的方式，但都不治本！還是當前執行緒用完 ThreadLocal 記得呼叫remove()，才是確保線程安全的根本之道！\n參考資料：\nJava - ThreadLocal 類的使用\nThreadLocal使用與原理\nSimpleDateFormat 非線程安全？ 由於 SimpleDateFormat 本身非 synchronized ，所以如果在不同執行緒使用同一個 SimpleDateFormat ，就會導致輸出的時間異常，請看以下的例子\npublic static void main(String[] args) { DateFormat sdf = new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); Date date1 = new Date(1614820308016L); Date date2 = new Date(1615820309016L); System.out.println(\u0026#34;初始定義時間1 : \u0026#34; + sdf.format(date1)); System.out.println(\u0026#34;初始定義時間2 : \u0026#34; + sdf.format(date2)); Thread t1 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 100; i++) { String dateStr = sdf.format(date1); if (!\u0026#34;2021-03-04 09:11:48\u0026#34;.equals(dateStr)) { System.out.println(Thread.currentThread().getName() + \u0026#34;異常時間為 : \u0026#34; + dateStr); } } }, \u0026#34;thread 1\u0026#34;); Thread t2 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 100; i++) { String dateStr = sdf.format(date2); if (!\u0026#34;2021-03-15 22:58:29\u0026#34;.equals(dateStr)) { System.out.println(Thread.currentThread().getName() + \u0026#34;異常時間為 : \u0026#34; + dateStr); } } }, \u0026#34;Thread 2\u0026#34;); t1.start(); t2.start(); try { t1.join(); t2.join(); } catch (InterruptedException e) { e.printStackTrace(); } } 輸出異常：(Thread2 輸出了 Thread1 的時間)\n初始定義時間1 : 2021-03-04 09:11:48 初始定義時間2 : 2021-03-15 22:58:29 Thread 2異常時間為 : 2021-03-04 09:11:48 但是， ThreadLocal 可以解決非線程安全的問題，只要在各自的執行緒，持有各自的ThreadLocal\u0026lt;DateFormat\u0026gt;，就不會有問題了，請看下面的例子\npublic static void main(String[] args) { DateFormat sdf = new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); Date date1 = new Date(1614820308016L); Date date2 = new Date(1615820309016L); System.out.println(\u0026#34;初始定義時間1 : \u0026#34; + sdf.format(date1)); System.out.println(\u0026#34;初始定義時間2 : \u0026#34; + sdf.format(date2)); Thread t1 = new Thread(() -\u0026gt; { ThreadLocal\u0026lt;DateFormat\u0026gt; currentSDF = new ThreadLocal\u0026lt;\u0026gt;(); DateFormat df1 = new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); currentSDF.set(df1); DateFormat dateFormat1 = currentSDF.get(); for (int i = 0; i \u0026lt; 100; i++) { String dateStr = dateFormat1.format(date1); if (!\u0026#34;2021-03-04 09:11:48\u0026#34;.equals(dateStr)) { System.out.println(Thread.currentThread().getName() + \u0026#34;異常時間為 : \u0026#34; + dateStr); } } currentSDF.remove(); }, \u0026#34;thread 1\u0026#34;); Thread t2 = new Thread(() -\u0026gt; { ThreadLocal\u0026lt;DateFormat\u0026gt; currentSDF = new ThreadLocal\u0026lt;\u0026gt;(); DateFormat df2 = new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); currentSDF.set(df2); DateFormat dateFormat2 = currentSDF.get(); for (int i = 0; i \u0026lt; 100; i++) { String dateStr = dateFormat2.format(date2); if (!\u0026#34;2021-03-15 22:58:29\u0026#34;.equals(dateStr)) { System.out.println(Thread.currentThread().getName() + \u0026#34;異常時間為 : \u0026#34; + dateStr); } } currentSDF.remove(); }, \u0026#34;Thread 2\u0026#34;); t1.start(); t2.start(); try { t1.join(); t2.join(); } catch (InterruptedException e) { e.printStackTrace(); } } 輸出正常：\n初始定義時間1 : 2021-03-04 09:11:48 初始定義時間2 : 2021-03-15 22:58:29 參考來源\n","permalink":"https://sunwc2023.github.io/blog/thread-local/","tags":["Java"],"title":"Java - ThreadLocal 類的使用"},{"categories":["Go Language"],"contents":"Heading 1 Heading 2 Heading 3 Heading 4 Heading 5 Heading 6 Emphasis Emphasis, aka italics, with asterisks or underscores.\nStrong emphasis, aka bold, with asterisks or underscores.\nCombined emphasis with asterisks and underscores.\nStrikethrough uses two tildes. Scratch this.\nLink I\u0026rsquo;m an inline-style link\nI\u0026rsquo;m an inline-style link with title\nI\u0026rsquo;m a reference-style link\nI\u0026rsquo;m a relative reference to a repository file\nYou can use numbers for reference-style link definitions\nOr leave it empty and use the link text itself.\nURLs and URLs in angle brackets will automatically get turned into links. http://www.example.com or http://www.example.com and sometimes example.com (but not on Github, for example).\nSome text to show that the reference links can follow later.\nParagraph Lorem ipsum dolor sit amet consectetur adipisicing elit. Quam nihil enim maxime corporis cumque totam aliquid nam sint inventore optio modi neque laborum officiis necessitatibus, facilis placeat pariatur! Voluptatem, sed harum pariatur adipisci voluptates voluptatum cumque, porro sint minima similique magni perferendis fuga! Optio vel ipsum excepturi tempore reiciendis id quidem? Vel in, doloribus debitis nesciunt fugit sequi magnam accusantium modi neque quis, vitae velit, pariatur harum autem a! Velit impedit atque maiores animi possimus asperiores natus repellendus excepturi sint architecto eligendi non, omnis nihil. Facilis, doloremque illum. Fugit optio laborum minus debitis natus illo perspiciatis corporis voluptatum rerum laboriosam.\nList List item List item List item List item List item Unordered List List item List item List item List item List item Code and Syntax Highlighting Inline code has back-ticks around it.\nvar s = \u0026#34;JavaScript syntax highlighting\u0026#34;; alert(s); s = \u0026#34;Python syntax highlighting\u0026#34; print s No language indicated, so no syntax highlighting. But let\u0026#39;s throw in a \u0026lt;b\u0026gt;tag\u0026lt;/b\u0026gt;. Blockquote This is a blockquote example.\nInline HTML You can also use raw HTML in your Markdown, and it\u0026rsquo;ll mostly work pretty well.\nTables Colons can be used to align columns.\nTables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 There must be at least 3 dashes separating each header cell. The outer pipes (|) are optional, and you don\u0026rsquo;t need to make the raw Markdown line up prettily. You can also use inline Markdown.\nMarkdown Less Pretty Still renders nicely 1 2 3 Image Youtube video ","permalink":"https://sunwc2023.github.io/blog/post-16/","tags":["Photos","Game","HTML","Python","New"],"title":"How To Use Checklists To Improve Your UX"}]