[{"categories":["SQL"],"contents":"最左前綴(最左匹配) 原則： 按照查詢條件順序來建立索引(規律的索引順序)，從左到右建立順序。 例如 當查詢條件有col2 = ? 以及 col1 = ? 和 col2 = ?，這種情況下建立 複合索引 時，要將col2欄位宣告在索引欄位前面會比較合適，像index_name(col2, col1)；若查詢條件有col1 = ? 以及 col2 = ? 以及 col1 = ? 和 col2 = ?，那就可以選擇建立兩個索引，col1和col2建立 複合索引，col2再 單獨 建立一個索引，遵循 複合索引 規則條件下，將一些索引進行合併，減少索引的數量。\n參考來源\n索引失效的場景(進行了全表掃描) 1.對索引欄位進行計算，或使用了函數。 若查詢條件在where子句進行計算的公式盡量在 = 的右邊。\n2.查詢中的資料型態與欄位型態不一致時，隱式類型轉換也會導致索引失效。\n3.違反索引的最左前綴(最左匹配)原則\n4.全表掃描更快。優化器評估找到目標索引後，還要評估要遍歷的索引數與全表總筆數的比例，若比例較高，優化器就可能考慮全表掃描\n參考來源\n字串型態欄位如何建立索引 對於較長的字串，例如email地址，可以只針對字串的前面一部分字符建立索引，就已經接近整個字串資料的不同值的比例，也就是說用前綴字串資料就差不多能替代整個字串了，替代的比例高達95%以上。\n前綴索引可以達到節省儲存空間，也不會對查詢性能產生明顯的影響。 不過，前綴索引無法利用覆蓋索引優化技術，無法實現唯一性。\n參考來源\n資料庫性能優化目的與方式 目的：主要目標就是減少掃描(訪問)硬碟的機率。 方式： 使用記憶體緩存，將會頻繁地存取的資料放在記憶體 索引SQL優化 MSSQL、MySQL底層使用的資料結構(B+ Tree)\n叢集索引 非叢集索引 參考來源\n資料結構參考網站\n","permalink":"https://sunwc2023.github.io/blog/sql/sql-index/","tags":["SQL"],"title":"資料庫索引 之 性能優化"},{"categories":["Java"],"contents":"為什麼要使用 Reflection？ 有時候我們無法確定，當程式執行起來時，對應不同時機要使用什麼物件來幫我們做事，就會使用 Reflection 機制，在需要的時候才建立對應的物件來處理當前要做的事，所以我們可以說 Reflection 擁有一種 機動性 建物件的功能\nReflection 與 Encapsulation(封裝) 是衝突的嗎？ 基本上封裝性的核心在於定義物件的成員時，要設定物件成員的存取權限，因此設定權限的本質，就是告訴開發人員，哪些是適合直接去使用的，若某些物件成員，在建立類別時就定義為不想直接被存取，撇開安全性的問題，有時更像是定義的人認定這個物件成員是不需要被開發人員使用到的，因為那些公開可以直接被使用的物件成員，其實就已經完全提供了這個物件應該實現的功能；而映射的出現，雖然說能夠存取私有的物件成員，但是也不代表我們使用映射就是為了去存取那些被定義為私有的物件成員；更多的使用只是為了能夠在需要動態產生對應物件做事時，使用這個映射的方式取得物件罷了。\n關於 java.lang.Class 類的理解 類的加載過程 程式經過執行 javac.exe 指令後，會產生一個或多個字節碼文件(.class)；接著我們使用 java.exe 指令對某個字節碼文件進行解釋執行。相當於將某個字節碼文件加載到記憶體中，此過程就稱為類的加載；加載到記憶體中的類，我們就稱為執行時期的類，此執行時期的類，就作為Class的一個實例 取得 Class 實例的方式 /** * @author sunwc * @create 2023-04-03 下午 02:26 */ public class ReflectionTest { /** * java.lang.Class 取得執行時期的類的四種方式 * @throws ClassNotFoundException */ @Test public void buildInstanceByClass() throws ClassNotFoundException { // 方式一 Class\u0026lt;Person\u0026gt; clazz1 = Person.class; System.out.println(clazz1); // 方式二 Person lily = new Person(\u0026#34;Lily\u0026#34;, 18); Class\u0026lt;? extends Person\u0026gt; clazz2 = lily.getClass(); System.out.println(clazz2); // 方式三 - 較常使用 Class\u0026lt;?\u0026gt; clazz3 = Class.forName(\u0026#34;com.atguigu.java.Person\u0026#34;); System.out.println(clazz3); System.out.println(clazz1 == clazz2); System.out.println(clazz2 == clazz3); // 方式四 ClassLoader classLoader = ReflectionTest.class.getClassLoader(); Class\u0026lt;?\u0026gt; clazz4 = classLoader.loadClass(\u0026#34;com.atguigu.java.Person\u0026#34;); System.out.println(clazz4 == clazz1); } } Person 類\n/** * @author sunwc * @create 2023-04-03 下午 02:23 */ public class Person { public String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } private Person(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { final StringBuilder sb = new StringBuilder(\u0026#34;Person{\u0026#34;); sb.append(\u0026#34;name=\u0026#39;\u0026#34;).append(name).append(\u0026#39;\\\u0026#39;\u0026#39;); sb.append(\u0026#34;, age=\u0026#34;).append(age); sb.append(\u0026#39;}\u0026#39;); return sb.toString(); } } 加載到記憶體中執行時期的類，會緩存一定的時間；在此時間之內，我們可以通過以上不同的方式來取得 哪些類型可以透過 java.lang.Class 取得執行時期的類？ 1.全部.class文件的類都算\n2.interface\n3.陣列\n4.列舉類\n5.annotation：註解@interface\n6.基本資料型態\n7.void\nClassLoader 讀取 .properties /** * @author sunwc * @create 2023-04-03 下午 03:05 */ public class ClassLoaderTest { @Test public void readPropertiesTest() throws IOException { Properties prop = new Properties(); // 方式一 FileInputStream fis = new FileInputStream(\u0026#34;src\\\\jdbc1.properties\u0026#34;); prop.load(fis); // 方式二 使用類加載器 // ClassLoader classLoader = ClassLoaderTest.class.getClassLoader(); // // 類加載器若要讀取 ResourceBundle 文件，會默認在當前module的src folder下尋找 // InputStream is = classLoader.getResourceAsStream(\u0026#34;jdbc1.properties\u0026#34;); // prop.load(is); String user = prop.getProperty(\u0026#34;user\u0026#34;); String password = prop.getProperty(\u0026#34;password\u0026#34;); System.out.println(\u0026#34;user = \u0026#34; + user + \u0026#34;, password = \u0026#34; + password); } } 執行時期類建立實例 /** * newInstance() 建立執行時期類的實例 * 調用此方法會去存取其執行時期類的無參建構子 * 且我們在宣告java bean的時候，通常會準備一個public權限的無參建構子 * 以便進行 映射(reflection) 建立 執行時期類的實例時，不會拋出 IllegalAccessException 例外；也以便於子類繼承此執行時期類時，默認調用super()時，保證父類有此建構子 * @throws InstantiationException * @throws IllegalAccessException */ @Test public void newInstanceTest() throws InstantiationException, IllegalAccessException { Class\u0026lt;Person\u0026gt; clazz = Person.class; Person person = clazz.newInstance(); System.out.println(person); } 若調用 Class 的 newInstance() 時，該執行時期類在宣告時沒有提供無參的建構子，則會拋出java.lang.InstantiationException: com.atguigu.java.Person例外，把以下的建構子加上就好了： public Person() { } 使用 Random.nextInt() 隨機產生執行時期的類 =\u0026gt; 體會映射的動態性 之需要告知classpath\n@Test public void getInstanceTest() { // 隨機輸出 0,1,2 數字 int number = new Random().nextInt(3); String classPath = \u0026#34;\u0026#34;; switch (number) { case 0: classPath = \u0026#34;java.lang.String\u0026#34;; break; case 1: classPath = \u0026#34;com.atguigu.java.Person\u0026#34;; break; case 2: classPath = \u0026#34;java.util.Date\u0026#34;; break; } try { Object instance = getInstance(classPath); System.out.println(instance.getClass()); } catch (Exception e) { e.printStackTrace(); } } private Object getInstance(String classPath) throws Exception { Class\u0026lt;?\u0026gt; clazz = Class.forName(classPath); return clazz.newInstance(); } newInstance() 相當於去調用當前執行時期類的無參建構子\n執行時期類中指定的結構：屬性、方法、建構子 /** * @author sunwc * @create 2023-04-04 下午 09:52 */ public class ReflectionTest { /** * 如何操作執行時期類的指定屬性 * @throws Exception */ @Test public void fieldTest() throws Exception { Class clazz = Goat.class; // 建立執行時期類的實例 Goat goat = (Goat) clazz.newInstance(); // 取得指定的屬性 // public static String CATEGORY = \u0026#34;domestic\u0026#34;; Field variety = clazz.getField(\u0026#34;variety\u0026#34;); /** * 1.default/private權限無法透過 getField(String fieldName) 取得屬性值 * 要透過 getDeclaredField(String fieldName) * 而private權限可透過透過 getDeclaredField(String fieldName)取得屬性值, * 但是前提是該Field必須設定 setAccessible(true); */ // int age; Field age = clazz.getDeclaredField(\u0026#34;age\u0026#34;); // private int weight; Field weight = clazz.getDeclaredField(\u0026#34;weight\u0026#34;); // 2.保證當前屬性是可以存取的 weight.setAccessible(true); /** * 3.指定當前屬性的值 set(param1, param2) * param1：指名指定哪個實例的屬性 * param2：將屬性值指定為多少 */ variety.set(goat, \u0026#34;山羊\u0026#34;); age.set(goat, 2); weight.set(goat, 3); /** * 4.取得當前屬性的值 get(param1) * param1：取得哪個實例的當前屬性值 */ String gVariety = (String) variety.get(goat); System.out.println(\u0026#34;public static String CATEGORY = \\\u0026#34;domestic\\\u0026#34;; get(param1) : \u0026#34; + gVariety); int gAge = (int) age.get(goat); System.out.println(\u0026#34;int age; get(param1) : \u0026#34; + gAge); int gWeight = (int) weight.get(goat); System.out.println(\u0026#34;private int weight; get(param1) : \u0026#34; + gWeight); } /** * 如何操作執行時期類的指定方法 * @throws Exception */ @Test public void methodTest() throws Exception { Class clazz = Goat.class; // 建立執行時期類的實例 Goat goat = (Goat) clazz.newInstance(); /** * 1.取得指定的某個方法 * getDeclaredMethod(param1, param2) * param1 指名取得的方法名稱 * param2 指名取得方法的參數列表 */ // private String sleep(String dozingSound) Method sleep = clazz.getDeclaredMethod(\u0026#34;sleep\u0026#34;, String.class); // 2.保證當前方法是可以存取得 sleep.setAccessible(true); /** * 3.調用 Method 的 invoke(param1, param2) * param1 方法的調用者 * param2 將方法參數列表提供實際值 * 此方法 return 對應類中調用方法的回傳值 */ String dozingSound = (String) sleep.invoke(goat, \u0026#34;zzzzZZZZZ\u0026#34;); System.out.println(\u0026#34;private String sleep(String dozingSound) return :\u0026#34; + dozingSound); // String play() Method play = clazz.getDeclaredMethod(\u0026#34;play\u0026#34;); Object returnVal = play.invoke(goat); System.out.println(\u0026#34;String play() return : \u0026#34; + returnVal); // private static void getDesc() Method getDesc = clazz.getDeclaredMethod(\u0026#34;getDesc\u0026#34;); getDesc.setAccessible(true); /** * 靜態方法調用invoke()時，不需指定執時時期類也能夠調用 * Object returnVal = getDesc.invoke(null); */ returnVal = getDesc.invoke(Goat.class); // 因為調用的方法沒有回傳值，所以為null System.out.println(\u0026#34;private static void getDesc() return : \u0026#34; + returnVal); } /** * 如何操作執行時期類的指定建構子 * @throws Exception */ @Test public void constructorTest() throws Exception { Class clazz = Goat.class; /** * 1.取得指定的建構子 private Goat(String name) * getDeclaredConstructor(param1) * param1：指名建構子的參數列表 */ Constructor constructor = clazz.getDeclaredConstructor(String.class); // 2.保證此建構子是可以存取的 constructor.setAccessible(true); // 3.調用此建構子建立執行時期類的實例 Goat goat = (Goat) constructor.newInstance(\u0026#34;山羊妹妹\u0026#34;); System.out.println(\u0026#34;private Goat(String name) toString : \u0026#34; + goat); } } Goat類\n/** * https://www.baeldung.com/java-reflection * @author sunwc * @create 2023-04-04 上午 04:50 */ /** * Since the superclass Animal implements Eating, Goat will have to implement that interface\u0026#39;s methods as well */ public class Goat extends Animal { public String variety; int age; private int weight; public Goat() { super(\u0026#34;goat\u0026#34;); } private Goat(String name) { super(name); } private String sleep(String dozingSound) { return dozingSound; } String play() { return \u0026#34;play with friends\u0026#34;; } private static void getDesc() { System.out.println(\u0026#34;我是一隻可愛的山羊\u0026#34;); } @Override public String toString() { final StringBuilder sb = new StringBuilder(\u0026#34;Goat{\u0026#34;); sb.append(\u0026#34;variety=\u0026#39;\u0026#34;).append(variety).append(\u0026#39;\\\u0026#39;\u0026#39;); sb.append(\u0026#34;, age=\u0026#34;).append(age); sb.append(\u0026#34;, name=\u0026#39;\u0026#34;).append(name).append(\u0026#39;\\\u0026#39;\u0026#39;); sb.append(\u0026#39;}\u0026#39;); return sb.toString(); } } abstract class Animal { public static String CATEGORY = \u0026#34;domestic\u0026#34;; public String name; public Animal(String name) { this.name = name; } public static String getCATEGORY() { return CATEGORY; } public static void setCATEGORY(String CATEGORY) { Animal.CATEGORY = CATEGORY; } public String getName() { return name; } public void setName(String name) { this.name = name; } } ","permalink":"https://sunwc2023.github.io/blog/reflection/reflection/","tags":["Java"],"title":"Java - Reflection"},{"categories":["Java"],"contents":"通信雙方地址 IP：網路定位的唯一一台主機，Java中表示 IP 地址，為 InetAddress 類；\n分為IPv4(例如 192.168.0.1)、IPv6(例如 3ffe:3201:1401:1280:c8ff:fe4d:db39:1984)；私有IP地址(局部網域)範圍即為192.168.0.0 ~ 192.168.255.255\nPort 號：定位主機上哪一個應用程序(Process)在執行；Port 號用來區分一台主機上的不同應用程序的 Process\ndomain(域名)：在 browser 輸入域名，透過DNS(域名解析服務器)取得實際IP地址後、連接實際的Web server\n遵循一定的規則(網路通信協議) 網路通信協議分層思想： TCP, UDP的差別 TCP協議： 使用TCP協議前，須先建立TCP連接，形成傳輸資料通道 傳輸前，採用“三次握手”方式，點對點通信，是可靠的 握手機制：保證對方都在 TCP協議進行通信的兩個應用Process：客戶端、服務端 在連接中可進行大資料量的傳輸 傳輸完畢，需釋放已建立的連接，效率低 建立連接需三次握手 關閉連接需四次揮手 UDP協議：適合播放影片 將資料、源、目的 封裝成數據包，不需要建立連接 每個資料報的大小限制在64K內 發送不管對方是否準備好，接收方收到也不確認，故是不可靠的 可以廣播發送 發送資料結束時無需釋放資源，開銷小，速度快 @Test public void inetAddressTest() { try { // 取得域名IP InetAddress google = InetAddress.getByName(\u0026#34;www.google.com\u0026#34;); System.out.println(google); // 取得域名 System.out.println(google.getHostName()); // 取得IP地址 System.out.println(google.getHostAddress()); // 取得本機IP InetAddress host1 = InetAddress.getLocalHost(); System.out.println(host1); } catch (UnknownHostException e) { e.printStackTrace(); } } 模擬客戶端連接、發送訊息至服務器端 範例一 ** * 實現TCP網路編程 * @author sunwc * @create 2023-04-02 下午 02:37 */ public class SocketTest { /** * 模擬客戶端 */ @Test public void client() { Socket socket = null; OutputStream os = null; try { InetAddress inetAddress = InetAddress.getByName(\u0026#34;127.0.0.1\u0026#34;); // 創建Socket物件，指明服務器端的IP與port號 socket = new Socket(inetAddress, 8899); // 取得輸出流，用於輸出資料 os = socket.getOutputStream(); // 寫出資料 os.write(\u0026#34;你好，這邊是客戶端\u0026#34;.getBytes(StandardCharsets.UTF_8)); } catch (IOException e) { e.printStackTrace(); } finally { // 關閉資源 if (os != null) { try { os.close(); } catch (IOException e) { e.printStackTrace(); } } if (socket != null) { try { socket.close(); } catch (IOException e) { e.printStackTrace(); } } } } /** * 模擬服務器端 */ @Test public void server() { ByteArrayOutputStream baos = null; ServerSocket serverSocket = null; Socket socket = null; InputStream is = null; try { // 創建服務器端的ServerSocket，指名自己的port號 serverSocket = new ServerSocket(8899); // 接收客戶端的Socket socket = serverSocket.accept(); // 取得輸入流 is = socket.getInputStream(); // 暫時用baos儲存所有bytes baos = new ByteArrayOutputStream(); byte[] buffer = new byte[20]; int len; while ((len = is.read(buffer)) != -1) { baos.write(buffer, 0, len); } System.out.println(baos.toString()); System.out.println(\u0026#34;收到來自 客戶端：\u0026#34; + socket.getInetAddress().getHostAddress() + \u0026#34;的資料\u0026#34;); } catch (IOException e) { e.printStackTrace(); } finally { if (baos != null) { try { baos.close(); } catch (IOException e) { e.printStackTrace(); } } if (is != null) { try { is.close(); } catch (IOException e) { e.printStackTrace(); } } if (socket != null) { try { socket.close(); } catch (IOException e) { e.printStackTrace(); } } if (serverSocket != null) { try { serverSocket.close(); } catch (IOException e) { e.printStackTrace(); } } } } } 範例二 ** * 從客戶端發送文件給服務器端，服務器端保存文件至本地，並回傳“發送成功”給客戶端 * @author sunwc * @create 2023-04-02 下午 04:30 */ public class TCPTest { @Test public void client() throws IOException { // 1. 建立客戶端Socket Socket socket = new Socket(\u0026#34;127.0.0.1\u0026#34;, 9090); // 2. 取得輸入流讀取本地文件 FileInputStream fis = new FileInputStream(\u0026#34;girl.png\u0026#34;); // 3. 取得輸出流 OutputStream os = socket.getOutputStream(); // 4. 進行讀寫操作 byte[] buffer = new byte[1024]; int len; while ((len = fis.read(buffer)) != -1) { os.write(buffer, 0, len); } // 5. socket關閉資料的輸出 socket.shutdownOutput(); // 6. 接收來自於服務器端的反饋，將資料顯示在console上 // 考量接收的訊息輸出的console可能有亂碼問題，故使用ByteArrayOutputStream InputStream is = socket.getInputStream(); ByteArrayOutputStream baos = new ByteArrayOutputStream(); buffer = new byte[20]; while ((len = is.read(buffer)) != -1) { baos.write(buffer, 0, len); } System.out.println(baos.toString()); // 7. 關閉資源 baos.close(); is.close(); os.close(); fis.close(); socket.close(); } @Test public void server() throws IOException { // 1. 建服務器Socket ServerSocket ss = new ServerSocket(9090); // 2. 接收客戶端Socket Socket socket = ss.accept(); // 3. 取得輸入流 InputStream is = socket.getInputStream(); // 4. 準備輸出流：將從客戶端取得的圖片寫至本地 FileOutputStream fos = new FileOutputStream(\u0026#34;girl_final.png\u0026#34;); // 5. 讀寫操作 byte[] buffer = new byte[1024]; int len; while ((len = is.read(buffer)) != -1) { fos.write(buffer, 0, len); } System.out.println(\u0026#34;服務器端圖片寫出完成\u0026#34;); // 6. 服務器端給予客戶端反饋 OutputStream os = socket.getOutputStream(); os.write(\u0026#34;您好，服務器端有收到您傳過來的圖片了\u0026#34;.getBytes(StandardCharsets.UTF_8)); // 7.關閉資源 os.close(); fos.close(); is.close(); socket.close(); ss.close(); } } 範例三 /** * 客戶端給服務端發送txt文件，服務端將文件轉成大寫再回傳給客戶端 * @author sunwc * @create 2023-04-02 下午 05:39 */ public class TCPTest2 { @Test public void client() throws IOException { // 1. 建立與服務器端連接的socket Socket socket = new Socket(\u0026#34;127.0.0.1\u0026#34;,9999); // 2. 讀取本地文件並暫時保存在 ByteArrayOutputStream FileInputStream fis = new FileInputStream(\u0026#34;english.txt\u0026#34;); ByteArrayOutputStream baos = new ByteArrayOutputStream(); // 3. 取得輸出流 OutputStream os = socket.getOutputStream(); byte[] buffer = new byte[20]; int len; while ((len = fis.read(buffer)) != -1) { baos.write(buffer, 0, len); } // 4. 一次性寫出資料到服務器端 os.write(baos.toByteArray()); // 5. socket關閉輸出資料 socket.shutdownOutput(); // 6. 取得服務器端大寫英文字的資料並將資料寫到本地文件 InputStream is = socket.getInputStream(); FileOutputStream fos = new FileOutputStream(\u0026#34;english_final.txt\u0026#34;); buffer = new byte[20]; while ((len = is.read(buffer)) != -1) { fos.write(buffer, 0, len); } // 7. 關閉資源 fos.close(); is.close(); os.close(); baos.close(); fis.close(); socket.close(); } @Test public void server() throws IOException { // 1. 建立服務器端socket ServerSocket ss = new ServerSocket(9999); // 2. 接收客戶端socket Socket socket = ss.accept(); // 3. 接收輸入流並將資料暫時寫入 ByteArrayOutputStream InputStream is = socket.getInputStream(); ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte[] buffer = new byte[20]; int len; while ((len = is.read(buffer)) != -1) { baos.write(buffer, 0, len); } System.out.println(\u0026#34;服務器端文件接收完成\u0026#34;); // 4. 將 ByteArrayOutputStream 資料一次性將英文字轉大寫 String upperCase = baos.toString().toUpperCase(Locale.ROOT); // 5. 一次性寫出大寫英文字資料到客戶端 OutputStream os = socket.getOutputStream(); os.write(upperCase.getBytes(StandardCharsets.UTF_8)); System.out.println(\u0026#34;服務器端文件轉大寫並傳輸完成\u0026#34;); // 6. 關閉資源 os.close(); baos.close(); is.close(); socket.close(); ss.close(); } } ","permalink":"https://sunwc2023.github.io/blog/networkprogramming/network/","tags":["Java"],"title":"Java - 網路通信"},{"categories":["Java"],"contents":"System類 System.in：標準輸入，默認s從鍵盤輸入；其類別為InputStream System.out：標準輸出，默認從console輸出；其類別為PrintStream，為OutputStream的子類 練習一 System.in(return InputStream 類) 讀取鍵盤輸入的兩種方式 從鍵盤輸入字串，要求將讀取到的整行字串轉成大寫輸出。然後繼續進行輸入操作，直至當輸入“e”或“exit”時，退出程式\npublic static void main(String[] args) { // 方法一 使用Scanner實現 // Scanner scan = new Scanner(System.in); // while (true) { // System.out.println(\u0026#34;請輸入一段文字：\u0026#34;); // String input = scan.next().toLowerCase(Locale.ROOT); // if (\u0026#34;e\u0026#34;.equals(input) || \u0026#34;exit\u0026#34;.equals(input)) { // break; // } // // String upper = input.toUpperCase(Locale.ROOT); // System.out.println(upper); // } // 方法二 使用 System.in 實現：System.in 回傳 InputStream // =\u0026gt; 使用 InputStreamReader 將 InputStream(字節流) 轉 =\u0026gt; BufferedReader(字符流) // 1. 將讀取鍵盤的輸入(byte[])轉成(char[]) BufferedReader br = null; try { InputStreamReader isr = new InputStreamReader(System.in); br = new BufferedReader(isr); while (true) { System.out.println(\u0026#34;請輸入一段文字：\u0026#34;); String line = br.readLine(); if (\u0026#34;e\u0026#34;.equalsIgnoreCase(line) || \u0026#34;exit\u0026#34;.equalsIgnoreCase(line)) { System.out.println(\u0026#34;程式結束\u0026#34;); break; } // 轉大寫輸出 System.out.println(line.toUpperCase(Locale.ROOT)); } } catch (IOException e) { e.printStackTrace(); } finally { if (br != null) { // 關閉流 try { br.close(); } catch (IOException e) { e.printStackTrace(); } } } } 練習二 System.out(return PrintStream 類) 輸出至console改為輸出至文件 /** * 將System.out 默認輸出內容至console * 但我們可以透過System.setOut()的方式 * 將內容輸出至指定文件(此指定文件可以不存在、但是此指定文件上層的目錄必須存在) */ @Test public void printStreamTest() { PrintStream ps = null; try { FileOutputStream fos = new FileOutputStream(new File(\u0026#34;C:\\\\io\\\\testSystemSetOut.txt\u0026#34;)); ps = new PrintStream(fos); System.setOut(ps); // 欲輸出的內容 for (int i = 0; i \u0026lt; 255; i++) { System.out.print((char) i); // 輸出ascii碼 if (i % 50 == 0) { // 每行50個字符就換行 System.out.println(); } } } catch (FileNotFoundException e) { e.printStackTrace(); } finally { if (ps != null) { ps.close(); } } } Data Stream 作用：為了將記憶體中的基本資料型態(byte/short/char/int/long/float/double/boolean)、String 類的資料輸出到指定文件，就可以使用 Data OutputStream；為了將指定文件內容輸入到程式中，就可以使用 Data InputStream 練習三 DataInputStream、DataOutputStream /** * 使用DataOutputStream將基本資料型態資料輸出到文件 */ @Test public void dataOutStreamTest() { DataOutputStream dos = null; try { dos = new DataOutputStream(new FileOutputStream(\u0026#34;C:\\\\io\\\\testDataOutputStream.txt\u0026#34;)); dos.writeUTF(\u0026#34;sunwc\u0026#34;); dos.flush(); // 刷新，將記憶體資料寫到文件 dos.writeInt(124); dos.flush(); dos.writeChar(\u0026#39;c\u0026#39;); dos.flush(); dos.writeBoolean(false); dos.flush(); } catch (IOException e) { e.printStackTrace(); } finally { if (dos != null) { try { dos.close(); } catch (IOException e) { e.printStackTrace(); } } } } /** * 使用DataInputStream將文件內容輸入到程式中 */ @Test public void dataInputStreamTest() { DataInputStream dis = null; try { dis = new DataInputStream(new FileInputStream(\u0026#34;C:\\\\io\\\\testDataOutputStream.txt\u0026#34;)); // 按照寫入的順序輸出資料型態 String name = dis.readUTF(); int number = dis.readInt(); char ch = dis.readChar(); boolean b = dis.readBoolean(); System.out.printf(\u0026#34;%s, %d, %c, %b\u0026#34;, name, number, ch, b); } catch (IOException e) { e.printStackTrace(); } finally { if (dis != null) { try { dis.close(); } catch (IOException e) { e.printStackTrace(); } } } } ObjectInputStream, ObjectOutputStream 序列化：用 ObjectOutputStream 將基本資料型態或物件資料寫入文件 反序列化：用 ObjectInputStream 讀取文件將內容轉成基本資料型態或物件資料 什麼是物件序列化？ 是允許將記憶體中的Java物件轉換成二進制流保存在硬碟中；或通過網路將這種二進制流傳輸到另一個網路節點\n什麼是反序列化？ 當其他程式取得了這種二進制流，就可以恢復其至原來的Java物件\n@Test public void objectOutputStreamTest() { /** * 序列化過程：將記憶體中的Java物件以文件形式儲存到硬碟中或通過網路傳輸出去(Java物件 =\u0026gt; 二進制流) * 使用ObjectOutputStream */ ObjectOutputStream oos = null; try { oos = new ObjectOutputStream(new FileOutputStream(\u0026#34;objectOutputStream.dat\u0026#34;)); // serialized oos.writeObject(new String(\u0026#34;將Java物件序列化\u0026#34;)); oos.flush(); // 刷新並寫出 } catch (IOException e) { e.printStackTrace(); } finally { if (oos != null) { try { oos.close(); } catch (IOException e) { e.printStackTrace(); } } } } @Test public void objectInputStreamTest() { /** * 反序列化過程：將硬碟中文件二進制流轉成Java物件；或是將從網路上取得的二進制流轉換成Java物件(二進制流 =\u0026gt; Java物件) */ ObjectInputStream ois = null; try { ois = new ObjectInputStream(new FileInputStream(\u0026#34;objectOutputStream.dat\u0026#34;)); Object o = ois.readObject(); if (o instanceof String) { String deserialized = (String) o; System.out.println(deserialized); } } catch (IOException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } finally { if (ois != null) { try { ois.close(); } catch (IOException e) { e.printStackTrace(); } } } } 自定義物件序列化的規則 1.當前物件需要實現 interface Serializable，並保證其屬性也是可序列化的\n2.當前類提供一個全局常量(static final) serialVersionUID\n3.static、transient 關鍵字修飾的成員屬性無法序列化(即序列化過程的值無法保存)\n/** * @author sunwc * @create 2023-04-01 下午 02:48 */ public class CustomizedClassObjectStreamTest { @Test public void objectOutputStreamTest() { ObjectOutputStream oos = null; try { oos = new ObjectOutputStream(new FileOutputStream(\u0026#34;person.dat\u0026#34;)); // Serialize oos.writeObject(new String(\u0026#34;先序列化String物件\u0026#34;)); oos.flush(); // Serialize oos.writeObject(new Person(\u0026#34;Lily\u0026#34;, 27)); oos.flush(); } catch (IOException e) { e.printStackTrace(); } finally { if (oos != null) { try { oos.close(); } catch (IOException e) { e.printStackTrace(); } } } } @Test public void objectInputStreamTest() { ObjectInputStream ois = null; try { ois = new ObjectInputStream(new FileInputStream(\u0026#34;person.dat\u0026#34;)); // Deserialize String str = (String) ois.readObject(); System.out.println(str); // Deserialize Person person = (Person) ois.readObject(); System.out.println(person); } catch (IOException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } finally { if (ois != null) { try { ois.close(); } catch (IOException e) { e.printStackTrace(); } } } } } class Person implements Serializable { public static final long serialVersionUID = 483742747387L; String name; int age; public Person(String name, int age) { this.name = name; this.age = age; } @Override public String toString() { final StringBuilder sb = new StringBuilder(\u0026#34;Person{\u0026#34;); sb.append(\u0026#34;name=\u0026#39;\u0026#34;).append(name).append(\u0026#39;\\\u0026#39;\u0026#39;); sb.append(\u0026#34;, age=\u0026#34;).append(age); sb.append(\u0026#39;}\u0026#39;); return sb.toString(); } } ","permalink":"https://sunwc2023.github.io/blog/io/other-stream/","tags":["Java"],"title":"Java - System.in、 System.out, PrintStream, Data Stream"},{"categories":["Java"],"contents":"流的分類 1.操作資料單位：字節流、字符流\n2.資料的流向：輸入流、輸出流\n3.流的角色：節點流、處理流\n流的體系結構 文件輸入字符流(FileReader)：read() @Test public void fileReaderTest() { FileReader fr = null; try { File file = new File(\u0026#34;hello.txt\u0026#34;); // System.out.println(file.getAbsolutePath()); // 準備具體的文件字符流 fr = new FileReader(file); // 每次調用read()即讀取一個字符 // 當方法回傳-1時，代表以至文件末尾 int aChar; while ((aChar = fr.read()) != -1) { System.out.print((char) aChar); } } catch (IOException e) { e.printStackTrace(); } finally { // 關閉流 if (fr != null) { try { fr.close(); } catch (IOException e) { e.printStackTrace(); } } } } 文件輸入字符流(FileReader)：int read(char[] ch) 有快遞車一次載5個商品，直到載完全部的商品；每次會回報這次實際載了幾個商品\n@Test public void fileReaderWithCharArr() { FileReader fr = null; try { File file = new File(\u0026#34;hello.txt\u0026#34;); fr = new FileReader(file); // 新建一個字符陣列，可以至多一次讀5個字符 char[] chBuffer = new char[5]; // len 接收每次讀取的實際字符數 // 若已至文件末尾，回傳-1 int len; while ((len = fr.read(chBuffer)) != -1) { // 方式一 // for (int i = 0; i \u0026lt; len; i++) { // System.out.print(chBuffer[i]); // } // 方式二 // 將char陣列轉字串輸出 String s = new String(chBuffer, 0, len); System.out.print(s); } } catch (IOException e) { e.printStackTrace(); } finally { if (fr != null) { try { fr.close(); } catch (IOException e) { e.printStackTrace(); } } } } 文件輸出字符流(FileWriter)：write(String str)/ write(char[] ch) @Test public void fileWriterTest() { FileWriter fw = null; try { File file = new File(\u0026#34;hello1.txt\u0026#34;); // new FileWriter(File file, boolean append) // append 屬性默認為false，新寫出的內容會覆蓋原來的內容 // append 屬性為true，則會在原有基礎上附加內容 fw = new FileWriter(file, false); // 方式一 // fw.write(\u0026#34;I am using file writer at the beginning.\\n\u0026#34;); // fw.write(\u0026#34;this is another line\u0026#34;); // 方式二 String content = \u0026#34;I am using file writer at the beginning.\\nthis is another line\u0026#34;; fw.write(content.toCharArray()); } catch (IOException e) { e.printStackTrace(); } finally { if (fw != null) { try { fw.close(); } catch (IOException e) { e.printStackTrace(); } } } } 文件輸入輸出一起操作(複製文件)：使用文件流讀取字符(char) @Test public void copyDocumentTest() { FileReader fr = null; FileWriter fw = null; try { File srcDoc = new File(\u0026#34;hello.txt\u0026#34;); File destDoc = new File(\u0026#34;hello2.txt\u0026#34;); fr = new FileReader(srcDoc); fw = new FileWriter(destDoc, false); char[] chBuffer = new char[5]; int len; while ((len = fr.read(chBuffer)) != -1) { // len的長度為實際讀取的字符數 // 因此也可以作為寫出的實際字符數 fw.write(chBuffer, 0, len); } } catch (IOException e) { e.printStackTrace(); } finally { try { if (fw != null) { fw.close(); } } catch (IOException e) { e.printStackTrace(); } try { if (fr != null) { fr.close(); } } catch (IOException e) { e.printStackTrace(); } } } 圖片輸入輸出一起操作(複製圖片) 讀取字節使用文件流(FileInputStream)：int read(byte[] bytes)/ 寫入字節使用文件流(FileOutputStream)：write(byte[] bytes, int offset, int count) /** * 圖片複製 */ @Test public void imageCopyTest() { FileInputStream fis = null; FileOutputStream fos = null; try { File srcImg = new File(\u0026#34;girl.png\u0026#34;); File destImg = new File(\u0026#34;girl2.png\u0026#34;); // 準備字節輸入流物件 fis = new FileInputStream(srcImg); // 準備字節輸出流物件 fos = new FileOutputStream(destImg); // 一次讀取至多1024 bytes byte[] byteBuffer = new byte[1024]; // 每次讀取會回傳實際讀取的bytes數 // 若回傳-1，代表已讀完整的圖片 int len; while ((len = fis.read(byteBuffer)) != -1) { // 依據本次實際讀取的字節數寫出 fos.write(byteBuffer,0, len); } } catch (IOException e) { e.printStackTrace(); } finally { if (fis != null) { try { fis.close(); } catch (IOException e) { e.printStackTrace(); } } if (fos != null) { try { fos.close(); } catch (IOException e) { e.printStackTrace(); } } } } 影片輸入輸出一起操作(影片複製)：使用緩衝流讀取字節(byte) 提高流的讀取、寫入的速度，原因：內部提供了一個緩衝區\n@Test public void videoCopyTest() { String srcPath = \u0026#34;C:\\\\Users\\\\ching\\\\Desktop\\\\google-video.mp4\u0026#34;; String destPath = \u0026#34;C:\\\\Users\\\\ching\\\\Desktop\\\\google-video1.mp4\u0026#34;; long start = System.currentTimeMillis(); copyFile(srcPath,destPath); long end = System.currentTimeMillis(); System.out.println(end - start); // 4599 1321 } private void copyFile(String srcPath, String destPath) { BufferedInputStream bis = null; BufferedOutputStream bos = null; try { File srcImg = new File(srcPath); File destImg = new File(destPath); // 準備字節輸入流物件 FileInputStream fis = new FileInputStream(srcImg); bis = new BufferedInputStream(fis); // 準備字節輸出流物件 FileOutputStream fos = new FileOutputStream(destImg); bos = new BufferedOutputStream(fos); // 一次讀取至多1024 bytes byte[] byteBuffer = new byte[1024]; // 每次讀取會回傳實際讀取的bytes數 // 若回傳-1，代表已讀完整的圖片 int len; while ((len = bis.read(byteBuffer)) != -1) { // 依據本次實際讀取的字節數寫出 bos.write(byteBuffer, 0, len); } } catch (IOException e) { e.printStackTrace(); } finally { if (bis != null) { try { bis.close(); } catch (IOException e) { e.printStackTrace(); } } if (bos != null) { try { bos.close(); } catch (IOException e) { e.printStackTrace(); } } } } 讀取字符使用緩衝流(BufferReader)：int read(byte[] bytes)/ String readLine(byte[] bytes)/ 寫入字符使用緩衝流(BufferWriter)：write(char[] ch, int offset, int count)/ write(String str) @Test public void copyDocumentTest() { BufferedReader br = null; BufferedWriter bw = null; try { File srcDoc = new File(\u0026#34;hello.txt\u0026#34;); File destDoc = new File(\u0026#34;hello2.txt\u0026#34;); FileReader fr = new FileReader(srcDoc); FileWriter fw = new FileWriter(destDoc, false); br = new BufferedReader(fr); bw = new BufferedWriter(fw); char[] chBuffer = new char[5]; int len; // 方式一 // while ((len = br.read(chBuffer)) != -1) { // // len的長度為實際讀取的字符數 // // 因此也可以作為寫出的實際字符數 // bw.write(chBuffer, 0, len); // } // 方式二 // 我們可以使用BufferedReader.readLine() 代表一次讀取一行 // 但readLine() 不會配給我們換行符 // 所以可以另外調BufferedReader.newLine()換行 // 當readLine()回傳 null 代表文件已經讀到末尾了 String str; while ((str = br.readLine()) != null) { bw.write(str); // 換行 bw.newLine(); } } catch (IOException e) { e.printStackTrace(); } finally { // 只要關閉最外層的流，內層的就會一起關閉了 try { if (bw != null) { bw.close(); } } catch (IOException e) { e.printStackTrace(); } try { if (br != null) { br.close(); } } catch (IOException e) { e.printStackTrace(); } } } 轉換流(處理流) 作用：提供 字符流(char) 與 字節流(byte) 之間的轉換\n類型：\n字符流(char)： InputStreamReader：將一個字節的輸入流轉換為字符的輸入流(解碼) OutputStreamWriter：將一個字符的輸出流轉換為字節的輸出流(編碼) 解碼：byte、byte[] =\u0026gt; char[]、String 編碼：char[]、String =\u0026gt; byte、byte[] InputStreamReader 例子\n/** * 例外要以try-catch-finally處理較正規 * @throws IOException */ @Test public void inputStreamReaderTest() throws IOException { // 使用文件字節流讀取到console // 可能會有中文字亂碼的危機 FileInputStream fis = new FileInputStream(\u0026#34;words.txt\u0026#34;); // 因此要想辦法將字節流 轉換成 字符流 (解碼的過程需提供文件儲存時 指定的編碼 ) InputStreamReader isr = new InputStreamReader(fis, \u0026#34;UTF-8\u0026#34;); char[] chArr = new char[20]; int len; while ((len = isr.read(chArr)) != -1) { // 輸出方式一 String str = new String(chArr, 0, len); // 在console輸出 System.out.print(str); // 輸出方式二 // for (int i = 0; i \u0026lt; len; i++) { // System.out.print(chArr[i]); // } } // 關閉最外層的inputStreamReader就可以了 isr.close(); } 綜合使用InputStreamReader, OutputStreamWriter將文件複製一份輸出，編碼從UTF-8 改 BIG5 /** * 例外要以try-catch-finally處理較正規 * @throws IOException */ @Test public void docUTF8ToBIG5() throws IOException { File srcFile = new File(\u0026#34;words.txt\u0026#34;); File destFile = new File(\u0026#34;words_BIG5.txt\u0026#34;); FileInputStream fis = new FileInputStream(srcFile); FileOutputStream fos = new FileOutputStream(destFile); // byte[] =\u0026gt; char[] 解碼 InputStreamReader isr = new InputStreamReader(fis, \u0026#34;UTF-8\u0026#34;); // char[] =\u0026gt; byte[] 編碼 OutputStreamWriter osr = new OutputStreamWriter(fos, \u0026#34;BIG5\u0026#34;); char[] chBuffer = new char[20]; int len; while((len = isr.read(chBuffer)) != -1) { osr.write(chBuffer, 0, len); } osr.close(); isr.close(); } 使用 ByteArrayOutputStream 實現複製文件 使用 ByteArrayOutputStream 的好處：若輸入流讀取後的資料直接寫入 ByteArrayOutputStream 儲存，就不用擔心每個字符到底對應幾個byte，因為在使用byte[] 盛裝資料時，可能會因為本次array空間不足就只儲存一個字符對應的部分bytes、而導致當要將bytes轉回字符時而產生亂碼的問題；ByteArrayOutputStream 底層是使用陣列append所有bytes之後，再一次性地將資料轉換成字串\n/** * 使用 ByteArrayOutputStream 實現複製文件 * 例外要以try-catch-finally處理較正規 * @throws IOException */ @Test public void byteArrayOutputStreamTest() throws IOException { FileInputStream fis = new FileInputStream(\u0026#34;hello.txt\u0026#34;); FileOutputStream fos = new FileOutputStream(\u0026#34;hello2.txt\u0026#34;); ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte[] buffer = new byte[20]; int len; while ((len = fis.read(buffer)) != -1) { // 先將從byte[] 讀取的字節保存到 ByteArrayOutputStream baos.write(buffer, 0, len); } // 再一次性地將 ByteArrayOutputStream 的資料寫入到文件 baos.writeTo(fos); // 關閉流 baos.close(); fos.close(); fis.close(); } 使用 StringBuilder 接收讀取的字符(指定編碼)資料並一次性輸出至console /** * 使用 StringBuilder 接收讀取的字符資料並一次性輸出至console * 例外要以try-catch-finally處理較正規 */ @Test public void consoleStringBuilderTest() throws IOException { FileInputStream fis = new FileInputStream(\u0026#34;hello.txt\u0026#34;); InputStreamReader isr = new InputStreamReader(fis, \u0026#34;Big5\u0026#34;); // 輸出console 準備 StringBuilder 接收資料 StringBuilder sb = new StringBuilder(); char[] chBuffer = new char[20]; int len; while ((len = isr.read(chBuffer)) != -1) { sb.append(new String(chBuffer, 0, len)); } System.out.println(sb.toString()); isr.close(); } ","permalink":"https://sunwc2023.github.io/blog/io/read-write/","tags":["Java"],"title":"Java - InputStream, OutputStream \u0026 Reader, Writer"},{"categories":["Java"],"contents":"File 類的使用 1.File 類的一個物件，代表一個文件或一個文件目錄(俗稱：文件夾)\n2.File 類宣告在 java.io package下\n3.File 類涉及到關於文件或文件目錄的創建、刪除、重命名、修改時間、取得文件大小等方法，並未涉及到寫入或讀取文件內容的操作。如果需要讀取或寫入文件內容，必須使用IO流來完成\n4.File 類的物件常會作為參數傳遞到流的 constructor 中，指名讀取或寫入的 “終點”\nFile 常用方法 public String getAbsolutePath()：取得絕對路徑 public String getPath()：取得路徑 public String getName()：取得名稱 public String getParent()：取得上層文件目錄路徑；若無，回傳null public long length()：取得文件長度(即byte數)；不能取得目錄的l長度 public long lastModified()：取得最後一次的修改時間，毫秒值 /** * 測試當文件都不存在的時候 */ @Test public void fileTest() { File file1 = new File(\u0026#34;hello.txt\u0026#34;); File file2 = new File(\u0026#34;d:\\\\io\\\\hi.txt\u0026#34;); System.out.println(file1.getAbsolutePath()); System.out.println(file1.getPath()); System.out.println(file1.getName()); System.out.println(file1.getParent()); System.out.println(file1.length()); System.out.println(new Date(file1.lastModified())); System.out.println(); System.out.println(file2.getAbsolutePath()); System.out.println(file2.getPath()); System.out.println(file2.getName()); System.out.println(file2.getParent()); System.out.println(file2.length()); System.out.println(file2.lastModified()); } 輸出結果：\nC:\\Users\\ching\\IdeaProjects\\JavaSenior\\day08\\hello.txt hello.txt hello.txt null 11 Thu Mar 30 10:21:01 GMT+08:00 2023 d:\\io\\hi.txt d:\\io\\hi.txt hi.txt d:\\io 0 0 public String[] list()：取得指定目錄下的所有文件或者文件目錄的名稱陣列 public File[] listFiles()：取得指定目錄下的所有文件或文件目錄的File陣列 @Test public void listFileTest() { File file = new File(\u0026#34;C:\\\\Users\\\\ching\\\\IdeaProjects\\\\JavaSenior\u0026#34;); String[] list = file.list(); for(String name: list) { System.out.println(name); } System.out.println(); File[] files = file.listFiles(); for (File file1 : files) { System.out.println(file1); } } 輸出結果：\n.idea day01 day02 day03 day04 day05 day06 day07 day08 JavaSenior.iml out C:\\Users\\ching\\IdeaProjects\\JavaSenior\\.idea C:\\Users\\ching\\IdeaProjects\\JavaSenior\\day01 C:\\Users\\ching\\IdeaProjects\\JavaSenior\\day02 C:\\Users\\ching\\IdeaProjects\\JavaSenior\\day03 C:\\Users\\ching\\IdeaProjects\\JavaSenior\\day04 C:\\Users\\ching\\IdeaProjects\\JavaSenior\\day05 C:\\Users\\ching\\IdeaProjects\\JavaSenior\\day06 C:\\Users\\ching\\IdeaProjects\\JavaSenior\\day07 C:\\Users\\ching\\IdeaProjects\\JavaSenior\\day08 C:\\Users\\ching\\IdeaProjects\\JavaSenior\\JavaSenior.iml C:\\Users\\ching\\IdeaProjects\\JavaSenior\\out public boolean renameTo(File dest)：把文件重命名為指定的文件路徑，例如file1.renameTo(file2) 若想要保證回傳 true， file1 需在硬碟中、且 file2 目錄在硬碟中但檔案不在硬碟中\n@Test public void renameToTest() { File file1 = new File(\u0026#34;C:\\\\Users\\\\ching\\\\IdeaProjects\\\\JavaSenior\\\\day08\\\\hello.txt\u0026#34;); File file2 = new File(\u0026#34;C:\\\\io\\\\hi.txt\u0026#34;); if (!file2.exists()) { new File(file2.getParent()).mkdir(); } System.out.println(file1.renameTo(file2)); } public boolean isDirectory()：判斷是否是文件目錄 public boolean isFile()：判斷是否是文件 public boolean exists()：判斷是否存在 public boolean canRead()：判斷是否可讀 public boolean canWrite()：判斷是否可寫 public boolean isHidden()：判斷是否隱藏 @Test public void fileBooleanTest() { // 存在的檔案 File file1 = new File(\u0026#34;C:\\\\Users\\\\ching\\\\IdeaProjects\\\\JavaSenior\\\\hello.txt\u0026#34;); // 不存在的檔案 file1 = new File(\u0026#34;C:\\\\Users\\\\ching\\\\IdeaProjects\\\\JavaSenior\\\\hello1.txt\u0026#34;); System.out.println(file1.exists()); System.out.println(file1.isFile()); System.out.println(file1.isDirectory()); System.out.println(file1.canWrite()); System.out.println(file1.canRead()); System.out.println(file1.isHidden()); System.out.println(); // 存在的目錄 File file2 = new File(\u0026#34;C:\\\\io\u0026#34;); // 不存在的目錄 file2 = new File(\u0026#34;C:\\\\io1\u0026#34;); System.out.println(file2.exists()); System.out.println(file2.isFile()); System.out.println(file2.isDirectory()); System.out.println(file2.canWrite()); System.out.println(file2.canRead()); System.out.println(file2.isHidden()); } 創建硬碟對應的文件或文件目錄 public boolean createNewFile()：創建文件；若文件存在，則不創建，回傳false\npublic boolean mkdir()：創建文件目錄；若此文件目錄存在，就不創建了；若此文件目錄的上層目錄不存在，也不創建\npublic boolean mkdirs()：創建文件目錄；若上層目錄不存在，一並創建\npublic boolean delete()：刪除文件或者文件夾；注意Java中的刪除不走回收站\n@Test public void fileCreationTest() throws IOException { // 不存在的檔案 File file1 = new File(\u0026#34;hello1.txt\u0026#34;); if (!file1.exists()) { file1.createNewFile(); System.out.println(\u0026#34;創建成功\u0026#34;); } else { file1.delete(); System.out.println(\u0026#34;刪除成功\u0026#34;); } } 練習 判斷指定目錄下是否有後綴名為.jpg的文件，如果有，就輸出該文件名稱 @Test public void getPostfixJPG() { File file = new File(\u0026#34;C:\\\\Users\\\\ching\\\\Pictures\u0026#34;); File[] files = file.listFiles(); for (File file1 : files) { String fileName = file1.getName(); if (fileName.endsWith(\u0026#34;.jpg\u0026#34;)) { System.out.println(fileName); } } } 創建一個與 file 同目錄下的另一個文件，文件名為：helloworld.txt @Test public void createNewFileTest() throws IOException { File file = new File(\u0026#34;C:\\\\Users\\\\ching\\\\IdeaProjects\\\\JavaSenior\\\\day08\\\\hello.txt\u0026#34;); File destFile = new File(file.getParent(), \u0026#34;helloworld.txt\u0026#34;); if (!destFile.exists()) { destFile.createNewFile(); System.out.println(\u0026#34;創建成功\u0026#34;); } } 遍歷指定目錄所有文件名稱，包括子文件目錄中的文件 拓展1：並計算指定目錄下所有檔案佔用空間的大小 @Test public void loopAllUnderTheDirectory() { File file = new File(\u0026#34;C:\\\\IdeaProjects\\\\ infotrends-plugin-cathay\u0026#34;); long totalOccupied = printFilePath(file); System.out.println(totalOccupied); } /** * 這道題涉及到了遞迴，對遞迴的感悟是： * \u0026lt;p\u0026gt; * 每執行一次遞迴方法就開闢一塊不同的Stack空間，所以遞迴方法裡變數儘管同名，但值不同。 * 遞迴如果按層次理解，遞迴先往內一層一層進入，在最內層方法執行結束後，外層的方法沒有結束（return），會再往外一層層return。最重要的是取得每層方法的回傳值結果。 * * @param dir * @return */ private long printFilePath(File dir) { long totalOccupied = 0L; if (dir.isFile()) { // 是檔案就直接做事 System.out.println(dir.getAbsolutePath()); // 是檔案就計算檔案bytes數 totalOccupied += dir.length(); } else { // 是目錄就展開目錄後再調用自己 再判斷子層裡是目錄還是檔案 File[] listFiles = dir.listFiles(); for (File listFile : listFiles) { // 收集每層遞迴方法回傳的值，而不要把需要收集的值傳遞過去 totalOccupied += printFilePath(listFile); } } return totalOccupied; } 參考來源\n拓展2：刪除指定文件目錄及其下的所有文件\n@Test public void deleteFileTest() { File file = new File(\u0026#34;C:\\\\IdeaProjects\\\\infotrends-plugin-cathay\u0026#34;); deleteFile(file); } private boolean deleteFile(File dir) { if (dir.isFile()) { // 是檔案就直接做事 dir.delete(); } else { // 是目錄就展開目錄後再調用自己 再判斷子層裡是目錄還是檔案 File[] listFiles = dir.listFiles(); for (File listFile : listFiles) { deleteFile(listFile); } } // 指定目錄此時為空，可以刪除 return dir.delete(); } 參考來源\n","permalink":"https://sunwc2023.github.io/blog/io/file/","tags":["Java"],"title":"Java - File"},{"categories":["Java"],"contents":"Collections 工具類 常用方法 reverse(List) ：反轉 List 中的元素 shuffle(List)：對 List 集合元素進行隨機排序 sort(List)：根據元素的自然順序對指定 List 集合元素按升冪排序 sort(List, Comparator)：根據指定的 Comparator 產生的順序對 List 集合元素進行排序 swap(List, int, int)：將指定 list 集合中的 index i元素 與 index j元素進行交換 Object max(Collection)：根據元素的自然排序，回傳給定集合中的最大元素 Object max(Collection, Comparator)：根據 Comparator 指定的順序，回傳給訂集合中的最大元素 Object min(Collection) Object min(Collection, Comparator) int frequency(Collection, Object)：回傳指定集合中指定元素的出現次數 void copy(List dest, List src)：將 src 中的內容複製到 dest 中 /** * @author sunwc * @create 2023-03-29 下午 03:20 */ public class CollectionsTest { @Test public void testCollections() { List list = new ArrayList(); list.add(353); list.add(0); list.add(4838); list.add(43); list.add(52); list.add(-432); list.add(9); // 使用Collecitons.copy()，要先撐開dest collection 的長度 至 source 的 長度 // tips: 先讓裝載的元素一樣多 List dest = Arrays.asList(new Object[list.size()]); // 再把值複製過來 Collections.copy(dest, list); System.out.println(dest); } } boolean replaceAll(List list, Object oldVal, Object newVal)：使用新值替換 List 對 同步控制 synchronizedXxx()方法：該方法可使指定集合包裝成執行緒同步的集合，進而解決多執行緒併發存取集合時的執行緒不安全問題 練習 隨機的數字List，請reverse list後顯示；從大到小排序顯示 @Test public void testCollections2() { List list = new ArrayList(); list.add(353); list.add(0); list.add(4838); list.add(43); list.add(52); list.add(-432); list.add(9); Collections.reverse(list); System.out.println(\u0026#34;reverse=\u0026#34;+list); Collections.sort(list, new Comparator\u0026lt;Integer\u0026gt;() { @Override public int compare(Integer o1, Integer o2) { return -Integer.compare(o1,o2); } }); System.out.println(\u0026#34;大到小=\u0026#34;+list); } 輸出結果：\nreverse=[9, -432, 52, 43, 4838, 0, 353] 大到小=[4838, 353, 52, 43, 9, 0, -432] 請把學生名與考試分數記錄到集合中，例如TreeSet(Student(id,name,score)); 並按分數顯示前三名成績的學生姓名 /** * @author sunwc * @create 2023-03-29 下午 03:20 */ public class CollectionsTest { @Test public void testCollections3() { TreeSet\u0026lt;Student\u0026gt; treeSet = new TreeSet\u0026lt;\u0026gt;(); treeSet.add(new Student(1001, \u0026#34;Jack\u0026#34;, 99)); treeSet.add(new Student(1002, \u0026#34;Hannah\u0026#34;, 88)); treeSet.add(new Student(1003, \u0026#34;Lily\u0026#34;, 45)); treeSet.add(new Student(1004, \u0026#34;Becky\u0026#34;, 84)); treeSet.add(new Student(1005, \u0026#34;May\u0026#34;, 60)); treeSet.add(new Student(1006, \u0026#34;Denial\u0026#34;, 77)); treeSet.add(new Student(1007, \u0026#34;Vicent\u0026#34;, 67)); treeSet.add(new Student(1008, \u0026#34;Potter\u0026#34;, 56)); treeSet.add(new Student(1009, \u0026#34;Hank\u0026#34;, 98)); Iterator\u0026lt;Student\u0026gt; iterator = treeSet.iterator(); int count = 0; while (iterator.hasNext() \u0026amp;\u0026amp; count \u0026lt;= 2) { Student next = iterator.next(); System.out.println(\u0026#34;學生姓名:\u0026#34;+next.getName()+\u0026#34;, 學生成績：\u0026#34;+next.getScore()); count++; } } } class Student implements Comparable\u0026lt;Student\u0026gt; { private int id; private String name; private int score; public Student(int id, String name, int score) { this.id = id; this.name = name; this.score = score; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getScore() { return score; } public void setScore(int score) { this.score = score; } @Override public String toString() { final StringBuilder sb = new StringBuilder(\u0026#34;Student{\u0026#34;); sb.append(\u0026#34;id=\u0026#34;).append(id); sb.append(\u0026#34;, name=\u0026#39;\u0026#34;).append(name).append(\u0026#39;\\\u0026#39;\u0026#39;); sb.append(\u0026#34;, score=\u0026#34;).append(score); sb.append(\u0026#39;}\u0026#39;); return sb.toString(); } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; return id == student.id \u0026amp;\u0026amp; score == student.score \u0026amp;\u0026amp; Objects.equals(name, student.name); } @Override public int hashCode() { return Objects.hash(id, name, score); } /** * 成績從高到低 * @param o * @return */ @Override public int compareTo(Student o) { return -Integer.compare(this.getScore(), o.getScore()); } } 輸出結果：\n學生姓名:Jack, 學生成績：99 學生姓名:Hank, 學生成績：98 學生姓名:Hannah, 學生成績：88 ","permalink":"https://sunwc2023.github.io/blog/collection/collections-list-set-map/","tags":["Java"],"title":"Java - Collections - 操作 Collection、Map 工具類"},{"categories":["Java"],"contents":"JDK 1.8 Collection 框架 - interface Map 架構 interface Map：雙列資料，儲存key-value對的資料\nMap 中的 key：無序的、不可重複的，使用 Set 儲存所有的 key Map 中的 value：無序的、可重複的，使用 Collection 儲存所有的 value 一個鍵值對：Key-value構成了一個 Entry 物件 Map 中的 entry：無序的、不可重複的，使用 Set 儲存所有的 entry HashMap：作為 interface Map 的主要實現類；執行緒不安全的，效率高；可以儲存null的key和value；底層使用 陣列+鏈結串列+紅黑樹\nHashMap 的 key 所在類別要覆寫 equals() 和 hashCode() HashMap 的 value 所在類別要覆寫 equals() HashMap 的底層實現原理：以 JDK 7 為例說明： 1. HashMap map = new HashMap(): 在實例化以後，底層創建了長度是16的一維陣列Entry[] table ...可能已經執行過多次put()... 2. map.put(key1,value1): 首先，調用 key1 所在類別的 hashCode() 計算 key 哈希值，此哈希值經過計算後得到在 Entry 陣列中的存放位置： 如果此位置上的資料為空，此時 key1-value1 新增成功 =\u0026gt; 情況1 如果此位置上的資料不為空，(意味著此位置上存在一個或多個資料(以鏈結串列形式存在))，比較 key1 和已經存在的一個或多個資料的哈希值： 如果 key1 的哈希值與已經存在的資料的哈希值都不同，此時 key1-value1 新增成功 =\u0026gt; 情況2 如果 key1 的哈希值和已經存在的某一個資料(key2-value2)的哈希值相同，繼續比較：調用 key1 所在類別的 equals(key2)： 如果 equals() 回傳 false：此時 key1-value1 新增成功 =\u0026gt; 情況3 如果 equals() 回傳 true：使用 value1 替換 value2 補充：關於情況2、情況3：此時 key1-value1 和原來的資料以鏈結串列的方式儲存 3. 在不斷地新增的過程中，會涉及到擴容問題，默認擴容方式，擴容為原來的2倍，並將原有的資料複製過來 HashMap 遍歷： 遍歷所有的 key 集： keySet() 遍歷所有的 value 集： values() 遍歷所有的 key-value： entrySet() HashMap 常用方法： 新增：put(Object key, Object value) 刪除：remove(Object key) 修改：put(Object key, Object value) 查詢：get(Object key) 長度：size() 遍歷：keySet()/ values()/ entrySet() LinkedHashMap：作為 HashMap 的子類；保證在遍歷map元素時，可以按照新增的順序實現遍歷 在原有的 HashMap 底層基礎上，每個元素還維護了兩個reference，紀錄資料的前一個與後一個元素的位置；對於頻繁的遍歷操作，LinkedHashMap 效率高於 HashMap TreeMap：可以按照新增元素的key進行自然排序 或 定制排序 底層結構是紅黑樹 Hashtable：作為 interface Map 的古老實現類；執行緒安全，效率低；不能儲存null的key和value\nProperties：作為 Hashtable 的子類；常用來處理配置文件；key和value都是String類別 /** * @author sunwc * @create 2023-03-29 下午 02:12 */ public class PropertiesTest { @Test public void propertiesTest() { Properties properties = new Properties(); FileInputStream fis = null; try { // 方式一、 // fis = new FileInputStream(System.getProperty(\u0026#34;user.dir\u0026#34;) + \u0026#34;\\\\jdbc.properties\u0026#34;); // 方式二、 File file = new File(\u0026#34;jdbc.properties\u0026#34;); fis = new FileInputStream(file.getAbsolutePath()); // 加載流對應文件 properties.load(fis); String name = properties.getProperty(\u0026#34;name\u0026#34;); String password = properties.getProperty(\u0026#34;password\u0026#34;); System.out.println(\u0026#34;name=\u0026#34;+name+\u0026#34;,password=\u0026#34;+password); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } finally { try { if (fis != null) { fis.close(); } } catch (IOException e) { e.printStackTrace(); } } } } 輸出結果：\nname=ching,password=ching123 ","permalink":"https://sunwc2023.github.io/blog/collection/map/","tags":["Java"],"title":"Java - Collection(二)"},{"categories":["Java"],"contents":"JDK 1.8 Collection 框架 - interface List, interface Set 架構 interface Collection：單列集合，用來儲存一個一個的物件 interface List：儲存有序的、可重複的資料 =\u0026gt; \u0026ldquo;動態\u0026quot;陣列，替換原有的陣列\nArrayList：作為 interface List 的主要實現類；執行緒不安全的，效率高；底層使用Object[] elementData儲存資料 LinkedList：對於頻繁地插入、刪除操作，使用此類效率比ArrayList高；底層使用雙向鏈結串列儲存資料 Vector：作為 interface List 的古老實現類；執行緒安全，效率低；底層使用Object[] elementData儲存資料 interface Set：儲存無序的、不可重複的資料\n無序性：儲存的資料在底層陣列中並非按照陣列索引的順序新增，而是根據資料的 hash code 決定的 不可重複性 HashSet：作為 interface Set 的主要實現類別；執行緒不安全的；可以儲存null值 HashSet 新增元素的過程： 我們向 HashSet 中新增元素a，首先調用元素a的 hashCode()，計算元素a的哈希值，以此哈希值計算出在 HashSet 底層陣列中的存放位置(即為：索引位置)，判斷陣列此索引位置上是否有元素：\n若此位置上沒有其他元素，則元素a新增成功 =\u0026gt; 情況1\r若此位置上有其他元素b(或以鏈結串列形式存在多個元素)，則比較元素a與元素b的哈希值\r若哈希值不相同，則元素a新增成功 =\u0026gt; 情況2\r若哈希值相同，進而需要調用元素a所在類別的 equals()\requals() 回傳true，元素a新增失敗\requals() 回傳false，元素a新增成功 =\u0026gt; 情況3\rHashSet 底層結構： 陣列 + 鏈結串列\n要求向 Set 新增元素時，其元素所在的類別一定要 override hashCode() 與 equals()\n要求 override 的 hashCode() 與 equals() 盡可能保持一致性：相同物件元素必須具有相同的散列碼\nLinkedHashSet：作為 HashSet 的子類；遍歷其內部資料時，可以按照新增元素的順序進行遍歷 LinkedHashSet 在新增元素時，每個元素還維護了兩個reference，紀錄資料的前一個與後一個元素的位置；對於頻繁的遍歷操作，LinkedHashSet 效率高於 HashSet TreeSet：可以按照新增元素的指定屬性進行排序\n要求向 TreeSet 新增元素時，必須是相同類別的物件 兩種排序方式：自然排序(實現 interface Comparable) 和 定制排序(實現 interface Comparator) 自然排序中，比較兩個物件是否想同的標準為：compareTo()回傳0 定制排序中，比較兩個物件是否想同的標準為：compareTo()回傳0 底層結構是紅黑樹 /** * @author sunwc * @create 2023-03-28 下午 09:31 */ public class TreeSetTest { /** * 自然排序 */ @Test public void treeSetTest() { TreeSet treeSet = new TreeSet(); treeSet.add(new User(\u0026#34;Flask\u0026#34;, 33)); treeSet.add(new User(\u0026#34;Ice\u0026#34;, 18)); treeSet.add(new User(\u0026#34;Gary\u0026#34;, 54)); treeSet.add(new User(\u0026#34;Tim\u0026#34;, 26)); treeSet.add(new User(\u0026#34;Daniel\u0026#34;, 40)); treeSet.add(new User(\u0026#34;Daniel\u0026#34;, 37)); System.out.println(treeSet.size()); // 在建立多個User物件、放入TreeSet中後，卻拋出以下例外 // java.lang.ClassCastException: com.atguigu.java.User cannot be cast to java.lang.Comparable // 因為TreeSet的特性會針對指定元素屬性進行比較，而自定義類別要有比較的功能就必須實現 interface Comparable - compareTo() // 另外，若比較User的姓名若有重複，就要在compareTo()中定義要如何比較另一個屬性， // 否則TreeSet就會認定只要新增的元素去調用compareTo()回傳的值為0時，就代表該元素是重複的而造成新增失敗；反之，就可以新增成功 Iterator iterator = treeSet.iterator(); while (iterator.hasNext()) { System.out.println(iterator.next()); } } /** * 定制排序 */ @Test public void treeSetTest2() { Comparator comparator = new Comparator\u0026lt;User\u0026gt;() { /** * 只比較年齡從小到大 * @param o1 * @param o2 * @return */ @Override public int compare(User o1, User o2) { return Integer.compare(o1.getAge(), o2.getAge()); } }; TreeSet treeSet = new TreeSet(comparator); treeSet.add(new User(\u0026#34;Flask\u0026#34;, 33)); treeSet.add(new User(\u0026#34;Ice\u0026#34;, 18)); treeSet.add(new User(\u0026#34;Gary\u0026#34;, 54)); treeSet.add(new User(\u0026#34;Tim\u0026#34;, 26)); treeSet.add(new User(\u0026#34;Daniel\u0026#34;, 26)); treeSet.add(new User(\u0026#34;Daniel\u0026#34;, 37)); Iterator iterator = treeSet.iterator(); while (iterator.hasNext()) { System.out.println(iterator.next()); } } } class User implements Comparable\u0026lt;User\u0026gt; { private String name; private int age; public User() { } public User(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { final StringBuilder sb = new StringBuilder(\u0026#34;User{\u0026#34;); sb.append(\u0026#34;name=\u0026#39;\u0026#34;).append(name).append(\u0026#39;\\\u0026#39;\u0026#39;); sb.append(\u0026#34;, age=\u0026#34;).append(age); sb.append(\u0026#39;}\u0026#39;); return sb.toString(); } /** * 排序規則 * 姓名從大到小排 * 年齡從小到大排 * @param o * @return */ @Override public int compareTo(User o) { int compareNameVal = -this.name.compareTo(o.name); // 姓名不一樣就直接回傳compareNameVal if (compareNameVal != 0) { return compareNameVal; } else { // 姓名一樣就還要再比較年齡 return Integer.compare(this.age, o.age); } } } TreeSet 自然排序 輸出結果：\n6 User{name=\u0026#39;Tim\u0026#39;, age=26} User{name=\u0026#39;Ice\u0026#39;, age=18} User{name=\u0026#39;Gary\u0026#39;, age=54} User{name=\u0026#39;Flask\u0026#39;, age=33} User{name=\u0026#39;Daniel\u0026#39;, age=37} User{name=\u0026#39;Daniel\u0026#39;, age=40} TreeSet 定制排序 輸出結果：\nUser{name=\u0026#39;Ice\u0026#39;, age=18} User{name=\u0026#39;Tim\u0026#39;, age=26} User{name=\u0026#39;Flask\u0026#39;, age=33} User{name=\u0026#39;Daniel\u0026#39;, age=37} User{name=\u0026#39;Gary\u0026#39;, age=54} 練習 面試題：ArrayList, LinkedList, Vector 三者有何不同？ 見上 相同點：三個類都是實現了 interface List，儲存資料的特點相同：儲存有序的、可重複的資料 練習一、在list中去除重複的數字值，要求盡量簡單 @Test public void test3() { List list = new ArrayList(); list.add(new Integer(1)); list.add(new Integer(2)); list.add(new Integer(2)); list.add(new Integer(4)); list.add(new Integer(4)); List list1 = removeDuplicate(list); for (Object o : list1) { System.out.println(o); } } private List removeDuplicate(List list) { Set set = new HashSet(); set.addAll(list); return new ArrayList(set); } 練習二、有點難度 public class HashSetTest { @Test public void test4() { HashSet set = new HashSet(); Person2 p1 = new Person2(1001, \u0026#34;AA\u0026#34;); Person2 p2 = new Person2(1002, \u0026#34;BB\u0026#34;); set.add(p1); set.add(p2); System.out.println(set); p1.name = \u0026#34;CC\u0026#34;; set.remove(p1); // 以1001, CC 換算hashcode找到的索引位置 沒有值 System.out.println(set); set.add(new Person2(1001, \u0026#34;CC\u0026#34;)); // 同上，1001, CC 換算hashcode找到的索引位置 沒有值，所以這個元素新增成功 System.out.println(set); set.add(new Person2(1001, \u0026#34;AA\u0026#34;)); // 以1001, AA 換算hashcode找到的索引位置 有值 但是 !\u0026#34;CC\u0026#34;.equals(\u0026#34;AA\u0026#34;)，所以這個元素也新增成功 System.out.println(set); // 最後這個set實際會輸出4個元素 } } class Person2 { int id; String name; public Person2(int id, String name) { this.id = id; this.name = name; } @Override public String toString() { final StringBuilder sb = new StringBuilder(\u0026#34;Person2{\u0026#34;); sb.append(\u0026#34;id=\u0026#34;).append(id); sb.append(\u0026#34;, name=\u0026#39;\u0026#34;).append(name).append(\u0026#39;\\\u0026#39;\u0026#39;); sb.append(\u0026#39;}\u0026#39;); return sb.toString(); } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Person2 person2 = (Person2) o; return id == person2.id \u0026amp;\u0026amp; Objects.equals(name, person2.name); } @Override public int hashCode() { return Objects.hash(id, name); } } ","permalink":"https://sunwc2023.github.io/blog/collection/list-set/","tags":["Java"],"title":"Java - Collection(一)"},{"categories":["Java"],"contents":"/** * @author sunwc * @create 2023-03-28 上午 09:56 */ public class CollectionTest { @Test public void testCollection() { Collection collection = new ArrayList\u0026lt;\u0026gt;(); Person person = new Person(\u0026#34;Jerry\u0026#34;, 20); collection.add(person); collection.add(123); collection.add(456); collection.add(false); collection.add(new String(\u0026#34;Tom\u0026#34;)); // 每次集合調用iterator()時都會得到一個全新的 迭代器 Iterator iterator = collection.iterator(); while (iterator.hasNext()) { // 走到next()後，指針才下移；所以如果要調remove()的話，要先調next() Object next = iterator.next(); // 刪除集合中的Tom if (\u0026#34;Tom\u0026#34;.equals(next)) { iterator.remove(); // 迭代的過程進行移除元素 } System.out.println(next); } System.out.println(collection.contains(new String(\u0026#34;Tom\u0026#34;))); // false } } class Person { private String name; private int age; public Person() { } public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { final StringBuilder sb = new StringBuilder(\u0026#34;Person{\u0026#34;); sb.append(\u0026#34;name=\u0026#39;\u0026#34;).append(name).append(\u0026#39;\\\u0026#39;\u0026#39;); sb.append(\u0026#34;, age=\u0026#34;).append(age); sb.append(\u0026#39;}\u0026#39;); return sb.toString(); } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Person person = (Person) o; return age == person.age \u0026amp;\u0026amp; Objects.equals(name, person.name); } } JDK 5.0 新增 集合Collection 的增強for迴圈特性 練習題 String[] arr = new String[]{\u0026#34;MM\u0026#34;,\u0026#34;MM\u0026#34;,\u0026#34;MM\u0026#34;}; // 方式一、直接改變arr[index]的元素值 for(int i = 0; i \u0026lt; arr.length; i++) { arr[i] = \u0026#34;GG\u0026#34;; } for(int i = 0; i \u0026lt; arr.length; i++) { System.out.print(arr[i]+\u0026#34;\\t\u0026#34;); // GG GG GG } String[] arr = new String[]{\u0026#34;MM\u0026#34;,\u0026#34;MM\u0026#34;,\u0026#34;MM\u0026#34;}; // 方式二、從arr取出值後，將值複製一份給變數str for(String str: arr) { str = \u0026#34;GG\u0026#34;; } for(int i = 0; i \u0026lt; arr.length; i++) { System.out.println(arr[i]+\u0026#34;\\t\u0026#34;); // MM MM MM } ","permalink":"https://sunwc2023.github.io/blog/collection/collection-iterator/","tags":["Java"],"title":"Java - Collection - iterator 方法"},{"categories":["Java"],"contents":"為什麼要使用列舉類？ 當我們在開發中，有一組常數對應不同的狀態來顯示時，就可以考慮使用 enum class\n方式一、自定義列舉類 /** * 自定義列舉類 * @author sunwc * @create 2023-03-27 下午 03:53 */ public class Season { // 1. 宣告Season物件的屬性：private final 修飾 private final String name; private final String desc; // 2. 私有的建構子，將屬性指定值 private Season(String name, String desc) { this.name = name; this.desc = desc; } /** * 提供列舉物件：public static final 修飾 */ public static final Season SPRING = new Season(\u0026#34;spring\u0026#34;, \u0026#34;春暖花開\u0026#34;); public static final Season SUMMER = new Season(\u0026#34;summer\u0026#34;, \u0026#34;盛夏光年\u0026#34;); public static final Season AUTUMN = new Season(\u0026#34;autumn\u0026#34;, \u0026#34;秋高氣爽\u0026#34;); public static final Season WINTER = new Season(\u0026#34;winter\u0026#34;, \u0026#34;寒風凜凜\u0026#34;); public String getName() { return name; } public String getDesc() { return desc; } @Override public String toString() { final StringBuilder sb = new StringBuilder(\u0026#34;Season{\u0026#34;); sb.append(\u0026#34;name=\u0026#39;\u0026#34;).append(name).append(\u0026#39;\\\u0026#39;\u0026#39;); sb.append(\u0026#34;, desc=\u0026#39;\u0026#34;).append(desc).append(\u0026#39;\\\u0026#39;\u0026#39;); sb.append(\u0026#39;}\u0026#39;); return sb.toString(); } } class EnumClassTest { @Test public void getEnumSeason() { System.out.println(Season.SPRING.getName()); System.out.println(Season.AUTUMN.getDesc()); System.out.println(Season.WINTER.toString()); } } 方式二、使用 enum 關鍵字定義 列舉類 定義的列舉類 默認繼承於 java.lang.Enum\n常用方法\n1.values()\n2.valueOf()\n3.toString()\nenum 列舉類可以 implements interface\n/** * 使用enum關鍵字定義列舉類 * @author sunwc * @create 2023-03-27 下午 03:53 */ public enum Season1 implements Info { /** * 提供列舉物件 */ SPRING(\u0026#34;spring\u0026#34;, \u0026#34;春暖花開\u0026#34;) { @Override public void show() { System.out.println(\u0026#34;這是有關春天的訊息\u0026#34;); } }, SUMMER(\u0026#34;summer\u0026#34;, \u0026#34;盛夏光年\u0026#34;) { @Override public void show() { System.out.println(\u0026#34;這是有關夏天的訊息\u0026#34;); } }, AUTUMN(\u0026#34;autumn\u0026#34;, \u0026#34;秋高氣爽\u0026#34;) { @Override public void show() { System.out.println(\u0026#34;這是有關秋天的訊息\u0026#34;); } }, WINTER(\u0026#34;winter\u0026#34;, \u0026#34;寒風凜凜\u0026#34;) { @Override public void show() { System.out.println(\u0026#34;這是有關冬天的訊息\u0026#34;); } }; // 宣告Season1物件的屬性：private final 修飾 private final String name; private final String desc; // 2. 私有的建構子，將屬性指定值 private Season1(String name, String desc) { this.name = name; this.desc = desc; } public String getName() { return name; } public String getDesc() { return desc; } } class EnumKeywordTest { @Test public void getEnumSeason1() { System.out.println(Season1.class.getSuperclass()); // class java.lang.Enum System.out.println(Season1.SPRING.getName()); System.out.println(Season1.AUTUMN.getDesc()); System.out.println(Season1.WINTER); // 遍歷所有列舉物件並調用interface抽象方法 show() for (int i = 0; i \u0026lt; Season1.values().length; i++) { Season1.values()[i].show(); } } } /** * 自定義 interface */ interface Info { void show(); } 輸出結果：\nclass java.lang.Enum spring 秋高氣爽 WINTER 這是有關春天的訊息 這是有關夏天的訊息 這是有關秋天的訊息 這是有關冬天的訊息 ","permalink":"https://sunwc2023.github.io/blog/enum/enum-class/","tags":["Java"],"title":"Java - enum class"},{"categories":["Java"],"contents":"interface java.lang.Comparable override compartTo() 自然排序 override compareTo(obj) 的規則： 如果當前物件this大於傳入物件obj，則回傳正整數 如果當前物件this小於傳入物件obj，則回傳負整數 如果當前物件this等於傳入物件obj，則回傳0 實現 interface Comparable 的有String, wrapper class, java.util.Date等類別，也因為如此它們都可以進行排序 public class Date implements java.io.Serializable, Cloneable, Comparable\u0026lt;Date\u0026gt; { } Date date1 = new Date(2023-1900, 3-1,27); Date date2 = new Date(2023-1900, 8-1,27); System.out.println(date2.compareTo(date1)); // 1 自定義類 implements Comparable override compareTo() 進行物件排序 /** * 商品類 * @author sunwc * @create 2023-03-27 上午 11:27 */ public class Goods implements Comparable { private String name; private int price; public Goods(String name, int price) { this.name = name; this.price = price; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getPrice() { return price; } public void setPrice(int price) { this.price = price; } @Override public String toString() { final StringBuilder sb = new StringBuilder(\u0026#34;Goods{\u0026#34;); sb.append(\u0026#34;name=\u0026#39;\u0026#34;).append(name).append(\u0026#39;\\\u0026#39;\u0026#39;); sb.append(\u0026#34;, price=\u0026#34;).append(price); sb.append(\u0026#39;}\u0026#39;); return sb.toString(); } /** * 指定商品比較大小的方式：按照價格從低到高排序 * @param o * @return */ @Override public int compareTo(Object o) { if (o instanceof Goods) { Goods goods = (Goods) o; // 方式一 if (this.price \u0026gt; goods.price) { return 1; } else if (this.price \u0026lt; goods.price) { return -1; } else { // return 0; // 價格相同的還可以再用名稱作為排序條件 return this.name.compareTo(goods.name); } // 方式二 // return Double.compare(this.price, goods.price); } throw new RuntimeException(\u0026#34;傳入的資料型態不符\u0026#34;); } } /** * 商品排序測試類 */ class GoodsTest { @Test public void comparableTest() { Goods[] manyMouse = new Goods[6]; manyMouse[0] = new Goods(\u0026#34;microsoft\u0026#34;, 600); manyMouse[1] = new Goods(\u0026#34;lenovo\u0026#34;, 400); manyMouse[2] = new Goods(\u0026#34;logitech\u0026#34;, 800); manyMouse[3] = new Goods(\u0026#34;steelseries\u0026#34;, 500); manyMouse[4] = new Goods(\u0026#34;kinyo\u0026#34;, 500); manyMouse[5] = new Goods(\u0026#34;cherry\u0026#34;, 500); // 若要使用Arrays.sort()對自定義物件陣列進行小到大排序，自定義類別要先覆寫 compareTo方法 Arrays.sort(manyMouse); System.out.println(Arrays.toString(manyMouse)); } } 自定義物件排序後 輸出結果\n[Goods{name=\u0026#39;lenovo\u0026#39;, price=400}, Goods{name=\u0026#39;cherry\u0026#39;, price=500}, Goods{name=\u0026#39;kinyo\u0026#39;, price=500}, Goods{name=\u0026#39;steelseries\u0026#39;, price=500}, Goods{name=\u0026#39;microsoft\u0026#39;, price=600}, Goods{name=\u0026#39;logitech\u0026#39;, price=800}] interface java.util.Comparator 定制排序 使用匿名實現類 override compare()\noverride compare(Object obj1, Object obj2) 的規則，比較obj1和obj2大小： 如果obj1大於obj2，則回傳正整數 如果obj1小於obj2，則回傳負整數 如果obj1等於obj2，則回傳0 @Test public void comparatorTest() { Goods[] manyMouse = new Goods[6]; manyMouse[0] = new Goods(\u0026#34;microsoft\u0026#34;, 600); manyMouse[1] = new Goods(\u0026#34;lenovo\u0026#34;, 400); manyMouse[2] = new Goods(\u0026#34;logitech\u0026#34;, 800); manyMouse[3] = new Goods(\u0026#34;steelseries\u0026#34;, 500); manyMouse[4] = new Goods(\u0026#34;kinyo\u0026#34;, 500); manyMouse[5] = new Goods(\u0026#34;cherry\u0026#34;, 500); // 若要使用Arrays.sort()對自定義物件陣列進行大到小排序，匿名實現類別要先覆寫 compare方法 // 條件：先按照產品名稱從低到高、再按照價格從高到低 Arrays.sort(manyMouse, new Comparator\u0026lt;Goods\u0026gt;() { @Override public int compare(Goods o1, Goods o2) { String s1 = String.valueOf(o1.getName().charAt(0)); String s2 = String.valueOf(o2.getName().charAt(0)); // name first character 相同 if (s1.equals(s2)) { // 價格從高到低(compare()原邏輯從低到高，所以要加負號變相反) return -Integer.compare(o1.getPrice(), o2.getPrice()); } else { // name first character 不同 // 名稱從低到高(compareTo()默認從低到高) return o1.getName().compareTo(o2.getName()); } } }); System.out.println(Arrays.toString(manyMouse)); } 定制排序後 輸出結果：\n[Goods{name=\u0026#39;cherry\u0026#39;, price=500}, Goods{name=\u0026#39;kinyo\u0026#39;, price=500}, Goods{name=\u0026#39;logitech\u0026#39;, price=800}, Goods{name=\u0026#39;lenovo\u0026#39;, price=400}, Goods{name=\u0026#39;microsoft\u0026#39;, price=600}, Goods{name=\u0026#39;steelseries\u0026#39;, price=500}] 總結 interface Comparable vs. interface Comparator\nComparable 的實現類別在任何位置都可以比較大小； Comparator 的 匿名實現類是屬於臨時性的比較\n","permalink":"https://sunwc2023.github.io/blog/compare/comparator-comparable/","tags":["Java"],"title":"Java - interface Comparator vs. interface Comparable"},{"categories":["Java"],"contents":"String：不可變的 CharSequence\nStringBuffer：可變的 CharSequence、且thread-safety，所以效率較低\nStringBuilder：可變的 CharSequence、非thread-safety，所以效率較高\n執行效率：StringBuilder \u0026gt; StringBuffer \u0026gt; String\nJDK source code 分析 String str = new String(); // new char[0]; String str1 = new String(\u0026#34;abc\u0026#34;); // new char[]{\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;}; // 底層創建了一個空間16的陣列 StringBuffer sb1 = new StringBuffer(); // new char[16]; sb1.append(\u0026#39;a\u0026#39;); // value[0] = \u0026#39;a\u0026#39;; sb1.append(\u0026#39;b\u0026#39;); // value[1] = \u0026#39;b\u0026#39;; StringBuffer sb2 = new StringBuffer(\u0026#34;abc\u0026#34;); // char[] value = new char[\u0026#34;abc\u0026#34;.length()+16]; // 問題1 System.out.println(sb2.length()); // 3 =\u0026gt; 實際裝入陣列的長度 // 問題2 擴容問題：若要新增的資料底層的陣列盛不下了，那就需要擴容底層的陣列，默認情況下，擴容為原來容量的2倍再加2，同時將原有陣列中的元素複製到新的陣列中 // 開發中建議使用：StringBuffer(int capacity) 或 StringBuilder(int capacity)，避免一開始就擴容 StringBuffer, StringBuilder 常見方法 總結 增 append(xxx);\r刪 delete(int start, int end)\r改 setChar(int index, char ch)/ replace(int start, int end, String str)\r查 charAt(int index)\r插入 insert(int offset, xxx)\r長度 length()\r遍歷 for loop + charAt()\r","permalink":"https://sunwc2023.github.io/blog/string/string-buffer/","tags":["Java"],"title":"Java - StringBuffer, StringBuilder"},{"categories":["Java"],"contents":"JDK 8 以前日期時間API java.lang.System.currentTimeMillis()：回傳(long值)當前時間與1970年1月1日0時0分0秒之間以毫秒為單位的時間差(時間戳)\nUTC 統一標準時間 GMT 格林威治標準時間 CST 中央標準時間 java.util.Date\njava.sql.Date // 1. toString()：顯示當前的年、月、日、時、分、秒 // 2. getTime()：取得當前Date物件對應的毫秒數(時間戳) // 3.當前時間Date物件 Date date = new Date(); System.out.println(date.toString()); // Sun Mar 26 21:13:32 GMT+08:00 2023 System.out.println(date.getTime()); // 1679836437117 // 4. 指定毫秒數Date物件 Date date2 = new Date(1679836437117L); // Sun Mar 26 21:13:57 GMT+08:00 2023 // 5. 如何將java.sql.Date, java.util.Date 互轉 // java.sql.Date 轉 java.util.Date(子轉父) Date date3 = new java.sql.Date(1679836437117L); System.out.println(date3.toString()); // 2023-03-26 // java.util.Date 轉 java.sql.Date(父轉子) java.sql.Date date4 = new java.sql.Date(date3.getTime()); System.out.println(date4.toString()); // 2023-03-26 java.text.SimpleDateFormat：對Date類的格式化和解析 SimpleDateFormat sdf = new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); // 格式化：日期 -\u0026gt; 字串 System.out.println(sdf.format(new Date())); // 2023-03-26 21:46:26 // 解析：字串 -\u0026gt; 日期 Date parse = null; try { parse = sdf.parse(\u0026#34;2023-03-26 21:46:26\u0026#34;); } catch (ParseException e) { e.printStackTrace(); } if (parse != null) { System.out.println(parse.toString()); // Sun Mar 26 21:46:26 GMT+08:00 2023 } java.util.Calendar(抽象類)\n常用方法：\nget() set() add() getTime() setTime() 注意：\n取得月份時，一月是0、二月是1，以此類推\u0026hellip;十二月是11 取得星期時，週日是1、週一是2，以此類推\u0026hellip;週六是7 // Date 偏移量 YEAR從1900開始、月從0開始 Date date = new Date(2023-1900, 3-1, 27); System.out.println(date); // 方式一、創建其子類(GregorianCalendar)的物件 // 方式二、調用其靜態方法 getInstance() Calendar calendar = Calendar.getInstance(); System.out.println(calendar.getClass()); // class java.util.GregorianCalendar // get() int days = calendar.get(Calendar.DAY_OF_MONTH); System.out.println(days); // 這個月的第幾天 System.out.println(calendar.get(Calendar.DAY_OF_YEAR)); // 這個年的第幾天 // add() calendar.add(Calendar.DAY_OF_YEAR, -3); days = calendar.get(Calendar.DAY_OF_YEAR); System.out.println(days); // 這個年的第幾天 // getTime() Date date = calendar.getTime(); System.out.println(date); // Mon Mar 27 09:42:12 GMT+08:00 2023 // setTime() Date date1 = new Date(); calendar.setTime(date1); System.out.println(calendar.get(Calendar.DAY_OF_YEAR)); // 這個年的第幾天 練習 // 字串\u0026#34;2020-09-08\u0026#34; 轉換為 java.sql.Date SimpleDateFormat sdf = new SimpleDateFormat(\u0026#34;yyyy-MM-dd\u0026#34;); Date date = sdf.parse(\u0026#34;2020-09-08\u0026#34;); java.sql.Date date1 = new java.sql.Date(date.getTime()); System.out.println(date1);// 2020-09-08 JDK 8 以後日期時間API LocalDate LocalTime LocalDateTime @Test public void LocalDateTest() { // now() 取得當前日期、時間、日期+時間 LocalDate localDate = LocalDate.now(); LocalTime localTime = LocalTime.now(); LocalDateTime localDateTime = LocalDateTime.now(); // of() 設置指定的年、月、時、分、秒。沒有偏移量 LocalDateTime localDateTime1 = localDateTime.of(2023, 3, 27, 10, 13, 0); System.out.println(localDateTime1);// 2023-03-27T10:13 // getXxx() 取得相關屬性 System.out.println(localDateTime1.getDayOfMonth()); System.out.println(localDateTime1.getDayOfWeek()); System.out.println(localDateTime1.getMonth()); System.out.println(localDateTime1.getMonthValue()); System.out.println(localDateTime1.getMinute()); // LocalDate 不可變性 // withXxx() 設置相關屬性 LocalDate localDate1 = localDate.withDayOfMonth(31); System.out.println(localDate); // 2023-03-27 System.out.println(localDate1); // 2023-03-31 // LocalDateTime 不可變性 LocalDateTime localDateTime2 = localDateTime.withHour(12); System.out.println(localDateTime); // 2023-03-27T10:22:58.529 System.out.println(localDateTime2); // 2023-03-27T12:22:58.529 // plusXxx() LocalDateTime localDateTime3 = localDateTime.plusMonths(3); System.out.println(localDateTime); // 2023-03-27T10:24:37.844 System.out.println(localDateTime3); // 2023-06-27T10:24:37.844 // minusXxx() LocalDateTime localDateTime4 = localDateTime.minusDays(6); System.out.println(localDateTime); // 2023-03-27T10:25:47.916 System.out.println(localDateTime4); // 2023-03-21T10:25:47.916 } java.time.Instant @Test public void instantTest() { // now() 取得本初子午線對應的標準時間 Instant now = Instant.now(); // 考慮時區問題 UTC+8 小時 OffsetDateTime offsetDateTime = now.atOffset(ZoneOffset.ofHours(8)); System.out.println(offsetDateTime); // 2023-03-27T10:38:16.822+08:00 // 直接指定台灣台北時區 ZonedDateTime zonedDateTime = now.atZone(ZoneId.of(\u0026#34;Asia/Taipei\u0026#34;)); System.out.println(zonedDateTime.toLocalDateTime()); // 2023-03-27T10:43:59.249 // toEpochMills()：取得自1970年1月1日0時0分0秒(UTC)開始的毫秒數 long milli = now.toEpochMilli(); System.out.println(milli); // 1679885289697 // ofEpochMilli()：通過指定的毫秒數，取得Instant實例 Instant instant = Instant.ofEpochMilli(1679885289697L); OffsetDateTime offsetDateTime1 = instant.atOffset(ZoneOffset.ofHours(8)); System.out.println(offsetDateTime1); // 2023-03-27T10:48:09.697+08:00 ZonedDateTime zonedDateTime1 = instant.atZone(ZoneId.of(\u0026#34;Asia/Taipei\u0026#34;)); System.out.println(zonedDateTime1.toLocalDateTime()); // 2023-03-27T10:48:09.697 } ","permalink":"https://sunwc2023.github.io/blog/datetime/datetime-api/","tags":["Java"],"title":"Java - 時間相關API"},{"categories":["Java"],"contents":"例子 /** * String 代表不可變的CharSequence，簡稱不可變性 * @author sunwc * @create 2023-03-25 下午 02:51 */ public class StringTest { private String str = new String(\u0026#34;good\u0026#34;); private char[] ch = {\u0026#39;t\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;s\u0026#39;,\u0026#39;t\u0026#39;}; private void change(String str, char[] ch) { str = \u0026#34;test ok\u0026#34;; ch[0] = \u0026#39;b\u0026#39;; } public static void main(String[] args) { StringTest stringTest = new StringTest(); stringTest.change(stringTest.str, stringTest.ch); System.out.println(stringTest.str); // good System.out.println(stringTest.ch); // best } } 以圖解釋main()執行時，記憶體分配資源的示意圖 幫助理解為什麼String 是不可變的 String 常見面試題 第一題 取得兩個字串中最大相同子串。例如str1 = \u0026quot;abcwerthelloyuiodef\u0026quot;, str2 = \u0026quot;cvhellobnm\u0026quot;;\r提示：將較短的字串在每一輪時總長度--，並在這個長度下得出不同組合，\r例如 str2 = \u0026quot;cvhellobnm\u0026quot; 第一輪會變成 =\u0026gt; cvhellobnm =\u0026gt; str1進行比較；\r第二輪會變成 cvhellobn 與 vhellobnm =\u0026gt; str1進行比較；\r第三輪會變成 cvhellob 與 vhellobn 與 hellobnm =\u0026gt; str1進行比較；...以此類推 /** * @author sunwc * @create 2023-03-26 下午 01:08 */ public class StringDemo { @Test public void getLongestSubString() { String str1 = \u0026#34;abcwerthelloyuiodef\u0026#34;, str2 = \u0026#34;cvhellobnm\u0026#34;; // 1.定義較長與較短字串 String maxString = str1.length() \u0026gt; str2.length() ? str1 : str2; String minString = str1.length() \u0026lt; str2.length() ? str1 : str2; // 2.定義較短字串長度 int minLength = minString.length(); /** * 先假設minString = abcdefg * 第一輪 i = 0, substring(0, minLength) =\u0026gt; abcdefg; * 第二輪 i = 1, substring(0, minLength - 1) =\u0026gt; abcdef, * substring(1, minLength) =\u0026gt; bcdefg; * 第三輪 i = 2, substring(0, minLength - 2) =\u0026gt; abcde, * substring(1, minLength -1) =\u0026gt; bcdef, * substring(2, minLength) =\u0026gt; cdefg * 以此類推...... */ back:{ for (int i = 0; i \u0026lt; minLength; i++) { for (int start = 0, end = minLength - i; end \u0026lt;= minLength; start++, end++) { // 3. 取得此輪固定長度下的不同組合subString String subString = minString.substring(start, end); // 4. 判斷較長字串是否包含minString的substring if (maxString.contains(subString)) { System.out.println(\u0026#34;找到longest substring為：\u0026#34; + subString); // 直接挑出外層迴圈 break back; } } } } } } 輸出結果：\n找到longest substring為：hello 參考來源\n第二題 取得一個字串在另一個字串中出現的次數，例如：取得\u0026quot;ab\u0026quot;在\u0026quot;abkkcadkabkebfkabkskab\u0026quot;中出現的次數\r@Test public void duplicateString() { String minString = \u0026#34;ab\u0026#34;; String maxString = \u0026#34;abkkcadkabkebfkabkskab\u0026#34;; int count = 0; for (int i = 0; i \u0026lt; maxString.length();) { // 不是-1代表有找到 if (maxString.indexOf(minString) != -1) { count++; // startIndex後移minString.length()位 maxString = maxString.substring(i += minString.length()); } else { // startIndex後移1位 maxString = maxString.substring(++i); } } System.out.println(\u0026#34;字串在另一個字串中出現的次數為：\u0026#34; + count); } 輸出結果：\n字串在另一個字串中出現的次數為：4 第三題 對字串String str1 = \u0026ldquo;abcwerthelloyuiodef\u0026quot;中的字符進行自然順序排序\n提示\n1.字串變成char array\n2.對陣列排序(選擇排序、氣泡排序、Arrays.sort())\n3.將排序後的陣列變成字串\n@Test public void orderStringAlphabetical() { String str1 = \u0026#34;abcwerthelloyuiodef\u0026#34;; char[] chars = str1.toCharArray(); for (int i = 0; i \u0026lt; chars.length; i++) { for (int j = i+1; j \u0026lt; chars.length; j++) { if (chars[i] \u0026gt; chars[j]) { // swap char temp = chars[i]; chars[i] = chars[j]; chars[j] = temp; } } } System.out.println(chars); } 輸出結果：\nabcdeeefhilloortuwy 參考來源 Sort String Characters In Alphabetical Order\n","permalink":"https://sunwc2023.github.io/blog/string/unchangeable-string/","tags":["Java"],"title":"Java - String 不可變的"},{"categories":["Java"],"contents":"Thread Pool 特性 背景：經常創建和銷毀、使用量特別大的資源，例如併發情況下的執行緒，對效能影響很大 思路：提前創建 Multi thread，放入 Thread Pool中，使用時直接取得，使用完後放回池中。可以避免頻繁創建與銷毀、實現重複利用。類似生活中大眾交通工具 好處： 提高響應速度(減少了創建新 Thread 的時間) 降低資源消耗(重複利用Thread Pool中的Thread，不需要每次都創建) 便於 Thread 管理 corePoolSize: 核心池的大小 maximumPoolSize: 最大 Thread 數 keepAliveTime: Thread 在沒有任務時最多保持多長時間後會終止 Thread Pool 相關 API JDK 5.0 起提供了 Thread Pool 相關 API: ExecutorService和 Executors interface ExecutorService：它的常見子類別 ThreadPoolExecutor void execute(Runnable command)：執行任務/ 命令，沒有回傳值，一般用來執行 Runnable Future submit(Callable task)：執行任務，有回傳值，一般用來執行 Callable void shutdown()：關閉 Thread Pool interface Executor：工具類、Thread Pool 的工廠類，用於創建並回傳不同類型的 Thread Pool Executors.newCachedThreadPool()：創建一個可根據需要創建新 Thread的 Thread Pool Executors.newFixedThreadPool(n)：創建一個可重用固定 Thread 數的 Thread Pool Executors.newSingleThreadPool()：創建一個只有一個 Thread 的 Thread Pool Executors.newScheduledThreadPool(n)：創建一個 Thread Pool，它可以安排在給定延遲後 執行命令 或者 定期地執行 使用 Thread Pool 實現 Multi-threading 步驟 1.提供指定 Thread 數的 Thread Pool\n2.執行指定的 Thread，需要提供Runnable 或 Callable 的實現類別物件\n3.關閉 Thread Pool\n例子 /** * @author sunwc * @create 2023-03-25 上午 10:22 */ public class ThreadPool { public static void main(String[] args) { ExecutorService executorService = Executors.newFixedThreadPool(10); // 設置Thread Pool 屬性 // 1. 透過 interface ExecutorService.getClass() 取得它的實現類別 System.out.println(executorService.getClass());// java.util.concurrent.ThreadPoolExecutor // 2. 取得實現類ThreadPoolExecutor後，就可以更改Thread Pool 屬性了 ThreadPoolExecutor threadPoolExecutor = (ThreadPoolExecutor) executorService; threadPoolExecutor.setCorePoolSize(15); // 適合使用於Runnable executorService.execute(new EvenNumThread()); // 適合使用於Callable executorService.submit(new OddNumThread()); // 關閉 Thread Pool executorService.shutdown(); } } /** * 輸出1-25間的偶數 */ class EvenNumThread implements Runnable { @Override public void run() { Thread.currentThread().setName(\u0026#34;偶數執行緒\u0026#34;); for (int i = 1; i \u0026lt;= 25; i++) { if (i % 2 == 0) { System.out.println(Thread.currentThread().getName() + \u0026#34;:\u0026#34; + i); } } } } /** * 輸出1-25間的奇數 */ class OddNumThread implements Callable { @Override public Object call() throws Exception { Thread.currentThread().setName(\u0026#34;奇數執行緒\u0026#34;); for (int i = 1; i \u0026lt;= 25; i++) { if (i % 2 != 0) { System.out.println(Thread.currentThread().getName() + \u0026#34;:\u0026#34; + i); } } return null; } } 輸出結果：\nclass java.util.concurrent.ThreadPoolExecutor 偶數執行緒:2 偶數執行緒:4 偶數執行緒:6 偶數執行緒:8 偶數執行緒:10 偶數執行緒:12 偶數執行緒:14 偶數執行緒:16 偶數執行緒:18 偶數執行緒:20 偶數執行緒:22 偶數執行緒:24 奇數執行緒:1 奇數執行緒:3 奇數執行緒:5 奇數執行緒:7 奇數執行緒:9 奇數執行緒:11 奇數執行緒:13 奇數執行緒:15 奇數執行緒:17 奇數執行緒:19 奇數執行緒:21 奇數執行緒:23 奇數執行緒:25 總結 如何創建 Thread 相關的概念，不知不覺寫了好幾篇文章，雖然實際開發中，通常不會自己建，只要使用框架幫我們寫好的就可以了；但是有了 Thread 底層的基礎觀念，使用起來也比較確定用法是正確的 :)\n在把這個系列的文章集合起來：\n有關創建多執行緒 (Multi-threading) 的方式 - 繼承 Thread 類，可以參考我的另一篇文章 Java - Thread 執行緒(一)\n有關創建多執行緒的方式 - 實現 interface Runnable，可以參考我的另一篇文章 Java - Thread 執行緒(二) - interface Runnable\n有關創建多執行緒的方式 - 實現 interface Runnable，可以參考我的另一篇文章 Java - Thread 執行緒(三) - interface Callable\n","permalink":"https://sunwc2023.github.io/blog/thread/thread-pool/","tags":["Java"],"title":"Java -  Thread 執行緒(四) Thread Pool"},{"categories":["Java"],"contents":"JDK 5.0 新增\n新執行緒的創建 (Multi-threading) - 實現 interface Callable 之步驟 1.創建一個實現了 interface Callable 的類別\n2.實現類去實現 Callable 的抽象方法： call()，將此執行緒需要執行的程式寫在這裡\n3.創建實現類的物件\n4.將此物件作為參數傳遞到 FutureTask\u0026lt;T\u0026gt; 類的建構子(constructor)中\n5.將FutureTask\u0026lt;T\u0026gt;物件作為參數傳遞到 Thread 類的建構子(constructor)中並調用 start()\n6.取得 Callable 中 call()的回傳值\ninterface Callable vs. interface Runnable 的好處 call() 有回傳值 call() 可以拋出例外，被外面的操作捕獲，取得例外的訊息 Callable 支持泛型 例子 /** * 1-100之間求偶數之和 * @author sunwc * @create 2023-03-24 下午 08:46 */ public class EvenAmount { public static void main(String[] args) { NumberThread numberThread = new NumberThread(); FutureTask futureTask = new FutureTask(numberThread); new Thread(futureTask).start(); try { // get() 即為調用call() 的回傳值 Object sum = futureTask.get(); System.out.println(\u0026#34;偶數之和：\u0026#34; + sum); } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } } } class NumberThread implements Callable { @Override public Object call() throws Exception { int sum = 0; for (int i = 1; i \u0026lt;= 100 ; i++) { if (i % 2 == 0) { sum += i; } } return sum; } } 輸出結果：\n偶數之和：2550 延伸學習：有關透過 Thread Pool 達成 Multi-threading，可以參考我的另一篇文章 Java - Thread 執行緒(四) Thread Pool\n","permalink":"https://sunwc2023.github.io/blog/thread/implements-callable/","tags":["Java"],"title":"Java - Thread 執行緒(三) - interface Callable"},{"categories":["Practice"],"contents":"題目 生產者(Producer)將產品將給店員(Clerk)，而消費者(Consumer)從店員出取走商品，店員一次只能持有固定數量的產品(例如:20)，如果生產者試圖生產更多的產品，店員會較生產者暫停一下，如果店中有空位可以放產品了在通知生產者繼續生產；如果店中沒有產品了，店員會告知消費者等一下，如果店中有產品了再通知消費者來取走產品\n/** * @author sunwc * @create 2023-03-24 下午 03:49 */ public class ConcurrentProduct { public static void main(String[] args) { // 共享資源 Clerk clerk = new Clerk(); // 第一個生產者 Producer producer1 = new Producer(clerk); // 第一個消費者 Consumer consumer1 = new Consumer(clerk); Consumer consumer2 = new Consumer(clerk); producer1.setName(\u0026#34;生產者1\u0026#34;); consumer1.setName(\u0026#34;消費者1\u0026#34;); consumer1.setPriority(Thread.MAX_PRIORITY); consumer2.setName(\u0026#34;消費者2\u0026#34;); producer1.start(); consumer1.start(); consumer2.start(); } } /** * 店員類 */ class Clerk { private int prodouctAmount = 0; /** * 店員幫忙生產 */ synchronized public void doProduction() { if (this.prodouctAmount \u0026lt; 20) { this.prodouctAmount++; System.out.println(Thread.currentThread().getName() +\u0026#34;: 生產第 \u0026#34;+ prodouctAmount + \u0026#34;個產品\u0026#34;); try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } // 生產者生產一個產品，就可以喚醒消費者去消費商品了 this.notify(); } else { try { // 產品量夠了，休息一下 this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } /** * 店員幫忙銷售 */ synchronized public void doVending() { if (this.prodouctAmount \u0026gt; 0) { System.out.println(Thread.currentThread().getName()+\u0026#34;: 銷售第 \u0026#34;+ prodouctAmount + \u0026#34;個商品\u0026#34;); this.prodouctAmount--; try { Thread.sleep(200); } catch (InterruptedException e) { e.printStackTrace(); } // 消費者買了一個商品後，就可以喚醒生產者去生產了 this.notify(); } else { try { // 商品沒了，等等再來買哦~ this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } } /** * 生產者類 */ class Producer extends Thread { // 共享資源 private Clerk clerk; public Producer(Clerk clerk) { this.clerk = clerk; } @Override public void run() { while (true) { clerk.doProduction(); } } } /** * 消費者類 */ class Consumer extends Thread { // 共享資源 private Clerk clerk; public Consumer (Clerk clerk) { this.clerk = clerk; } @Override public void run() { while (true) { clerk.doVending(); } } } 輸出結果：\n生產者1: 生產第 1個產品 生產者1: 生產第 2個產品 生產者1: 生產第 3個產品 生產者1: 生產第 4個產品 生產者1: 生產第 5個產品 生產者1: 生產第 6個產品 生產者1: 生產第 7個產品 生產者1: 生產第 8個產品 生產者1: 生產第 9個產品 生產者1: 生產第 10個產品 生產者1: 生產第 11個產品 生產者1: 生產第 12個產品 生產者1: 生產第 13個產品 生產者1: 生產第 14個產品 生產者1: 生產第 15個產品 生產者1: 生產第 16個產品 生產者1: 生產第 17個產品 生產者1: 生產第 18個產品 生產者1: 生產第 19個產品 生產者1: 生產第 20個產品 消費者2: 銷售第 20個商品 消費者2: 銷售第 19個商品 消費者2: 銷售第 18個商品 消費者2: 銷售第 17個商品 消費者2: 銷售第 16個商品 消費者2: 銷售第 15個商品 消費者2: 銷售第 14個商品 消費者1: 銷售第 13個商品 消費者1: 銷售第 12個商品 消費者1: 銷售第 11個商品 消費者1: 銷售第 10個商品 消費者1: 銷售第 9個商品 消費者1: 銷售第 8個商品 消費者1: 銷售第 7個商品 消費者1: 銷售第 6個商品 消費者1: 銷售第 5個商品 消費者1: 銷售第 4個商品 消費者1: 銷售第 3個商品 消費者1: 銷售第 2個商品 消費者1: 銷售第 1個商品 生產者1: 生產第 1個產品 消費者1: 銷售第 1個商品 生產者1: 生產第 1個產品 生產者1: 生產第 2個產品 生產者1: 生產第 3個產品 消費者1: 銷售第 3個商品 消費者1: 銷售第 2個商品 消費者1: 銷售第 1個商品 生產者1: 生產第 1個產品 生產者1: 生產第 2個產品 消費者1: 銷售第 2個商品 消費者1: 銷售第 1個商品 生產者1: 生產第 1個產品 生產者1: 生產第 2個產品 生產者1: 生產第 3個產品 消費者1: 銷售第 3個商品 消費者1: 銷售第 2個商品 消費者1: 銷售第 1個商品 生產者1: 生產第 1個產品 消費者1: 銷售第 1個商品 生產者1: 生產第 1個產品 生產者1: 生產第 2個產品 生產者1: 生產第 3個產品 生產者1: 生產第 4個產品 消費者1: 銷售第 4個商品 消費者1: 銷售第 3個商品 消費者1: 銷售第 2個商品 ....... ","permalink":"https://sunwc2023.github.io/blog/thread/concurrent-product/","tags":["Java"],"title":"Java - 多執行緒 通訊"},{"categories":["Java"],"contents":"執行緒通訊 Multi-threading 中 如何讓執行緒可以交互執行 會涉及到三個方法：\njava.lang.Object.wait()：一但執行此方法，當前執行緒就會進入阻塞狀態，並釋放同步鎖 java.lang.Object.notify()：一但執行此方法，就會喚醒正在wait()中的執行緒。如果有多個執行緒wait()中，就先喚醒優先級較高的 java.lang.Object.notifyAll()：一但執行此方法，就會喚醒所有wait()中的執行緒 wait(),notify(),notifyAll()使用前提 這三個方法只能使用在synchronized修飾的區塊 或 同步方法中 這三個方法的調用者必須是同步鎖this；若調用此三個方法的物件與同步鎖不一致，會出現IllegalMonitorStateException 例子 /** * @author sunwc * @create 2023-03-24 下午 03:02 */ public class PrintNumberInteraction { public static void main(String[] args) { Number number = new Number(); Thread t1 = new Thread(number); Thread t2 = new Thread(number); t1.setName(\u0026#34;thread 1\u0026#34;); t2.setName(\u0026#34;thread 2\u0026#34;); t1.start(); t2.start(); } } class Number implements Runnable { private int number = 1; @Override public void run() { while (number \u0026lt;= 50) { synchronized (this) { // 喚醒阻塞中的執行緒 this.notify(); if (number \u0026lt;= 50) { System.out.println(Thread.currentThread().getName() + \u0026#34;: number - \u0026#34; + number); number++; } try { // 當前執行緒阻塞並釋放同步鎖，讓其它執行緒進入 this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } } } 輸出結果：\nthread 2: number - 1 thread 1: number - 2 thread 2: number - 3 thread 1: number - 4 thread 2: number - 5 thread 1: number - 6 thread 2: number - 7 thread 1: number - 8 thread 2: number - 9 thread 1: number - 10 thread 2: number - 11 thread 1: number - 12 thread 2: number - 13 thread 1: number - 14 thread 2: number - 15 thread 1: number - 16 thread 2: number - 17 thread 1: number - 18 thread 2: number - 19 thread 1: number - 20 thread 2: number - 21 thread 1: number - 22 thread 2: number - 23 thread 1: number - 24 thread 2: number - 25 thread 1: number - 26 thread 2: number - 27 thread 1: number - 28 thread 2: number - 29 thread 1: number - 30 thread 2: number - 31 thread 1: number - 32 thread 2: number - 33 thread 1: number - 34 thread 2: number - 35 thread 1: number - 36 thread 2: number - 37 thread 1: number - 38 thread 2: number - 39 thread 1: number - 40 thread 2: number - 41 thread 1: number - 42 thread 2: number - 43 thread 1: number - 44 thread 2: number - 45 thread 1: number - 46 thread 2: number - 47 thread 1: number - 48 thread 2: number - 49 thread 1: number - 50 總結 java.lang.Thread.sleep() vs. java.lang.Object.wait() 相同點：一但執行方法，都可以使得當前執行緒進入阻塞狀態 不同點： 1.調用的要求不同：sleep()可以在任何需要的場景下使用；wait()必須使用在 synchronized修飾的區塊 或 同步方法中\n2.關於是否釋放同步鎖：若兩的方法都使用在 synchronized 結構中，sleep不會釋放鎖；而wait()會釋放鎖\n","permalink":"https://sunwc2023.github.io/blog/thread/wait-notify/","tags":["Java"],"title":"Java - 執行緒 交互輸出1-50的數字"},{"categories":["Practice"],"contents":"方式一、 使用鎖 import java.util.concurrent.locks.ReentrantLock; /** * 演示案例：銀行有一個帳戶 * 有兩個存戶分別向同一個帳戶存3000元，每次存1000，存3次。 * 每次存完輸出帳戶餘額 * @author sunwc * @create 2023-03-24 下午 12:23 */ public class ConcurrentAccount { public static void main(String[] args) { // 帳戶為共享資源，只new一次 Account account = new Account(); Depositor depositor = new Depositor(account); Thread t1 = new Thread(depositor); Thread t2 = new Thread(depositor); t1.setName(\u0026#34;存戶1\u0026#34;); t2.setName(\u0026#34;存戶2\u0026#34;); t1.start(); t2.start(); } } /** * 帳戶類 */ class Account { /** * 存款餘額 */ private double balance; /** * 存入金額並輸出帳戶餘額 * @param amount */ synchronized void deposit(int amount) {// 同步鎖默認為this if (amount \u0026gt; 0) { this.balance += amount; // 看會不會增加執行緒不安全問題 try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \u0026#34; 帳戶餘額：\u0026#34; + this.balance); } } } /** * 存戶類 */ class Depositor implements Runnable { private Account account; public Depositor(Account account) { this.account = account; } /** * 鎖，設置執行緒先進先出 */ private ReentrantLock reentrantLock = new ReentrantLock(true); @Override public void run() { // 每個存戶 每次存1000、存3次 for (int i = 0; i \u0026lt; 3; i++) { try { reentrantLock.lock(); // 存1000 account.deposit(1000); } finally { reentrantLock.unlock(); } } } } 輸出結果：\n存戶1 帳戶餘額：1000.0 存戶2 帳戶餘額：2000.0 存戶1 帳戶餘額：3000.0 存戶2 帳戶餘額：4000.0 存戶1 帳戶餘額：5000.0 存戶2 帳戶餘額：6000.0 方式二、使用 synchronized 機制 /** * @author sunwc * @create 2023-03-24 下午 12:52 */ public class ConcurrentAccount2 { public static void main(String[] args) { Depositor2 depositor1 = new Depositor2(); Depositor2 depositor2 = new Depositor2(); depositor1.setName(\u0026#34;存戶1\u0026#34;); depositor2.setName(\u0026#34;存戶2\u0026#34;); depositor1.start(); depositor2.start(); } } /** * 帳戶類 */ class Account2 { /** * 存款餘額 */ private double balance; public double getBalance() { return balance; } public void setBalance(double balance) { this.balance = balance; } } /** * 存戶類 */ class Depositor2 extends Thread { /** * 帳戶(共享資源) */ private static Account2 account; /** * constrctor在創建存戶時一併創建帳戶 */ public Depositor2() { synchronized (Depositor.class) { if (account == null) { account = new Account2(); } } } @Override public void run() { for (int i = 0; i \u0026lt; 3; i++) { // 存1000 synchronized (Depositor2.class) { deposit(1000); } } } /** * 存錢操作 * @param amount */ private void deposit(int amount) { if (amount \u0026gt; 0) { // 先取得餘額 double currnetBalance = account.getBalance(); // 增加存款金額 currnetBalance += amount; account.setBalance(currnetBalance); try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \u0026#34; 存錢成功，帳戶餘額：\u0026#34; + account.getBalance()); } } } 輸出結果：\n存戶1 存錢成功，帳戶餘額：1000.0 存戶2 存錢成功，帳戶餘額：2000.0 存戶2 存錢成功，帳戶餘額：3000.0 存戶1 存錢成功，帳戶餘額：4000.0 存戶1 存錢成功，帳戶餘額：5000.0 存戶2 存錢成功，帳戶餘額：6000.0 總結 我們在下面兩篇文章已經了解到解決執行緒不安全的兩種方式\n有關透過鎖 Lock 解決執行緒不安全問題，可以參考我的另一篇文章 Java - Lock - 解決執行緒不安全\n有關透過實現類 implements interface Runnable 達成 Multi-threading，可以參考我的另一篇文章 Java - Thread 執行緒(二) - interface Runnable\n本篇文章是舉例另一個可能會造成執行緒不安全的現實例子，能夠對於同步的機制更加印象深刻\n","permalink":"https://sunwc2023.github.io/blog/thread/deposit-concurrent-example/","tags":["Java"],"title":"Java - Lock \u0026 synchronized 使用"},{"categories":["Java"],"contents":"為什麼要用鎖(Lock)？ 鎖 相對於 synchronized 機制，是更加靈活的，它一樣能夠解決執行緒不安全的問題；\n不同點在於：synchronized機制在執行完相應的區塊後，會自動釋放同步鎖；而Lock就需要手動啟動同步 以及 手動結束同步 java.util.concurrent.locks.ReentrantLock; 是JDK 5.0新增的特性，新特性可以考慮優先使用 例子 /** * 演示使用Lock解決執行緒不安全問題 * @author sunwc * @create 2023-03-24 上午 11:18 */ public class LockTest { public static void main(String[] args) { Window window = new Window(); Thread t1 = new Thread(window); t1.setName(\u0026#34;窗口1\u0026#34;); Thread t2 = new Thread(window); t2.setName(\u0026#34;窗口2\u0026#34;); Thread t3 = new Thread(window); t3.setName(\u0026#34;窗口3\u0026#34;); t1.start(); t2.start(); t3.start(); } } /** * 窗口類 */ class Window implements Runnable { private int ticketAmount = 20; @Override public void run() { while (ticketAmount \u0026gt; 0) { if (ticketAmount \u0026gt; 0) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() +\u0026#34; : 售出的票號 - \u0026#34;+ ticketAmount); ticketAmount--; } } } } 演示執行緒不安全輸出結果：\n窗口3 : 售出的票號 - 20 窗口1 : 售出的票號 - 20 窗口2 : 售出的票號 - 20 窗口1 : 售出的票號 - 17 窗口3 : 售出的票號 - 17 窗口2 : 售出的票號 - 17 窗口3 : 售出的票號 - 14 窗口2 : 售出的票號 - 14 窗口1 : 售出的票號 - 14 窗口2 : 售出的票號 - 11 窗口1 : 售出的票號 - 11 窗口3 : 售出的票號 - 11 窗口2 : 售出的票號 - 8 窗口1 : 售出的票號 - 8 窗口3 : 售出的票號 - 8 窗口3 : 售出的票號 - 5 窗口1 : 售出的票號 - 5 窗口2 : 售出的票號 - 5 窗口1 : 售出的票號 - 2 窗口3 : 售出的票號 - 2 窗口2 : 售出的票號 - 2 窗口1 : 售出的票號 - -1 使用 ReentrantLock 使得 Thread-safety 修改窗口類\nclass Window implements Runnable { private int ticketAmount = 20; // 1.創建Lock物件 // new ReentrantLock(boolean fair) fair默認false；若設置true，執行緒先進來先執行(先進先出) ReentrantLock reentrantLock = new ReentrantLock(true); @Override public void run() { while (ticketAmount \u0026gt; 0) { try { // 2. 手動取得同步鎖 reentrantLock.lock(); if (ticketAmount \u0026gt; 0) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() +\u0026#34; : 售出的票號 - \u0026#34;+ ticketAmount); ticketAmount--; } } finally { // 3.手動釋放同步鎖 reentrantLock.unlock(); } } } } 解決執行緒不安全輸出結果：\n窗口1 : 售出的票號 - 20 窗口2 : 售出的票號 - 19 窗口3 : 售出的票號 - 18 窗口1 : 售出的票號 - 17 窗口2 : 售出的票號 - 16 窗口3 : 售出的票號 - 15 窗口1 : 售出的票號 - 14 窗口2 : 售出的票號 - 13 窗口3 : 售出的票號 - 12 窗口1 : 售出的票號 - 11 窗口2 : 售出的票號 - 10 窗口3 : 售出的票號 - 9 窗口1 : 售出的票號 - 8 窗口2 : 售出的票號 - 7 窗口3 : 售出的票號 - 6 窗口1 : 售出的票號 - 5 窗口2 : 售出的票號 - 4 窗口3 : 售出的票號 - 3 窗口1 : 售出的票號 - 2 窗口2 : 售出的票號 - 1 總結 本文介紹了如何使用鎖 將部分程式邏輯達到同步的效果，Lock的使用實際上會更靈活，因為它比較偏向人為去控制，哪時候開執行同步、哪時候結束同步，達到立竿見影的效果\n基礎鞏固：有關透過實現類 implements interface Runnable 達成 Multi-threading，可以參考我的另一篇文章 Java - Thread 執行緒(二) - interface Runnable\n","permalink":"https://sunwc2023.github.io/blog/thread/lock-reentrantlock/","tags":["Java"],"title":"Java - Lock - 解決執行緒不安全"},{"categories":["Java"],"contents":"什麼是死鎖？ 當不同執行緒分別占用對方需要的同步資源不放棄，都在等待對方放棄自己需要的同步資源，就形成了執行緒的死鎖\n死鎖出現後的現象？ 出現死鎖後，不會出現例外，也不會有提示，只是所有執行緒都處於阻塞的狀態；因此我們在使用 synchronized 的時候，要避免死鎖的情況發生\n如何避免死鎖？ 盡量減少同步資源的宣告，例如 有 static 關鍵字 避免嵌套synchronized(同步鎖){} 例子 /** * 演示執行緒死鎖問題 * @author sunwc * @create 2023-03-24 上午 10:49 */ public class DeadlockTest { public static void main(String[] args) { // 1. 第一個同步鎖 StringBuffer s1 = new StringBuffer(); // 2. 第二個同步鎖 StringBuffer s2 = new StringBuffer(); // 3.匿名子類創建執行緒(子Thread1) new Thread() { @Override public void run() { synchronized (s1) { s1.append(\u0026#34;1\u0026#34;); s2.append(\u0026#34;a\u0026#34;); // 5. 阻塞0.1秒，增加死鎖概率 try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (s2) { s1.append(\u0026#34;2\u0026#34;); s2.append(\u0026#34;b\u0026#34;); Thread.currentThread().setName(\u0026#34;子Thread1\u0026#34;); System.out.println(Thread.currentThread().getName() + \u0026#34; : \u0026#34; + s1); System.out.println(Thread.currentThread().getName() + \u0026#34; : \u0026#34; + s2); } } } }.start(); // 4. 匿名實現類創建執行緒 new Thread(new Runnable() { @Override public void run() { synchronized (s2) { s1.append(\u0026#34;3\u0026#34;); s2.append(\u0026#34;c\u0026#34;); // 6. 阻塞0.1秒，增加死鎖概率 try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (s1) { s1.append(\u0026#34;4\u0026#34;); s2.append(\u0026#34;d\u0026#34;); Thread.currentThread().setName(\u0026#34;子Thread2\u0026#34;); System.out.println(Thread.currentThread().getName() + \u0026#34; : \u0026#34; + s1); System.out.println(Thread.currentThread().getName() + \u0026#34; : \u0026#34; + s2); } } } }).start(); } } 總結 本文使用一個例子演示了兩個執行緒如何剛好都在等對方持有的那把鎖，而導致程式整個卡住了，因此使用 synchronized 機制時，還是要思考一下如何避免死鎖的情況產生，就像我們使用迴圈也會避免出現死循環一樣\n","permalink":"https://sunwc2023.github.io/blog/thread/thread-deadlock/","tags":["Java"],"title":"Java - Thread 的 Deadlock"},{"categories":["Java"],"contents":"JDK中用Thread.State類定義了執行緒的幾種狀態如下：\npublic enum State { NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED } Java語言使用 Thread 類及其子類別的物件來表示執行緒，在它一個完整的生命週期中通常要經歷如下五個狀態：\n1. 新建：當一個 Thread 類或其子類別的物件被宣告並創建時，新的執行緒物件處於新建狀態\r2. 就緒：處於新建狀態的執行緒被start()後，將進入執行緒隊列等待、以取得一段能夠搶占CPU的使用時長，此時它已具備了執行的條件，只是還沒分配到CPU資源\r3. 執行：當就緒的執行緒被調度並取得CPU資源時，便進入執行狀態，run()中定義了執行緒的操作和功能\r4. 阻塞：在某種特殊的情況下，被人為掛起或執行輸入輸出操作時，讓出CPU並臨時中止自己的執行，進入阻塞狀態\r5. 死亡：當執行緒完成了它的全部工作或執行緒被提前強制性地終止或出現例外導致結束\r總結 本文概略的介紹了執行緒的生命週期，了解到從 就緒 到 執行 狀態是雙向的關係，以及在生命週期關係圖中，提及一些 java.lang.Object的方法，例如wait(), notify(), notifyAll()等，因此關於方法的介紹請看\n我的另一篇文章 Java - 執行緒 交互輸出1-50的數字\n","permalink":"https://sunwc2023.github.io/blog/thread/thread-lifecycle/","tags":["Java"],"title":"Java - Thread 的 生命週期"},{"categories":["Java"],"contents":" 有關創建多執行緒 (Multi-threading) 的方式 - 繼承 Thread 類，可以參考我的另一篇文章 Java - Thread 執行緒(一)\n除了上述說的方式創建新的執行緒；\n在實際應用面，以透過實現 interface Runnable 來做是更好的方式，詳細的說明如下：\n新執行緒的創建 (Multi-threading) - 實現 interface Runnable 之步驟 1.創建一個實現了 interface Runnable 的類別\n2.實現類去實現 Runnable 的抽象方法： run()\n3.創建實現類的物件\n4.將此物件作為參數傳遞到 Thread 類的建構子(constructor)中\n5.通過 Thread 類的物件調用 start()\n[ 註 ] 以下的例子為非thread-safety，還必須優化；本文最後會介紹兩種優化方法\n例子 /** * 售票窗口類 */ class Window implements Runnable { private int ticketAmount = 20; @Override public void run() { while (true) { if (ticketAmount \u0026gt; 0) { // 進行賣票操作 System.out.println(Thread.currentThread().getName() + \u0026#34; : 售出票號 - \u0026#34; + ticketAmount); ticketAmount--; } else { break; } } } } /** * 測試類 * @author sunwc * @create 2023-03-23 下午 03:01 */ public class ImplementsRunnableTest { public static void main(String[] args) { Window window = new Window(); Thread t1 = new Thread(window); t1.setName(\u0026#34;Window 1\u0026#34;); Thread t2 = new Thread(window); t2.setName(\u0026#34;Window 2\u0026#34;); Thread t3 = new Thread(window); t3.setName(\u0026#34;Window 3\u0026#34;); t1.start(); t2.start(); t3.start(); } } 演示執行緒不安全輸出結果：\nWindow 1 : 售出票號 - 20 Window 2 : 售出票號 - 20 Window 3 : 售出票號 - 20 Window 2 : 售出票號 - 18 Window 2 : 售出票號 - 16 Window 1 : 售出票號 - 19 Window 2 : 售出票號 - 15 Window 3 : 售出票號 - 17 Window 2 : 售出票號 - 13 Window 2 : 售出票號 - 11 Window 2 : 售出票號 - 10 Window 2 : 售出票號 - 9 Window 2 : 售出票號 - 8 Window 2 : 售出票號 - 7 Window 2 : 售出票號 - 6 Window 2 : 售出票號 - 5 Window 2 : 售出票號 - 4 Window 2 : 售出票號 - 3 Window 2 : 售出票號 - 2 Window 2 : 售出票號 - 1 Window 1 : 售出票號 - 14 Window 3 : 售出票號 - 12 創建新執行緒：繼承 Thread 類 vs. 實現 interface Runnable 開發中會優先選擇 實現 interface Runnable 方式\n原因：\n實現的方式沒有 類別單一繼承 的侷限性 實現的方式更適合來處理 Multi-threading 有共享資料的情況 其實原生的 Thread 類別 也是 interface Runnable 的實現類， 所以不管是子類繼承 Thread 類 或 實現類實現 interface Runnable ，相同點是： 需要 Override run()，將執行緒要執行的邏輯寫在 run() 中\n上面的售票的執行緒安全問題，問題點解釋： 售票過程中，出現了重複售出同一個票號的票、超賣的情況 原因：當某個執行緒操作車票的過程中，尚未操作完成時，其它的執行緒就參與進來 如何解決執行緒安全問題： 當一個執行緒A在操作ticket的時候，其它執行緒不能參與進來。直到執行緒A操作完ticket時，其它執行緒才可以開始操作ticket。這種情況即使執行A被阻塞了，其它執行緒也一定要等待\n現實例子：\n當某A在使用唯一一間廁所時，某B即使肚子痛要使用，也要等某A使用完才可以進入。因為某A鎖門了，某B只好等了\n在Java中，我們通過同步機制，來解決執行緒安全的問題 優化方式一、同步程式區塊 synchronized(同步鎖) { // 需要被同步的程式 } 說明：\n將共享資料的程式用synchronized(同步鎖){}包起來，當一個thread先進入這層，其它thread要先在這層外面等\n共享資料：指的是Multi-threading中共同操作的一個變數，以例子來說 ticketAmount 就是共享的資料\n什麼是同步鎖？\n任何一個類別的物件都可以充當鎖，但是Multi-threading 中的每個 thread 進入這層時都必須使用同一把鎖\n侷限性：在同步程式區塊內，只能有一個執行緒參與，其它執行緒等待。區塊內相當於是一個單執行緒的過程，效率會比較低\n例子 優化後(一)的售票窗口類： /** * 售票窗口類 */ class Window implements Runnable { private int ticketAmount = 20; @Override public void run() { while(true) { // 同步程式區塊 - Window.class(當前類別)充當唯一一把鎖 // 因為類別只會加載一次，當作唯一鎖相對安全 // 用this的話要看這個類別在主執行緒(main方法)中new了幾個物件 // 若只有一個就可以用this當唯一鎖 synchronized (Window.class) { // 或 synchronized (this) if (ticketAmount \u0026gt; 0) { // 執行緒阻塞，提高執行緒不安全機率 try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } // 進行賣票操作 System.out.println(Thread.currentThread().getName() + \u0026#34; : 售出票號 - \u0026#34; + ticketAmount); ticketAmount--; } else { break; } } } } } 解決執行緒不安全輸出結果：\nWindow 1 : 售出票號 - 20 Window 1 : 售出票號 - 19 Window 1 : 售出票號 - 18 Window 1 : 售出票號 - 17 Window 1 : 售出票號 - 16 Window 1 : 售出票號 - 15 Window 1 : 售出票號 - 14 Window 3 : 售出票號 - 13 Window 2 : 售出票號 - 12 Window 2 : 售出票號 - 11 Window 2 : 售出票號 - 10 Window 2 : 售出票號 - 9 Window 2 : 售出票號 - 8 Window 2 : 售出票號 - 7 Window 2 : 售出票號 - 6 Window 3 : 售出票號 - 5 Window 3 : 售出票號 - 4 Window 1 : 售出票號 - 3 Window 1 : 售出票號 - 2 Window 1 : 售出票號 - 1 優化方式二、同步方法 若使用到共享資料的程式完整的寫在一個方法中，我們不妨將此方法宣告成同步的\n同步方法仍然涉及到同步鎖，只是不需要我們顯示的宣告\n同步鎖 ：\n非靜態的同步方法：this (當前物件本身)\n靜態的同步方法：當前類別本身\n例子 優化後(二)的售票窗口類： /** * 售票窗口類 */ class Window implements Runnable { private static int ticketAmount = 20; @Override public void run() { while (ticketAmount \u0026gt; 0) { // 售票 sellTicket(); } } // private synchronized void sellTicket() {// 默認使用this當作鎖 private static synchronized void sellTicket() { // 默認使用Window.class當鎖 if (ticketAmount \u0026gt; 0) { // 執行緒阻塞，提高執行緒不安全機率 try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } // 進行賣票操作 System.out.println(Thread.currentThread().getName() + \u0026#34; : 售出票號 - \u0026#34; + ticketAmount); ticketAmount--; } } } 解決執行緒不安全輸出結果：\nWindow 1 : 售出票號 - 20 Window 1 : 售出票號 - 19 Window 1 : 售出票號 - 18 Window 3 : 售出票號 - 17 Window 3 : 售出票號 - 16 Window 3 : 售出票號 - 15 Window 3 : 售出票號 - 14 Window 3 : 售出票號 - 13 Window 3 : 售出票號 - 12 Window 3 : 售出票號 - 11 Window 3 : 售出票號 - 10 Window 3 : 售出票號 - 9 Window 3 : 售出票號 - 8 Window 3 : 售出票號 - 7 Window 2 : 售出票號 - 6 Window 2 : 售出票號 - 5 Window 2 : 售出票號 - 4 Window 2 : 售出票號 - 3 Window 2 : 售出票號 - 2 Window 2 : 售出票號 - 1 總結 本文幫助了解如何\n1.透過實現類 implements interface Runnable 達成 Multi-threading\n2.透過將共享資源宣告成「同步的」以解決執行緒不安全問題\n延伸學習：有關透過鎖 Lock 解決執行緒不安全問題，可以參考我的另一篇文章 Java - Lock - 解決執行緒不安全\n","permalink":"https://sunwc2023.github.io/blog/thread/implements-runnable/","tags":["Java"],"title":"Java - Thread 執行緒(二) - interface Runnable"},{"categories":["Java"],"contents":"\n什麼是Process？ 通常一個應用程序執行起來，就會在記憶體加載一個 Process ，對應到工作管理員(上圖)來看，一個 Process 就會對應到一個 PID (Process Identification)； 而一個 Process 會有 Multi-threading (Thread)，代表這個應用程序支持我們能夠使用它 同時在裡面做很多事情\n例如 執行一個 Java 應用程序java.exe，其實至少有三個執行緒被執行：main() 主執行緒、gc() 資源回收執行緒、例外處理執行緒。當然若有例外發生，就可能會影響主執行緒\n什麼是併行 與 併發？ 併行：多個CPU同時執行多個任務。例如 多個人同時做不同的事情\n併發：一個CPU快速切換不同執行緒以執行任務。例如 搶演唱會門票、多個人做同一件事情\nJVM 的記憶體結構 每個 Thread 都有獨立的一套 VM Stack 與 Program Counter Register\r每個 Process 有獨立的一套 Method Area 與 Heap，即 Multi-threading 一起共用這些資源\r有關創建多執行緒的方式 - 實現 interface Runnable，可以參考我的另一篇文章 Java - Thread 執行緒(二) - interface Runnable\n新執行緒的創建 (Multi-threading) - 繼承 Thread 類 之步驟 1.創建一個繼承於 Thread 類的子類別\n2.覆寫 Thread 類的run()\n3.創建 Thread 類的子類別物件\n4.通過此物件調用start()\n例子 class MyThread extends Thread { /** * 子執行緒輸出偶數 */ @Override public void run() { // 在這裡寫在 子執行緒 要做的事情 for (int i = 1; i \u0026lt;= 10; i++) { if (i % 2 == 0) { System.out.println(Thread.currentThread().getName() + \u0026#34; : \u0026#34; + i); } } } } /** * 多執行緒的創建 * 遍歷10以內的所有偶數 * @author sunwc * @create 2023-03-23 上午 10:23 */ public class ThreadTest { public static void main(String[] args) { // 主執行緒創建一個新執行緒 MyThread t1 = new MyThread(); // 主執行緒啟動子執行緒(會去執行run()) t1.start(); // 測試一、不能通過調用run()的方式啟動執行緒 // t1.run(); // 測試二、子執行緒已經t1.start()啟動，不能再用一樣的語句再啟動一次，會拋出java.lang.IllegalThreadStateException // 若 threadStatus != 0 會拋此例外 // t1.start(); // 再創建第二個子執行緒 MyThread t2 = new MyThread(); t2.start(); // 主執行緒輸出奇數 for (int i = 1; i \u0026lt;= 10; i++) { if (i % 2 != 0) { System.out.println(Thread.currentThread().getName() + \u0026#34; : \u0026#34; + i); } } } } 輸出結果\nThread-0 : 2 Thread-1 : 2 main : 1 Thread-1 : 4 Thread-0 : 4 Thread-0 : 6 Thread-0 : 8 Thread-0 : 10 Thread-1 : 6 main : 3 main : 5 main : 7 main : 9 Thread-1 : 8 Thread-1 : 10 使用匿名子類創建子執行緒 /** * 使用匿名子類創建兩個子執行緒 * 一個執行緒 印奇數 * 一個執行緒 印偶數 * @author sunwc * @create 2023-03-23 上午 11:05 */ public class NonTitleThreadTest { public static void main(String[] args) { new Thread() { @Override public void run() { for (int i = 1; i \u0026lt;= 10; i++) { if (i % 2 != 0) { Thread.currentThread().setName(\u0026#34;thread 1\u0026#34;); System.out.println(Thread.currentThread().getName() + \u0026#34; : \u0026#34; + i); } } } }.start(); new Thread() { @Override public void run() { for (int i = 1; i \u0026lt;= 10; i++) { if (i % 2 == 0) { Thread.currentThread().setName(\u0026#34;thread 2\u0026#34;); System.out.println(Thread.currentThread().getName() + \u0026#34; : \u0026#34; + i); } } } }.start(); } } 輸出結果\nthread 1 : 1 thread 1 : 3 thread 1 : 5 thread 1 : 7 thread 1 : 9 thread 2 : 2 thread 2 : 4 thread 2 : 6 thread 2 : 8 thread 2 : 10 Thread 類常見的方法 1. start()：啟動當前執行緒；調用當前執行緒的run()\r2. run()：通常需要覆寫Thread類中的此方法，將創建的執行緒要執行的操作寫在此方法中\r3. currentThread()：靜態方法，回傳當前程式的執行緒\r4. getName()：取得當前執行緒的名稱\r5. setName()：設置當前執行緒的名稱\r6. yield()：釋放當前CPU的執行權\r7. join()：在 執行緒A 中調用 執行緒B的join()，此時執行緒A就進入阻塞狀態，直到執行緒B全部執行完後，執行緒A才結束阻塞狀態\r8. stop：已過時不使用。當執行此方法時，強制結束當前執行緒\r9. sleep(long millitime)：讓當前執行緒“睡眠”指定的毫秒數，在指定的millitime時間內，當前的執行緒是阻塞狀態\r10. isAlive()：判斷當前執行緒是否還存活\rThread 類的優先級 1. MAX_PRIORITY: 10\rMIN_PRIORITY: 1\rNORM_PRIORITY: 5\r2. 如何取得和設置當前執行緒的優先級\rgetPriority()：取得執行緒的優先級\rsetPriority(int priority)：設置執行緒的優先級\r總結 本文介紹的內容比較多，包含：\n1.在作業系統中的 Process 以及它與 Thread 之間的關係\n2.如何透過繼承 Thread 類的方式創建新的執行緒來達成 Multi-threading\n3.用比較懶的方式(使用匿名子類)、在不用創建子類別繼承 Thread 類的方式創建新的執行緒來達成 Multi-threading\n4.Thread 類的常見方法、執行的優先級等\n","permalink":"https://sunwc2023.github.io/blog/thread/thread/","tags":["Java"],"title":"Java - Thread 執行緒(一)"},{"categories":["Java"],"contents":" Error：此錯誤是 Java虛擬機 (JVM) 無法解決的嚴重問題。例如 JVM系統內部錯誤、資源耗盡等嚴重情況 java.lang.StackOverflowError堆疊溢出 =\u0026gt; 例如 recursion終止條件沒寫好 java.lang.OutOfMemoryError 堆積溢出 =\u0026gt; 例如 Integer[] arr = new Integer[1024*1024*1024]; Exception：由於程式編輯錯誤或偶然的外在因素的一般性問題，可以使用針對性的程式進行處理 請看以下error/ exception 架構圖進行了解：\n例外體系結構： java.lang.Throwable java.lang.Error： 一般不編寫針對性的程式進行處理 java.lang.Exception： 可以進行例外的處理 compile 時異常(checked) IOExpetion FileNotFoundException ClassNotFoundException run 時異常(unchecked, RuntimeException) NullPointerException ArrayIndexOutBoundsException StringIndexOutBoundsException ClassCastException NumberFormatException InputMismatchException ArithmeticException 例外處理的方式： 方式一、try-catch-finally\n狼來了，自己把狼驅走，保護好羊群\n能夠處理 compile 時期的例外，run 時期仍可能出現例外，相當於延遲例外情況到執行的時候才可能會出現；通常我們在開發時一定是先處理編譯時例外，執行時例外視情況處理\n方式二、throws + 例外類型\n狼來了，自己趕快大喊，捕狼人來幫幫忙哦～ (自己沒辦法保護好羊群)\n拋給方法的調用者去處理\n手動拋出一個例外物件，視業務邏輯必要時使用： 使用 throw 關鍵字\nclass Student { private int id; public void register(int id) throws Exception { if (id \u0026gt; 0) { this.id = id; } else { // 手動拋出例外物件 throw new RuntimeException(\u0026#34;您輸入的學號是不合規範的\u0026#34;); } } } 總結 本文介紹\n1.Error/Exception 架構 父子層 關係\n因此我們在需要捕獲多個例外時，若例外類別之間彼此有父子類關係，就先寫子類、再寫父類\r2.例外處理的兩種方式\n3.視業務邏輯使用 throw 關鍵字拋出例外物件並輸出自定義訊息\n","permalink":"https://sunwc2023.github.io/blog/exception/exception-example/","tags":["Java"],"title":"Java - 例外處理 (Exception)"},{"categories":["Java"],"contents":"interface 特性 interface 可以定義全局常量、抽象方法、靜態方法與默認方法\ninterface 沒有 constructor，因此也不可以實例化\nJava類可以 implements 多個 interface ，彌補了 Java 單繼承的侷限性 (先寫繼承後寫實現)\npublic final class String extends Object implements java.io.Serializable, Comparable\u0026lt;String\u0026gt;, CharSequence { } interface 之間可以多重繼承 interface 體現多型的特性 可以把 interface 看作是一種規範 (contract) 現實例子： USB adaptor、JDBC interface 資料庫連線的規範(MySQL Driver, MSSQL Driver, Oracle Driver,\u0026hellip;.)\n例子 /** * interface USB * @Description * @author sunwc * @Date 2023年3月22日下午12:31:17 * */ interface USB { // 全局常量：定義了長、寬、高、最小傳輸速度等 public static final int WIDTH = 3; // 開始驅動 public abstract void start(); // public abstract可省略 // 移除驅動 void stop(); // 靜態方法(有方法體) public static void staticMethod() { System.out.println(\u0026#34;interface USB靜態方法\u0026#34;); } // 默認方法(有方法體) public default void defaultMethod1() { System.out.println(\u0026#34;interface USB默認方法1\u0026#34;); } public default void defaultMethod2() { System.out.println(\u0026#34;interface USB默認方法2\u0026#34;); } } /** * 創見USB 實現 interface USB * @Description * @author sunwc * @Date 2023年3月22日下午12:33:16 * */ class Transcend implements USB { @Override public void start() { System.out.println(\u0026#34;Transcend USB開啟工作\u0026#34;); } @Override public void stop() { System.out.println(\u0026#34;Transcend USB結束工作\u0026#34;); } @Override public void defaultMethod1() { System.out.println(\u0026#34;Transcend覆寫defaultMethod1\u0026#34;); } public void myMethod() { // 調用自己定義的覆寫方法 defaultMethod1(); // 調用interface中的默認方法 USB.super.defaultMethod1(); } } /** * 電腦類 * @Description * @author sunwc * @Date 2023年3月22日下午12:33:01 * */ class Computer { /** * 傳輸資料 * @Description * @author sunwc * @Date 2023年3月22日下午2:58:08 * @param usb */ public void transferData(USB usb) { usb.start(); System.out.println(\u0026#34;具體傳輸資料細節\u0026#34;); usb.stop(); } } /** * 測試類 * @Description * @author sunwc * @Date 2023年3月22日下午12:33:27 * */ public class USBTest { public static void main(String[] args) { Computer computer = new Computer(); Transcend transcend = new Transcend();// Usb usb = new Transcend(); computer.transferData(transcend); System.out.println(\u0026#34;=============================\u0026#34;); // interface的靜態方法只能透過interface進行調用 USB.staticMethod(); // 實現類可以覆寫interface的default方法 transcend.defaultMethod1(); // 若實現類沒有覆寫interface的default方法，則執行原本default方法的內容 transcend.defaultMethod2(); System.out.println(\u0026#34;==============================\u0026#34;); transcend.myMethod(); } } 輸出結果：\nTranscend USB開啟工作 具體傳輸資料細節 Transcend USB結束工作 ============================= interface USB靜態方法 Transcend覆寫defaultMethod1 interface USB默認方法2 ============================== Transcend覆寫defaultMethod1 interface USB默認方法1 結論：\ninterface 與 抽象類別 都不能被實例化，因此均體現 多型 的特性，需要子類別來繼承 或 實現類來實現\r以上面的例子來說，電腦傳輸資料時，均接受符合USB規範的各種物件，這就是多型的體現方式，因為電腦不用管USB adaptor、硬碟 (hard disk) 是哪種牌子，只要是符合interface USB規範都可以，也就能夠透過USB usb變數接受的不同 實現類別 而執行不同的 開始驅動 與 移除驅動 的方法了，藉以展現不同的行為模式\n","permalink":"https://sunwc2023.github.io/blog/abstract/interface/","tags":["Java"],"title":"Java - interface"},{"categories":["Java"],"contents":" 有關的例子，可以參考我的另一篇文章 Java - 多型 繼承\nabstract的特性 abstract 關鍵字只可以修飾 非final 的類別、 非private、非static、非final 的方法 抽象類別不可以實例化，抽象類別一定有constructor，以便讓子類別實例化的時候可以進行調用 抽象方法只有方法的宣告、沒有方法體 總結： 包含 抽象方法 的類別，一定是抽象類別；反之，抽象類別中可以無抽象方法 若子類別覆寫父類別的所有抽象方法後，此子類別可以實例化；若子類別沒有覆寫父類的所有抽象方法，則此子類別也是一個抽象類別，需要使用 abstract 修飾 ","permalink":"https://sunwc2023.github.io/blog/abstract/abstract/","tags":["Java"],"title":"Java - 抽象類別 抽象方法"},{"categories":["Java"],"contents":" static 關鍵字： 有些時候，我們希望「某些特定資料在記憶體中只有一份」，且這份資料是大家共享的，而不會隨著物件而不同的，例如：存款利率、最低存款金額、工具類\naccess 靜態變數 實例變數\r類別 Yes No\r物件 Yes Yes\rstatic 特性： static 可以修飾 屬性、方法、程式區塊、內部類 靜態程式區塊 (static block)：(用於類別初始化) 隨著類別加載時，就會執行，且只會執行一次 static { System.out.println(\u0026#34;只要本類別在加載時，我會被輸出\u0026#34;); } 非靜態程式區塊 (non-static block) 隨著每次物件被new時，就會被執行；執行順序優於建構子 (constructor) { System.out.println(\u0026#34;只要本類別在new一個物件時，我會被輸出\u0026#34;); } 靜態變數/靜態方法 是與類別 同時加載的，因此 靜態變數 是早於物件創建 由於類別只會加載一次，因此靜態修飾的結構只會在記憶體中存在一份資料，存在在方法區的靜態域 靜態方法只可以存取靜態變數與靜態方法(早出生不能調晚出生的)；實例方法可以存取靜態結構與實例結構(晚出生能調早出生的)，原因是看在生命週期被創建的時間點 單例設計模式： 所謂類別的單例設計模式，就是採取一定的方法保證在整個程式系統中，對某個類別只能存在一個物件實例。\n如何實現： 具體參考如下\n單例模式的優點： 由於單例模式指生成一個實例，減少了系統性能開銷，當一個物件的產生需要比較多的資源時，如讀取配置、產生其他依賴物件時，則可以通過在應用程式啟動時直接產生一個單例物件，然後永久駐留記憶體的方式來解決，例如 java.lang.Runtime\n現實例子： 網站的計數器 應用程式的日誌應用 資料庫連線池 讀取配置文件的類別 Application 就是單例的典型應用 Windows的Task Manager(任務管理器) Windows的Recycle Bin(資源回收桶) 單例設計模式 方式一 // 餓漢式 public class SingletonTest { public static void main(String[] args) { Bank bank1 = Bank.getInstance(); Bank bank2 = Bank.getInstance(); // 同一個地址值 System.out.println(\u0026#34;bank1 == bank2 : \u0026#34; + (bank1 == bank2)); } } class Bank { // 1. 私有化類別的建構子 private Bank() { } // 2. 類別的內部創建類別的私有物件，且宣告為靜態的 private static Bank instance = new Bank(); // 3. 提供公共靜態的方法，回傳類別的物件 public static Bank getInstance() { return instance; } } 輸出結果：\r```txt\rbank1 == bank2 : true 單例設計模式 方式二 // 懶漢式 public class SingletonTest2 { public static void main(String[] args) { Order order1 = Order.getInstance(); Order order2 = Order.getInstance(); // 同一個地址值 System.out.println(\u0026#34;order1 == order2 : \u0026#34; + (order1 == order2)); } } class Order { static { System.out.println(\u0026#34;static block 類別加載中…\u0026#34;); } // 1. 私有化類別的建構子 private Order() { } // 2. 類別的內部宣告類別變數，但不初始化 private static Order instance = null; // 3. 提供公共靜態的方法，回傳類別的物件 // 要調用的時候再new(非執行緒安全) =\u0026gt; 方法加上 synchronized 關鍵字就成了同步方法(執行緒安全) public static synchronized Order getInstance() { if (instance == null) { // 只new一次 instance = new Order(); } return instance; } { System.out.println(\u0026#34;non-static block 類別物件被new出來了…\u0026#34;); } } 輸出結果：\nstatic block 類別加載中… non-static block 類別物件被new出來了… order1 == order2 : true ","permalink":"https://sunwc2023.github.io/blog/static/static-example/","tags":["Java"],"title":"Java - static 關鍵字 vs. 單例 (Singleton) 設計模式"},{"categories":["Java"],"contents":"Object 的 euqals() 與 == 作用是相同的 是比較兩個物件的記憶體地址是否相同\npublic boolean equals(Object obj) { return (this == obj); } String, java.util.Date, File, wrapper class的 equals() 都已經覆寫Object的 euqals()，比較的不是兩個物件的地址值是否相等，而是比較實體內容是否相同 String s1 = new String(\u0026#34;sunwc\u0026#34;); String s2 = new String(\u0026#34;sunwc\u0026#34;); System.out.println(s1.equals(s2)); //true Date date1 = new Date(32432525324L); Date date2 = new Date(32432525324L); System.out.println(date1.equals(date2)); //true 自定義類別 覆寫 equals() public class Customer { private int age; private String name; public Customer() { super(); } public Customer(int age, String name) { super(); this.age = age; this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } /** * 手動實現 * 覆寫的原則：比較兩個物件的實體內容(即name和age)是否相同 */ @Override public boolean equals(Object obj) { if (this == obj) { return true; } if (obj instanceof Customer) { Customer customer = (Customer) obj; return customer.age == this.age \u0026amp;\u0026amp; customer.name.equals(this.name); } return false; } } /** * IDE 自動生成 equals() 覆寫：比較兩個物件的實體內容(即name和age)是否相同 */ @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Customer other = (Customer) obj; if (age != other.age) return false; if (name == null) { if (other.name != null) return false; } else if (!name.equals(other.name)) return false; return true; } 測試類\npublic class CustomerTest { public static void main(String[] args) { Customer c1 = new Customer(18, \u0026#34;Lucy\u0026#34;); Customer c2 = new Customer(18, \u0026#34;Lucy\u0026#34;); System.out.println(c1.equals(c2)); //true } } 理解 Collection API: contains(), containsAll(), remove(), removeAll()判斷 與 Collection元素擁有equals() 的邏輯判斷有關，主要看該 equals() 是比較記憶體地址 還是 屬性內容？ /** * @author sunwc * @create 2023-03-28 上午 09:56 */ public class CollectionTest { @Test public void collectionTest() { Collection collection = new ArrayList\u0026lt;\u0026gt;(); Person person = new Person(\u0026#34;Jerry\u0026#34;, 20); collection.add(person); System.out.println(collection.size()); // 1 boolean contains = collection.contains(person); // true System.out.println(contains); // 在自定義Person尚未 Override equals()時，默認是使用Object類的 equals()，比較的是 == 的概念 // 因此 比較的是 記憶體的地址 // 所以這時候如果問 new Person(\u0026#34;Jerry\u0026#34;, 20) 是否有包含在集合中時，就會回傳false // 但是如果Person類 Override equals()後，比較的就會是 Person類中的屬性了 // 所以這時候如果問 new Person(\u0026#34;Jerry\u0026#34;, 20) 是否有包含在集合中時，就會回傳true System.out.println(collection.contains(new Person(\u0026#34;Jerry\u0026#34;, 20))); // collection.remove() 與 collection.contains() 的調用的結果，會隨著自定義類別是否覆寫過 equals() 而有不同 boolean jerry = collection.remove(new Person(\u0026#34;Jerry\u0026#34;, 20)); System.out.println(jerry); } } class Person { private String name; private int age; public Person() { } public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { final StringBuilder sb = new StringBuilder(\u0026#34;Person{\u0026#34;); sb.append(\u0026#34;name=\u0026#39;\u0026#34;).append(name).append(\u0026#39;\\\u0026#39;\u0026#39;); sb.append(\u0026#34;, age=\u0026#34;).append(age); sb.append(\u0026#39;}\u0026#39;); return sb.toString(); } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Person person = (Person) o; return age == person.age \u0026amp;\u0026amp; Objects.equals(name, person.name); } } 總結 向 interface Collection 的實現類別的物件容器中，新增元素 obj 時，要求 obj 所在類別要覆寫 equals()\n補充知識 Collection 集合\n特性：元素有序性、元素可重複性 removeAll()：求差集 =\u0026gt; 刪除兩個集合中一樣的所有元素，而保留其他不一樣的元素 retainAll()：求交集 =\u0026gt; 刪除兩個集合中所有不一樣的元素，而保留其他一樣的元素 集合 \u0026ndash;\u0026gt; array Collection collection = new ArrayList\u0026lt;\u0026gt;(); collection.add(123); collection.add(456); Object[] arr = collection.toArray(); System.out.println(Arrays.toString(arr)); // [123, 456] array \u0026ndash;\u0026gt; 集合 List\u0026lt;Integer\u0026gt; list = Arrays.asList(new Integer[]{123,456}); System.out.println(list); // [123, 456] ","permalink":"https://sunwc2023.github.io/blog/compare/equals/","tags":["Java"],"title":"Java - equals 方法"},{"categories":["Java"],"contents":"finalize 方法 一般來說，在物件被回收之前會先存取 物件.finalize()，但是我們不要主動去調finalize()，gc回收機制會主動去調 物件.finalize()\nfinal 關鍵字 * final 修飾類別： 代表本類別就不能被繼承，例如 String, System, StringBuffer 類別\r* final 修飾方法： 代表本方法不能被覆寫 (Override)，例如Object類別的getClass()\r* final 修飾變數： 代表本變數為常量，不能做修改；可以考慮指定值的位置有：顯示初始化、non-static-block 中初始化、constructor 中初始化\r```java\rpublic class SingletonTest2 {\rfinal int WIDTH;\rfinal int HEIGHT;\rfinal double PI;\r// non-static-block\r{\rPI = Math.PI;\r}\r// construtor1\rpublic SingletonTest2() {\rWIDTH = 2;\rHEIGHT = 4;\r}\r// construtor2\rpublic SingletonTest2(int height) {\rWIDTH = 2;\rHEIGHT = height;\r}\r}\r```\rfinal面試題一、\r```java\rpublic class Something {\rpublic int addOne(final int x) {\rreturn ++x; // 編譯錯誤\r// return x + 1; // 編譯、執行成功\r}\r}\r```\rfinal面試題二、\r```java\rpublic class Something {\rpublic static void main(String[] args) {\rOther o = new Other();\rnew Something().addOne(o);\r}\rpublic void addOne(final Other o) {\r// o = new Other(); // 編譯錯誤\r// 被加上final的物件 其屬性是可以修改的\ro.i++; // 編譯、執行成功 }\r}\rclass Other {\rpublic int i;\r}\r```\r* stactic final修飾屬性：代表本屬性為 全局常數\r---\rtry-catch-finally： finally 區塊：一定會被執行的程式\n當 catch 區塊中又出現例外 當 try 區塊有 return 語句 public class ExeptionTest { public static void main(String[] args) { ExeptionTest exeptionTest = new ExeptionTest(); String numberString = exeptionTest.exceptionTest(); System.out.println(numberString); } public String exceptionTest() { try { int[] arr = new int[3]; System.out.println(arr[3]); return \u0026#34;0\u0026#34;; } catch (ArrayIndexOutOfBoundsException e) { System.out.println(\u0026#34;進catch~\u0026#34;); return \u0026#34;1\u0026#34;; } finally { System.out.println(\u0026#34;進finally~\u0026#34;); return \u0026#34;2\u0026#34;; } } } 輸出結果：(finally 區塊執行完畢後，才會執行其他區塊的 return 語句)\n進catch~ 進finally~ 2 finally 關閉資源 JVM 對於物理連接，例如資料庫連線、輸入輸出流、Socket連線銷毀無能為力，否則有內存洩漏的危險，此時資源的釋放，就需要宣告在finally中 @Test public void testFinallyClose() { FileInputStream fis = null; try { File file = new File(\u0026#34;hello.txt\u0026#34;); fis = new FileInputStream(file); // 讀取一個字符 int data = fis.read(); while(data != -1) { System.out.print((char) data); data = fis.read(); } } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } finally { if (fis != null) { try { fis.close(); } catch (IOException e2) { e2.printStackTrace(); } } } } 總結 面試中考題層出現問它們三倆有什麼關係 final, finally, finalize，其實並沒有關係，只是長得像就被放在一起了，透過這篇文章能夠更了解各自的意義，不要下次又搞混了就好了 :)\n","permalink":"https://sunwc2023.github.io/blog/final/final-finally-finalize/","tags":["Java"],"title":"Java - final, finally, finalize 的區別"},{"categories":["Java"],"contents":"encapsulation封裝性： Java提供了4種存取修飾符private ,不寫(default), protected , public來修飾類別及類別的內部結構，體現類別及內部結構在被存取時的可見性(visible)的大小\ninheritance繼承性： 減少程式碼的冗餘，也方便功能的擴展，先有一個類別(子)去繼承另一個類別(父)，而有了父類與子類的關係，子類可以使用父類的所有功能，且子類還可以在父類的基礎之上擴展其他功能 =\u0026gt; is-a 關係(子類 is a 父類)\npolymorphism多型性： 類別的繼承關係 子類要覆寫 (Override) 父類的方法，就能透過父類別使用子類別覆寫的功能 典型例子：資料庫連線 父、子類的設計 物件的多型性：只適用於方法 (Method) =\u0026gt; 又稱 存取虛擬方法 ；但不適用屬性 (Field)！ 多型 例子 package day08.oop; class Person { int age; int name; public Person() { this.age = 1; } public void eat() { System.out.println(\u0026#34;人吃飯\u0026#34;); } public void sleep() { System.out.println(\u0026#34;人睡覺\u0026#34;); } } class Student extends Person { int age; public Student() { this.age = 10; } @Override public void eat() { System.out.println(\u0026#34;學生要吃營養的食物\u0026#34;); } @Override public void sleep() { System.out.println(\u0026#34;學生要睡飽才會長高\u0026#34;); } public void study() { System.out.println(\u0026#34;學生認真學習！\u0026#34;); } } public class PolymorphismTest { public static void main(String[] args) { Person p1 = new Student(); p1.eat(); p1.sleep(); // 會存取到父類別的屬性 System.out.println(\u0026#34;age=\u0026#34;+p1.age); System.out.println(\u0026#34;====================\u0026#34;); // 如何才能使用 p1變數 存取子類別特有的屬性與方法？ // 使用向下轉型：使用強制轉型符 if (p1 instanceof Student) { // 為了避免轉型失敗拋出ClassCastException，先用 instanceof 關鍵字判斷 Student student = (Student) p1; // 會存取到子類別的屬性 System.out.println(\u0026#34;age=\u0026#34;+student.age); student.study(); student.sleep(); } } } 輸出結果：\n學生要吃營養的食物 學生要睡飽才會長高 age=1 ==================== age=10 學生認真學習！ 學生要睡飽才會長高 Overload (多載) vs. Override (覆寫) Overload (概念可稱同名方法) 在編譯 (compile) 時期就會去檢查 方法宣告的參數列表 是否符合 多載 的規定 Override 在編譯 (complie) 時期 會先以父類別變數去存取父類別方法來判斷編譯通不通過，直到執行 (run) 時期 若使用父類別變數存取的方法 子類別有覆寫 (多型概念)，則會是在執行時才在heap區去存取子類別覆寫的方法 PS. 編譯時期看左邊、執行時期看右邊\n","permalink":"https://sunwc2023.github.io/blog/abstract/oop/","tags":["Java"],"title":"Java - OOP 物件導向特性"},{"categories":["Practice"],"contents":" 值轉換數字失敗，會拋出NumberFormatException，詳情請看private static Double isNumeric(Object obj) function\n題目 取得一個Object Array，包含不同data types，排除不是數字、不是浮點型的值\n再將剩下的值使用quick sort進行排序(不可使用Arrays.sort())\n/** * @Description * @author sunwc * @Date 2023年3月19日下午10:39:17 * */ public class QuickSort { public static void main(String[] args) { Object[] objArr = {\u0026#34;2\u0026#34;, \u0026#34;0.3\u0026#34;, 38, null, \u0026#34;hello world\u0026#34;, \u0026#34;100\u0026#34;, 9.27, \u0026#34;-133\u0026#34;, \u0026#34;null\u0026#34;}; // 1. 排除任何不是numeric的值 // 2. 使用quick sort 將 numeric array 進行排序 double[] temp = new double[objArr.length]; int k = 0; for (int i = 0; i \u0026lt; objArr.length; i++) { if (isNumeric(objArr[i]) != null) { temp[k++] = isNumeric(objArr[i]); } } // 再copy array是為了排除temp[] null值的空間 double[] result = Arrays.copyOf(temp, k); // 快速排序 quickSort(result, 0, result.length-1); System.out.println(Arrays.toString(result)); } /** * 判斷object array元素是否為數字 * 是數字回傳Double 不是數字回傳null * @Description * @author sunwc * @Date 2023年3月19日下午10:37:26 * @param obj * @return */ private static Double isNumeric(Object obj) { Double result = null; if (obj == null) { return result; } if (obj instanceof String) { String str = (String) obj; try { result = Double.parseDouble(str); } catch (NumberFormatException e) { result = null; } } else if (obj instanceof Integer) { int temp = (int) obj; result = (double) temp; } else if (obj instanceof Double) { result = (double) obj; } return result; } /** * 快速排序法 * @Description * @author sunwc * @Date 2023年3月19日下午10:41:24 * @param array * @param left * @param right */ public static void quickSort(double[] array, int left, int right) { // 快速排序的終止條件就是當left不小於right if (left \u0026gt;= right) { return; } // 取得partition的標準數 double pivot = array[(left+right)/2]; int partitionInx = partition(array, left, right, pivot); quickSort(array, left, partitionInx - 1); quickSort(array, partitionInx, right); } /** * 使左邊的數比partitionInx小，右邊的數比partitionInx大 * @Description * @author sunwc * @Date 2023年3月19日下午9:29:55 * @param array * @param left * @param right * @param pivot * @return */ private static int partition(double[] array, int left, int right, double pivot) { while (left \u0026lt;= right) { // 只要左邊的值小於pivot就繼續往右移直到找到為止 while (array[left] \u0026lt; pivot) { left++; } // 只要右邊的值大於pivot就繼續往左移直到找到為止 while (array[right] \u0026gt; pivot) { right--; } if (left \u0026lt;= right) { // 兩值交換 swap(array, left, right); left++; right--; } } return left; } /** * 兩值交換 * @Description * @author sunwc * @Date 2023年3月19日下午9:33:43 * @param array * @param left * @param right */ private static void swap(double[] array, int left, int right) { double temp = array[left]; array[left] = array[right]; array[right] = temp; } } 輸出結果：\n[-133.0, 0.3, 2.0, 9.27, 38.0, 100.0] 參考來源： Algorithms: Quicksort\n","permalink":"https://sunwc2023.github.io/blog/array/quick-sort/","tags":["Java"],"title":"Java - 陣列快速排序法 Quick Sort"},{"categories":["Practice"],"contents":"public static void main(String[] args) { // 二分搜尋 // 前提：所要搜尋的陣列必須有序 int[] arr = {-98,-34,2,34,54,66,79,105,210,333}; int target = 34; int startInx = 0; int endInx = arr.length-1; boolean flag = true; while (startInx \u0026lt;= endInx) { int middleInx = (endInx - startInx) / 2 + startInx; if (arr[middleInx] == target) { System.out.println(\u0026#34;target=\u0026#34;+ target+\u0026#34;在index=\u0026#34;+middleInx+\u0026#34;找到了！\u0026#34;); flag = false; break; } else if (arr[middleInx] \u0026lt; target) { startInx = middleInx + 1; } else if (arr[middleInx] \u0026gt; target) { endInx = middleInx - 1; } } if (flag) { System.out.println(\u0026#34;很遺憾沒找到\u0026#34;); } } 輸出結果\ntarget=34在index=3找到了！ array中常見的異常(Exception)： 陣列索引越界：ArrayIndexOutOfBoundsException ","permalink":"https://sunwc2023.github.io/blog/array/array-search/","tags":["Java"],"title":"Java - 陣列二分搜尋"},{"categories":["Practice"],"contents":"陣列反轉 public static void main(String[] args) { String[] arr = new String[] {\u0026#34;PP\u0026#34;,\u0026#34;BB\u0026#34;,\u0026#34;MM\u0026#34;,\u0026#34;GG\u0026#34;,\u0026#34;JJ\u0026#34;,\u0026#34;DD\u0026#34;,\u0026#34;MM\u0026#34;}; String temp; // 方式一、交換arr.length/2次 for (int i = 0; i \u0026lt; arr.length/2; i++) { // 定義臨時變數交換 temp = arr[i]; arr[i] = arr[arr.length -i-1]; arr[arr.length -i-1] = temp; } System.out.println(Arrays.toString(arr)); // 方式二、arr[i], arr[j]於陣列兩端進行交換 for (int i = 0, j = arr.length-1;i \u0026lt; j; i++, j--) { temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } System.out.println(Arrays.toString(arr)); // s1中反轉bcd123，在輸出s1 String s1 = \u0026#34;abcd1234\u0026#34;; char[] chars = s1.toCharArray(); for (int i = 1; i \u0026lt; (chars.length)/2; i++) { char temp = chars[i]; chars[i] = chars[chars.length-1-i]; chars[chars.length-1-i] = temp; } System.out.println(new String(chars)); // a321dcb4 } 輸出結果\n[MM, DD, JJ, GG, MM, BB, PP] 字串反轉 public static void main(String[] args) { // 方式一、 String str = \u0026#34;Hello World\u0026#34;; char[] chars = str.toCharArray(); for (int i = 0; i \u0026lt; chars.length/2; i++) { char temp = chars[i]; chars[i] = chars[chars.length -i-1]; chars[chars.length -i-1] = temp; } System.out.println(chars); // 方式二、 StringBuilder sb1 = new StringBuilder(str); sb1.reverse(); System.out.println(sb1); } 輸出結果\ndlroW olleH ","permalink":"https://sunwc2023.github.io/blog/reversion/array-reversion/","tags":["Java"],"title":"Java - 陣列反轉/字串反轉"},{"categories":["Practice"],"contents":"public static void main(String[] args) { for (int i = 2; i \u0026lt;= 100; i++) { boolean flag = true; // 質數是只能被1與自己整除，所以判斷非質數範圍就只能是 2 ~ (i-1) // for (int j = 2; j \u0026lt; i ; j++) { for (int j = 2; j \u0026lt;= Math.sqrt(i) ; j++) { // 優化二、j \u0026lt;= Math.sqrt(i)開根號：對質數的計算提升效率 if (i % j == 0) { // 非質數 flag = false; // 優化一、break對非質數的計算提升效率 break; } } if (flag) { System.out.println(\u0026#34;印出當前質數 : \u0026#34; + i); } } } 輸出結果\n印出當前質數 : 2 印出當前質數 : 3 印出當前質數 : 5 印出當前質數 : 7 印出當前質數 : 11 印出當前質數 : 13 印出當前質數 : 17 印出當前質數 : 19 印出當前質數 : 23 印出當前質數 : 29 印出當前質數 : 31 印出當前質數 : 37 印出當前質數 : 41 印出當前質數 : 43 印出當前質數 : 47 印出當前質數 : 53 印出當前質數 : 59 印出當前質數 : 61 印出當前質數 : 67 印出當前質數 : 71 印出當前質數 : 73 印出當前質數 : 79 印出當前質數 : 83 印出當前質數 : 89 印出當前質數 : 97 ","permalink":"https://sunwc2023.github.io/blog/exmaple/find-prime-number/","tags":["Java"],"title":"Java - 找1-100中所有質數"},{"categories":["Practice"],"contents":" public static void main(String[] args) { /* 內層迴圈每次執行10次 第1行(i=5) 印星號 j=5 第2行(i=4) 印星號 j=4、6 第3行(i=3) 印星號 j=3、5、7 第4行(i=2) 印星號 j=2、4、6、8 第5行(i=1) 印星號 j=1、3、5、7、9 j其餘情況印一個空白 輸出上半部： * * * * * * * * * * * * * * * */ for (int i = 5; i \u0026gt; 0; i--) { // 計算當前是第幾行，第0行即不用找下一個印星號的位置 int line = 5 - i; int nextPosition = 0; for (int j = 1; j \u0026lt; 10; j++) { // 當 內層迴圈 第一次 i == j 的時候，就先去找下一個印*號的位置 // j == nextPosition(下一個印星號的位置)，就印星號 if (line \u0026gt;= 0 \u0026amp;\u0026amp; (j == i || nextPosition == j)) { System.out.print(\u0026#34;*\u0026#34;); if (line \u0026gt; 0) { // 當印出當前星號後，就開始找到再下個印星號的位置 nextPosition = j + 2; // 當line=0，代表當前這行的星號已經印完了 line--; } } else { // 印空白 System.out.print(\u0026#34; \u0026#34;); } } // 換行 System.out.println(); } /* 內層迴圈每次執行7次 第1行(i=5) 印星號 j=8、6、4、2 第2行(i=4) 印星號 j=7、5、3 第3行(i=3) 印星號 j=6、4 第4行(i=2) 印星號 j=5 j其餘情況印一個空白 輸出下半部： * * * * * * * * * * */ for (int i = 5; i \u0026gt; 1; i--) { // 每行開頭先印一個空白 System.out.print(\u0026#34; \u0026#34;); // 計算當前是第幾行，第0行即不用找下一個印星號的位置 int line = i - 2; int nextPosition = 0; for (int j = 8; j \u0026gt; 1; j--) { // 當 內層迴圈 第一次(i+3) == j 的時候，就先去找下一個印*號的位置 // j == nextPosition(下一個印星號的位置)，就印星號 if (line \u0026gt;= 0 \u0026amp;\u0026amp; (j == (i+3) || nextPosition == j)) { System.out.print(\u0026#34;*\u0026#34;); if (line \u0026gt; 0) { // 當印出當前星號後，就開始找到再下個印星號的位置 nextPosition = j - 2; // 當line=0，代表當前這行的星號已經印完了 line--; } } else { // 印空白 System.out.print(\u0026#34; \u0026#34;); } } // 換行 System.out.println(); } } 輸出結果：\n* * * * * * * * * * * * * * * * * * * * * * * * * ","permalink":"https://sunwc2023.github.io/blog/exmaple/print-diamond/","tags":["Java"],"title":"Java - 打印菱形"},{"categories":["Practice"],"contents":" 思路：越下面的 case 被執行的機率越高，因此要從最下面的 case 1 倒著累加至第一個 case 12；由於沒有 break 語句，因此進入某個 case 後，其 case 下面的所有 case 都會被執行\n判斷該年份是否為閏年標準： 可以被4整除，但不可以被100整除 可以被400整除 public static void main(String[] args) { System.out.println(\u0026#34;請輸入年份 : \u0026#34;); Scanner scanner = new Scanner(System.in); int year = scanner.nextInt(); System.out.println(\u0026#34;請輸入月份 : \u0026#34;); int month = scanner.nextInt(); System.out.println(\u0026#34;請輸入日期 : \u0026#34;); int date = scanner.nextInt(); int result = 0; switch (month) { case 12: result += 30; case 11: result += 31; case 10: result += 30; case 9: result += 31; case 8: result += 31; case 7: result += 30; case 6: result += 31; case 5: result += 30; case 4: result += 31; case 3: // 判斷是否為閏年: true:29天 false:28天 int daysOfFeb = ((year % 4 == 0 \u0026amp;\u0026amp; year % 100 != 0) || year % 400 == 0) ? 29 : 28; result += daysOfFeb; case 2: result += 31; case 1: result += date; } System.out.println(month+\u0026#34;月\u0026#34;+date+\u0026#34;日為\u0026#34;+year+\u0026#34;年的第\u0026#34;+result+\u0026#34;天\u0026#34;); } 輸出結果： 請輸入年份 : 2008 請輸入月份 : 3 請輸入日期 : 17 3月17日為2008的第77天 ","permalink":"https://sunwc2023.github.io/blog/exmaple/days-of-year/","tags":["Java"],"title":"Java - Switch-case 計算X年X月X日為第X年第幾天"},{"categories":["Java"],"contents":" 原始random區間為包含0.0且不包含1.0 =\u0026gt; [0.0,1.0)\n我們可以透過公式Math.random*(b-a+1)+a 取得區間[a,b)的一個數字\n例子 public static void main(String[] args) { // 原始random區間為包含0.0且不包含1.0 double random = Math.random();// [0.0,1.0) // [10-99] 如何取得10-99之間的數：公式 - (b-a+1)+a int result = (int)(Math.random() * (99 - 10) + 1 + 10); System.out.println(result); // [888-999] 如何取得888-999之間的數： result = (int)(Math.random() * (999 - 888 + 1) + 888); System.out.println(result); } 例子 陣列長度10放入隨機數[10-99]、且不重複 public static void main(String[] args) { int[] arr = new int[10]; arr[0] = (int) (Math.random() * (99 - 10 + 1) + 10); // 用來判斷隨機數是否重複 Set set = new HashSet\u0026lt;Integer\u0026gt;(); set.add(arr[0]); int max = arr[0]; int min = arr[0]; int sum = 0; int average = 0; for (int i = 1; i \u0026lt; arr.length; i++) { // 隨機數都是兩位數 int random = (int) (Math.random() * (99 - 10 + 1) + 10); if (set.contains(random)) { i--; } else { // 未重複 arr[i] = random; // 計算總和 sum += arr[i]; // 計算最大值 if (max \u0026lt; arr[i]) { max = arr[i]; } // 計算最小值 if (min \u0026gt; arr[i]) { min = arr[i]; } set.add(random); } } System.out.println(\u0026#34;min=\u0026#34;+min+\u0026#34;,max=\u0026#34;+max+\u0026#34;,average=\u0026#34;+sum/arr.length); System.out.println(Arrays.toString(arr)); } ","permalink":"https://sunwc2023.github.io/blog/exmaple/math-random/","tags":["Java"],"title":"Java - Math.random 使用"},{"categories":["Practice"],"contents":"學習目標: 多型 繼承 --多型-- 撰寫一個 Human 類別 代表人 在這裡我們有兩個衍伸類別 Man 與 Woman 他們用不同的規則活著： Man : 吃飯時 印出\u0026#34;好好吃\u0026#34; 睡覺時 印出\u0026#34;zzz\u0026#34; Woman: 吃飯時 印出\u0026#34;Orzz\u0026#34; 睡覺時 印出\u0026#34;:)\u0026#34; (印出代表用System.our.println(...)) 使用者會輸入一個字串 代表 男人與女人 的順序 ( b -\u0026gt; 男 g -\u0026gt; 女 大小寫皆可) 像是: bgGGBgb 代表 男人有3位 女人有4位 照這個順序排列 (左到右) 之後照著順序印出所有人 吃飯 及 睡覺 的情況 需使用多型 沒頭緒的話就讀熟多型的章節 Example Input bgGGBgb output 輸入字串： bgGGBgb 好好吃 Orzz Orzz Orzz 好好吃 Orzz 好好吃 zzz :) :) :) zzz :) zzz 題目來源\n建立Human抽象類別 public abstract class Human { abstract String eating(); abstract String sleeping(); } 建立男人類別繼承Human class Man extends Human { @Override String eating() { return \u0026#34;好好吃\u0026#34;; } @Override String sleeping() { return \u0026#34;zzz\u0026#34;; } } 建立女人類別繼承Human class Woman extends Human { @Override String eating() { return \u0026#34;Orzz\u0026#34;; } @Override String sleeping() { return \u0026#34;:)\u0026#34;; } } 讓使用者輸入字串，最後照著字串順序印出所有人 吃飯 及 睡覺 的情況 mport java.util.ArrayList; import java.util.List; import java.util.Locale; import java.util.Scanner; public abstract class Human { abstract String eating(); abstract String sleeping(); public static void main(String[] args) { System.out.println(\u0026#34;請輸入一個字串 代表 男人與女人 的順序 ( b -\u0026gt; 男 g -\u0026gt; 女 大小寫皆可)\\n\u0026#34; + \u0026#34;像是: bgGGBgb 代表 男人有3位 女人有4位 照這個順序排列 (左到右)\u0026#34;); // 取得使用者的輸入 Scanner scanner = new Scanner(System.in); // 將取得的字串轉英文小寫 String bgString = scanner.next().toLowerCase(Locale.ROOT); printHumanRoutine(bgString); } /** * 照著順序印出所有人 吃飯 及 睡覺 的情況 * @param bgString */ public static void printHumanRoutine(String bgString) { List\u0026lt;Human\u0026gt; humanList = new ArrayList\u0026lt;\u0026gt;(); // 遍歷字串將男人或女人放入human集合 for (int i = 0; i \u0026lt; bgString.length(); i++) { String str = bgString.charAt(i) + \u0026#34;\u0026#34;; Human human = null; if (\u0026#34;b\u0026#34;.equals(str)) { human = new Man(); } else if (\u0026#34;g\u0026#34;.equals(str)) { human = new Woman(); } System.out.println(human.eating()); humanList.add(human); } for (int i = 0; i \u0026lt; humanList.size(); i++) { Human human = humanList.get(i); System.out.println(human.sleeping()); } } } 總結 最後我覺得 水球潘 對於這個範例的解釋太好了，所以我決定放在這裡讓這個觀念好好住在心裡:)\n在這邊 男人跟女人 是 具體的子類別 因為很清楚 這是男人 這是女人 所以稱為\u0026#34;具體\u0026#34; 那人類呢? 人類具體嗎? Human 你不知道他是哪種人 因此稱之為 \u0026#34;抽象\u0026#34;，抽象的類別 就不該把具體的內容打清楚 所以在定義Human的函數時 會不知道要打什麼內容 抽象類別是不可以被new的 因為他是抽象的 抽象類別 可以定義抽象方法 就是只跟程式說 人類會吃飯 會睡覺 但我不說清楚其具體內容 你必須告訴我你是哪個具體子類別 我才知道你 在睡覺跟吃飯時要做什麼 參考來源\n","permalink":"https://sunwc2023.github.io/blog/abstract/abstract-human/","tags":["Java"],"title":"Java - 多型 繼承"},{"categories":["Experience"],"contents":" 有關如何使用 ThreadLocal 確保 Thread-safety，可以參考我的另一篇文章 Java - ThreadLocal 類的使用\n筆者曾經在不了解 ThreadLocal 類的情況下，錯用 ThreadLocal 客製Log物件的工具類，後來理解 ThreadLocal 運作原理後，在這裡特別記錄下來\n客製 LogBox 類 import java.text.SimpleDateFormat; import java.util.Date; import java.util.LinkedList; import java.util.List; public class LogBox { private static final ThreadLocal\u0026lt;LogBox\u0026gt; currentThreadLogBox = new ThreadLocal\u0026lt;\u0026gt;(); private static final ThreadLocal\u0026lt;SimpleDateFormat\u0026gt; currentThreadSDF = new ThreadLocal\u0026lt;\u0026gt;(); private final String title; private final static String timeType = \u0026#34;yyyy-MM-dd HH:mm:ss.SSS\u0026#34;; private final List\u0026lt;String\u0026gt; logMsgList = new LinkedList\u0026lt;\u0026gt;(); public LogBox(String title) { this.title = title; } /** * 日誌訊息層級 */ public enum MessageType { MESSAGE, DEBUG, WARNING, ERROR } /** * 建立當前執行緒logBox * @param title * @return */ public static LogBox createCurrentThreadLogBox(String title) { LogBox logBox = new LogBox(title); currentThreadLogBox.set(logBox); return logBox; } /** * 取得當前執行緒logBox * 當某個request流程跨function時 * 則可以使用同一個logBox * @return */ public static LogBox getCurrentThreadLogBox() { if (currentThreadLogBox.get() == null) { createCurrentThreadLogBox(\u0026#34;title unset\u0026#34;); } return currentThreadLogBox.get(); } /** * 清除當前執行緒LogBox * 清除當前執行緒SimpleDateTimeFormat * 並取得log字串 * @return */ public String removeLogBoxAndGetLog() { removeCurrentThreadSDF(); currentThreadLogBox.remove(); StringBuilder sb = new StringBuilder(); if (logMsgList.size() \u0026gt; 0) { sb.append(\u0026#34;Log Title : \u0026#34;).append(title); logMsgList.forEach(eachLine -\u0026gt; { sb.append(\u0026#34;\\n\u0026#34;).append(\u0026#34;\\t\u0026#34;).append(eachLine); }); } sb.append(\u0026#34;\\n\u0026#34;).append(\u0026#34;=========================================================\u0026#34;); return sb.toString(); } /** * 簡略示意客製添加 info 層級 log 訊息 * @param msg */ public void info(String msg) { SimpleDateFormat simpleDateFormat = currentThreadSDF.get(); String now = simpleDateFormat.format(new Date()); msg = String.format(\u0026#34;[%s] \u0026#39;%s\u0026#39; %s\u0026#34;, MessageType.MESSAGE, now, msg); logMsgList.add(msg); } // 接收 debug、warn、error 等 log 訊息 function...... /** * 建立當前執行緒SimpleDateFormat * @return */ public static SimpleDateFormat createCurrentThreadSDF() { SimpleDateFormat sdf = new SimpleDateFormat(timeType); currentThreadSDF.set(sdf); return sdf; } /** * 取得當前執行緒SimpleDateFormat * @return */ public static SimpleDateFormat getCurrentThreadSDF() { if (currentThreadSDF.get() == null) { createCurrentThreadSDF(); } return currentThreadSDF.get(); } /** * 清除當前執行緒SimpleDateFormat */ public void removeCurrentThreadSDF() { currentThreadSDF.remove(); } } LogBox 類使用情境\n情境一、這個 LogBox 類實際上是可以應用在 Filter interface 透過建立一個客製類實作 Filter 並實現 doFilter 方法，一開始透過 createCurrentThreadLogBox(title) 建立屬於該 request (該執行緒) 的 ThreadLocal\u0026lt;LogBox\u0026gt; 物件，中間還可以從 request 中取得 requestURI、requestParams 並取得 response 等資訊都加入 ThreadLocal\u0026lt;LogBox\u0026gt; ，等程式從controller層回到 doFilter 再 removeLogBoxAndGetLog() 清除當前執行緒 ThreadLocal\u0026lt;LogBox\u0026gt;\n因為有上面提及的這層操作，因此在SpringBoot framework 的 Controller 或 Service 層的 function 中，就只需要getCurrentThreadLogBox() 取得當前執行緒的 LogBox，並將當前API、業務邏輯所需顯示的 log 內容，透過 log.info(\u0026quot;xxxx\u0026quot;), log.error(exeption message),\u0026hellip; 將不同層級訊息加到 LogBox 中\n圖片來源\n情境二、這個 LogBox 類實際上是可以應用在 quartz 排程 透過建立一個客製類繼承 QuartzJobBean 並覆寫 executeInternal 方法，一開始透過 createCurrentThreadLogBox(title) 建立屬於該排程 (該執行緒) 的 ThreadLocal\u0026lt;LogBox\u0026gt; 物件；不過，此方法可能會再存取 ScheduleService 類的方法，因此在 ScheduleService 層就只需要　getCurrentThreadLogBox() 取得當前執行緒的 LogBox ，並添加業務邏輯所需顯示的 log 內容，透過 log.info(\u0026quot;xxxx\u0026quot;), log.error(exeption message),\u0026hellip; 將不同層級訊息加到 LogBox 中，等排程快結束時程式回到 executeInternal 方法，再 removeLogBoxAndGetLog() 清除當前執行緒 ThreadLocal\u0026lt;LogBox\u0026gt;\n筆者在理解 ThreadLocal 後，但是卻在下面例子的當程式走到 callTransferLimitUpPer30Mins()內部時，該 function 的 log 都印不出來；\n原來的寫法： 在 callTransferLimitUpPer30Mins() function 的內部，才 getCurrentThreadLogBox() 取得當前執行緒的 LogBox，最後才發現這個坑是跟 ExecutorService interface 有關；\n改善後的寫法： 將 LogBox 物件當作傳參送到 callTransferLimitUpPer30Mins(logBox) ，才解決了問題\n例子 quartz入口類 @Slf4j @DisallowConcurrentExecution public class RaiseupTransferLimitJob extends QuartzJobBean { @Autowired CancelRaiseupLimitTask cancelRaiseupLimitTask; public static final String TASK_NAME = QuartzTaskNameConstants.raiseupTransferLimt; public static final String PROP_NAME = \u0026#34;quartz.findBeforeSystemTimeLessThan1Day\u0026#34;; public RaiseupTransferLimitJob() { QuartzJobService.descriptionMap.put(TASK_NAME, \u0026#34;re-send raiseupTransferLimit\u0026#34;); QuartzJobService.taskDisplayNameMap.put(TASK_NAME, TASK_NAME); } @Override public void executeInternal(JobExecutionContext jobExecutionContext) { String logTitle = new Exception().getStackTrace()[0].getClassName()+\u0026#34;.\u0026#34;+new Exception().getStackTrace()[0].getMethodName(); LogBox logBox = LogBox.createCurrentThreadLogBox(logTitle); logBox.info(\u0026#34;start running callTransferLimitUpPer30Mins\u0026#34;); try { cancelRaiseupLimitTask.cancelTaskPer60MINS(); } catch (Exception e) { logBox.error(e); } finally { logBox.info(\u0026#34;end run callTransferLimitUpPer30Mins\u0026#34;); String logString = logBox.removeLogBoxAndGetLog(); if (logString != null \u0026amp;\u0026amp; logString.trim().length() \u0026gt; 0) { log.info(logString); } } } } quartz入口類呼叫ScheduleService類方法 public void cancelTaskPer60MINS() throws Exception { LogBox logBox = LogBox.getThreadLocalLogBox(); ExecutorService executor = Executors.newSingleThreadExecutor(); Future\u0026lt;String\u0026gt; future = executor.submit(() -\u0026gt; { // 需求是若排程有timeout情況產生，單一排程至多執行60分鐘\tcallTransferLimitUpPer30Mins(logBox); // 排程業務邏輯 logBox.info(\u0026#34;callTransferLimitUpPer30Mins is completed!\u0026#34;); return \u0026#34;Ready!\u0026#34;; }); try { logBox.info(\u0026#34;Every 60 minutes is started..\u0026#34;); // 設置最大等待時間 logBox.info(future.get(60, TimeUnit.MINUTES)); logBox.info(\u0026#34;Every 60 minutes is finished!\u0026#34;); } catch (TimeoutException e) { // 允許取消正在運行的執行緒——以拋出異常的方式中斷 future.cancel(true); logBox.info(\u0026#34;callTransferLimitUpPer30Mins is terminated!\u0026#34;); } executor.shutdownNow(); logBox.info(\u0026#34;cancelTaskPer60MINS shutdown now\u0026#34;); } 圖片參考\n總結 關於 log 印不出來，我的想法是 原來在主執行緒的 LogBox ，與 Executors 建立的單一執行緒裡的 LogBox 彼此之間是不互相影響的；但是只有主執行緒的 LogBox 可以印出 log (因為最後有 removeLogBoxAndGetLog() )，所以我就必須將主執行緒產生出來的 LogBox 當作傳參送入 callTransferLimitUpPer30Mins(logBox)，這樣就沒問題啦！\n","permalink":"https://sunwc2023.github.io/blog/thread/thread-local-example/","tags":["Java"],"title":"Java - ThreadLocal 實際應用"},{"categories":["Java"],"contents":" 有關在實際工作上使用到 ThreadLocal 的例子，可以參考我的另一篇文章 Java - ThreadLocal 實際應用\nThreadLocal 實現原理 ThreadLocal 從字面義直翻，就是執行緒 (Thread) 的局部變數，是每一個執行緒所單獨持有，其他執行緒不能對其進行存取\nThreadLocal 支持泛型，也就是支持 value 是可以設置的，像是 ThreadLocal\u0026lt;Integer\u0026gt; 就是設置 value 為 Integer 類型\n每個執行緒會有自己一份 ThreadLocalMap 副本，去儲存這個執行緒自己想存放的 ThreadLocal\u0026lt;T\u0026gt; 變數們，ThreadLocalMap 副本內部儲存的是一個 key-value 對，其中 key 是某個 ThreadLocal\u0026lt;T\u0026gt; 物件實例 ， value 就是這個執行緒、該 ThreadLocal\u0026lt;T\u0026gt; 物件實例 set 的值，所以對一個執行緒來說，一個 ThreadLocal\u0026lt;T\u0026gt; 只能存一個值，而一個執行緒可以存放多個 ThrealLocal\u0026lt;T\u0026gt;\nJDK Souce code public class Thread implements Runnable { // Thread 類裡的threadLocals 存放此執行緒的專有 ThreadLocalMap 副本 ThreadLocal.ThreadLocalMap threadLocals = null; } public class ThreadLocal\u0026lt;T\u0026gt; { // 根據執行緒，取得那個執行緒自己的 ThreadLocalMap ThreadLocalMap getMap(Thread t) { return t.threadLocals; } static class ThreadLocalMap { // ThreadLocalMap 的 key 是使用 \u0026#34;弱引用\u0026#34; 的 ThreadLocal\u0026lt;T\u0026gt; static class Entry extends WeakReference\u0026lt;ThreadLocal\u0026lt;?\u0026gt;\u0026gt; { Object value; // ThreadLocalMap 中的 key 就是 ThreadLocal\u0026lt;T\u0026gt;，value 就是設置的值 Entry(ThreadLocal\u0026lt;?\u0026gt; k, Object v) { super(k); value = v; } } } public T get() { // 取得當前執行緒 Thread t = Thread.currentThread(); // 每個執行緒 都有一個自己的 ThreadLocalMap // ThreadLocalMap 裡就保存著所有的ThreadLocal\u0026lt;T\u0026gt;變數 ThreadLocalMap map = getMap(t); if (map != null) { // ThreadLocalMap 的 key 就是當前 ThreadLocal\u0026lt;T\u0026gt; 物件實例 // 多個 ThreadLocal\u0026lt;T\u0026gt; 變數都是放在這個 map 中的 ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) // 從 map 裡取出來的值就是我們需要的這個 ThreadLocal\u0026lt;T\u0026gt; 變數 T result = (T)e.value; return result; } } // 如果 map 沒有初始化，那麼在這裡初始化一下 return setInitialValue(); } public void set(T value) { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) { map.set(this, value); } else { createMap(t, value); } } public void remove() { ThreadLocalMap map = getMap(Thread.currentThread()); if (map != null) { map.remove(this); } } } ThreadLocal 常用方法 set(x) : 設置此執行緒的想要放的值 x get() : 取得此執行緒當初存放的值，如果沒有存放過則返回 null remove() : 刪除此執行緒的 key-value 對，也就是如果先執行 remove 再執行 get，會返回 null 可以創建多個 ThreadLocal\u0026lt;T\u0026gt; 物件，對每個 ThreadLocal\u0026lt;T\u0026gt; 都設置不同的值\n像是以下的例子，在 main 執行緒中的 ThreadLocalMap ，就有兩個 key-value 的映射，userIdThreadLocal -\u0026gt; 100、userNameThreadLocal -\u0026gt; hello 例子 public class Main { public static void main(String[] args){ ThreadLocal\u0026lt;Integer\u0026gt; userIdThreadLocal = new ThreadLocal\u0026lt;\u0026gt;(); ThreadLocal\u0026lt;String\u0026gt; userNameThreacLocal = new ThreadLocal\u0026lt;\u0026gt;(); userId.set(100); userName.set(\u0026#34;hello\u0026#34;); } } ThreadLocal 存在內存洩露 這邊不多去探討這個議題，內存洩漏是可以避免的，只要當前執行緒要結束前記得即時的remove()，也就是是使得 ThreadLocalMap 中不要存在這個 key-value 對，這樣才能確保 GC 能正確回收\n以下有更多的文章，仔細地談論 ThreadLocal 內存洩漏問題 與 Java 自身解決的方式，但都不治本！還是當前執行緒用完 ThreadLocal 記得呼叫remove()，才是確保線程安全的根本之道！\n參考資料：\nJava - ThreadLocal 類的使用\nThreadLocal使用與原理\nSimpleDateFormat 非線程安全？ 由於 SimpleDateFormat 本身非 synchronized ，所以如果在不同執行緒使用同一個 SimpleDateFormat ，就會導致輸出的時間異常，請看以下的例子\n例子 public static void main(String[] args) { DateFormat sdf = new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); Date date1 = new Date(1614820308016L); Date date2 = new Date(1615820309016L); System.out.println(\u0026#34;初始定義時間1 : \u0026#34; + sdf.format(date1)); System.out.println(\u0026#34;初始定義時間2 : \u0026#34; + sdf.format(date2)); Thread t1 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 100; i++) { String dateStr = sdf.format(date1); if (!\u0026#34;2021-03-04 09:11:48\u0026#34;.equals(dateStr)) { System.out.println(Thread.currentThread().getName() + \u0026#34;異常時間為 : \u0026#34; + dateStr); } } }, \u0026#34;thread 1\u0026#34;); Thread t2 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 100; i++) { String dateStr = sdf.format(date2); if (!\u0026#34;2021-03-15 22:58:29\u0026#34;.equals(dateStr)) { System.out.println(Thread.currentThread().getName() + \u0026#34;異常時間為 : \u0026#34; + dateStr); } } }, \u0026#34;Thread 2\u0026#34;); t1.start(); t2.start(); try { t1.join(); t2.join(); } catch (InterruptedException e) { e.printStackTrace(); } } 輸出異常：(Thread2 輸出了 Thread1 的時間)\n初始定義時間1 : 2021-03-04 09:11:48 初始定義時間2 : 2021-03-15 22:58:29 Thread 2異常時間為 : 2021-03-04 09:11:48 但是， ThreadLocal 可以解決非線程安全的問題，只要在各自的執行緒，持有各自的ThreadLocal\u0026lt;DateFormat\u0026gt;，就不會有問題了，請看下面的例子\npublic static void main(String[] args) { DateFormat sdf = new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); Date date1 = new Date(1614820308016L); Date date2 = new Date(1615820309016L); System.out.println(\u0026#34;初始定義時間1 : \u0026#34; + sdf.format(date1)); System.out.println(\u0026#34;初始定義時間2 : \u0026#34; + sdf.format(date2)); Thread t1 = new Thread(() -\u0026gt; { ThreadLocal\u0026lt;DateFormat\u0026gt; currentSDF = new ThreadLocal\u0026lt;\u0026gt;(); DateFormat df1 = new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); currentSDF.set(df1); DateFormat dateFormat1 = currentSDF.get(); for (int i = 0; i \u0026lt; 100; i++) { String dateStr = dateFormat1.format(date1); if (!\u0026#34;2021-03-04 09:11:48\u0026#34;.equals(dateStr)) { System.out.println(Thread.currentThread().getName() + \u0026#34;異常時間為 : \u0026#34; + dateStr); } } currentSDF.remove(); }, \u0026#34;thread 1\u0026#34;); Thread t2 = new Thread(() -\u0026gt; { ThreadLocal\u0026lt;DateFormat\u0026gt; currentSDF = new ThreadLocal\u0026lt;\u0026gt;(); DateFormat df2 = new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); currentSDF.set(df2); DateFormat dateFormat2 = currentSDF.get(); for (int i = 0; i \u0026lt; 100; i++) { String dateStr = dateFormat2.format(date2); if (!\u0026#34;2021-03-15 22:58:29\u0026#34;.equals(dateStr)) { System.out.println(Thread.currentThread().getName() + \u0026#34;異常時間為 : \u0026#34; + dateStr); } } currentSDF.remove(); }, \u0026#34;Thread 2\u0026#34;); t1.start(); t2.start(); try { t1.join(); t2.join(); } catch (InterruptedException e) { e.printStackTrace(); } } 輸出正常：\n初始定義時間1 : 2021-03-04 09:11:48 初始定義時間2 : 2021-03-15 22:58:29 參考來源\n","permalink":"https://sunwc2023.github.io/blog/thread/thread-local/","tags":["Java"],"title":"Java - ThreadLocal 類的使用"}]