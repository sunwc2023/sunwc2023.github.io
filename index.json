[{"categories":["Java"],"contents":"","permalink":"https://sunwc2023.github.io/blog/exception-example/","tags":["Java"],"title":"Java - 例外處理 (Exception)"},{"categories":["Java"],"contents":" interface 可以定義全局常量、抽象方法、靜態方法與默認方法 interface 沒有 constructor，因此也不可以實例化 Java類可以 implements 多個 interface ，彌補了 Java 單繼承的侷限性 (先寫繼承後寫實現) 格式類似如下： public final class String extends Object implements java.io.Serializable, Comparable\u0026lt;String\u0026gt;, CharSequence { } interface 之間可以多繼承 interface 體現多型的特性 可以把 interface 看作是一種規範 (contract) 現實例子： USB adaptor、JDBC interface 操作資料庫的規範(MySQL Driver, MSSQL Driver, Oracle Driver,\u0026hellip;.)\n/** * interface USB * @Description * @author sunwc * @Date 2023年3月22日下午12:31:17 * */ interface USB { // 全局常量：定義了長、寬、高、最小傳輸速度等 public static final int WIDTH = 3; // 驅動 void start(); void stop(); // 靜態方法(有方法體) public static void staticMethod() { System.out.println(\u0026#34;interface USB靜態方法\u0026#34;); } // 默認方法(有方法體) public default void defaultMethod1() { System.out.println(\u0026#34;interface USB默認方法1\u0026#34;); } public default void defaultMethod2() { System.out.println(\u0026#34;interface USB默認方法2\u0026#34;); } } /** * 創見USB 實現 interface USB * @Description * @author sunwc * @Date 2023年3月22日下午12:33:16 * */ class Transcend implements USB { @Override public void start() { System.out.println(\u0026#34;Transcend USB開啟工作\u0026#34;); } @Override public void stop() { System.out.println(\u0026#34;Transcend USB結束工作\u0026#34;); } @Override public void defaultMethod1() { System.out.println(\u0026#34;Transcend覆寫defaultMethod1\u0026#34;); } public void myMethod() { // 調用自己定義的覆寫方法 defaultMethod1(); // 調用interface中的默認方法 USB.super.defaultMethod1(); } } /** * 電腦類 * @Description * @author sunwc * @Date 2023年3月22日下午12:33:01 * */ class Computer { /** * 傳輸資料 * @Description * @author sunwc * @Date 2023年3月22日下午2:58:08 * @param usb */ public void transferData(USB usb) { usb.start(); System.out.println(\u0026#34;具體傳輸資料細節\u0026#34;); usb.stop(); } } /** * 測試類 * @Description * @author sunwc * @Date 2023年3月22日下午12:33:27 * */ public class USBTest { public static void main(String[] args) { Computer computer = new Computer(); Transcend transcend = new Transcend();// Usb usb = new Transcend(); computer.transferData(transcend); System.out.println(\u0026#34;=============================\u0026#34;); // interface的靜態方法只能透過interface進行調用 USB.staticMethod(); // 實現類可以覆寫interface的default方法 transcend.defaultMethod1(); // 若實現類沒有覆寫interface的default方法，則執行原本default方法的內容 transcend.defaultMethod2(); System.out.println(\u0026#34;==============================\u0026#34;); transcend.myMethod(); } } 輸出結果：\nTranscend USB開啟工作 具體傳輸資料細節 Transcend USB結束工作 ============================= interface USB靜態方法 Transcend覆寫defaultMethod1 interface USB默認方法2 ============================== Transcend覆寫defaultMethod1 interface USB默認方法1 結論：\ninterface 與 抽象類別 都不能被實例化，因此均體現 多型 的特性，需要子類別來繼承 或 實現類來實現\r以上面的例子來說，電腦傳輸資料時，可以接受符合USB規範的各種物件，這就是多型的體現方式，因為電腦不用管USB是哪種牌子的，只要是符合interface USB規範都可以，也就能夠透過USB usb變數去執行 實現類別 Override 的 start()與stop()了\n","permalink":"https://sunwc2023.github.io/blog/interface/","tags":["Java"],"title":"Java - interface"},{"categories":["Java"],"contents":" static 關鍵字：有些時候，我們希望「某些特定資料在記憶體中只有一份」，且這份資料是大家共享的，而不會隨著物件而不同的，例如：存款利率、最低存款金額、工具類\naccess 靜態變數 實例變數\r類別 Yes No\r物件 Yes Yes\rstatic 可以修飾 屬性、方法、程式區塊、內部類 靜態程式區塊 (static block)：(用於類別初始化) 隨著類別加載時，就會執行，且只會執行一次 static { System.out.println(\u0026#34;只要本類別在加載時，我會被輸出\u0026#34;); } 非靜態程式區塊 (non-static block) 隨著每次物件被new時，就會被執行；執行順序優於建構子 (constructor) { System.out.println(\u0026#34;只要本類別在new一個物件時，我會被輸出\u0026#34;); } 靜態變數/靜態方法 是與類別 同時加載的，因此 靜態變數 是早於物件創建 由於類別只會加載一次，因此靜態修飾的結構只會在記憶體中存在一份資料，存在在方法區的靜態域 靜態方法只可以存取靜態變數與靜態方法(早出生不能調晚出生的)；實例方法可以存取靜態結構與實例結構(晚出生能調早出生的)，原因是看在生命週期被創建的時間點 單例設計模式：\n所謂類別的單例設計模式，就是採取一定的方法保證在整個程式系統中，對某個類別只能存在一個物件實例。\n如何實現： 具體參考如下\n單例模式的優點： 由於單例模式指生成一個實例，減少了系統性能開銷，當一個物件的產生需要比較多的資源時，如讀取配置、產生其他依賴物件時，則可以通過在應用程式啟動時直接產生一個單例物件，然後永久駐留記憶體的方式來解決，例如 java.lang.Runtime\n現實例子： 網站的計數器 應用程式的日誌應用 資料庫連線池 讀取配置文件的類別 Application 就是單例的典型應用 Windows的Task Manager(任務管理器) Windows的Recycle Bin(資源回收桶) 方式一 // 餓漢式 public class SingletonTest { public static void main(String[] args) { Bank bank1 = Bank.getInstance(); Bank bank2 = Bank.getInstance(); // 同一個地址值 System.out.println(\u0026#34;bank1 == bank2 : \u0026#34; + (bank1 == bank2)); } } class Bank { // 1. 私有化類別的建構子 private Bank() { } // 2. 類別的內部創建類別的私有物件，且宣告為靜態的 private static Bank instance = new Bank(); // 3. 提供公共靜態的方法，回傳類別的物件 public static Bank getInstance() { return instance; } } 輸出結果：\r```txt\rbank1 == bank2 : true 方式二 // 懶漢式 public class SingletonTest2 { public static void main(String[] args) { Order order1 = Order.getInstance(); Order order2 = Order.getInstance(); // 同一個地址值 System.out.println(\u0026#34;order1 == order2 : \u0026#34; + (order1 == order2)); } } class Order { static { System.out.println(\u0026#34;static block 類別加載中…\u0026#34;); } // 1. 私有化類別的建構子 private Order() { } // 2. 類別的內部宣告類別變數，但不初始化 private static Order instance = null; // 3. 提供公共靜態的方法，回傳類別的物件 // 要調用的時候再new(非線程安全) public static Order getInstance() { if (instance == null) { // 只new一次 instance = new Order(); } return instance; } { System.out.println(\u0026#34;non-static block 類別物件被new出來了…\u0026#34;); } } 輸出結果：\nstatic block 類別加載中… non-static block 類別物件被new出來了… order1 == order2 : true ","permalink":"https://sunwc2023.github.io/blog/static-example/","tags":["Java"],"title":"Java - static 關鍵字 vs. 單例 (Singleton) 設計模式"},{"categories":["Java"],"contents":" Object 的 euqals() 與 == 作用是相同的，是比較兩個物件的記憶體地址是否相同 public boolean equals(Object obj) { return (this == obj); } String, java.util.Date, File, wrapper class的 equals() 都已經覆寫Object的 euqals()，比較的不是兩個物件的地址值是否相等，而是比較實體內容是否相同 String s1 = new String(\u0026#34;sunwc\u0026#34;); String s2 = new String(\u0026#34;sunwc\u0026#34;); System.out.println(s1.equals(s2)); //true Date date1 = new Date(32432525324L); Date date2 = new Date(32432525324L); System.out.println(date1.equals(date2)); //true 自定義類別 覆寫 equals() public class Customer { private int age; private String name; public Customer() { super(); } public Customer(int age, String name) { super(); this.age = age; this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } /** * 手動實現 * 覆寫的原則：比較兩個物件的實體內容(即name和age)是否相同 */ @Override public boolean equals(Object obj) { if (this == obj) { return true; } if (obj instanceof Customer) { Customer customer = (Customer) obj; return customer.age == this.age \u0026amp;\u0026amp; customer.name.equals(this.name); } return false; } } /** * IDE 自動生成 equals() 覆寫：比較兩個物件的實體內容(即name和age)是否相同 */ @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Customer other = (Customer) obj; if (age != other.age) return false; if (name == null) { if (other.name != null) return false; } else if (!name.equals(other.name)) return false; return true; } 測試\npublic class CustomerTest { public static void main(String[] args) { Customer c1 = new Customer(18, \u0026#34;Lucy\u0026#34;); Customer c2 = new Customer(18, \u0026#34;Lucy\u0026#34;); System.out.println(c1.equals(c2)); //true } } ","permalink":"https://sunwc2023.github.io/blog/equals/","tags":["Java"],"title":"Java - equals 方法"},{"categories":["Java"],"contents":" finalize 方法： 一般來說，在物件被回收之前會先存取 物件.finalize()，但是我們不要主動去調finalize()，gc回收機制會主動去調 物件.finalize()\nfinal 關鍵字\nfinal 修飾類別： 代表本類別就不能被繼承，例如 String, System, StringBuffer 類別 final 修飾方法： 代表本方法不能被覆寫 (Override)，例如Object類別的getClass() final 修飾變數： 代表本變數為常量，不能做修改；可以考慮指定值的位置有：顯示初始化、non-static-block 中初始化、constructor 中初始化 public class SingletonTest2 { final int WIDTH; final int HEIGHT; final double PI; // non-static-block { PI = Math.PI; } // construtor1 public SingletonTest2() { WIDTH = 2; HEIGHT = 4; } // construtor2 public SingletonTest2(int height) { WIDTH = 2; HEIGHT = height; } } final面試題一、\npublic class Something { public int addOne(final int x) { return ++x; // 編譯錯誤 // return x + 1; // 編譯、執行成功 } } final面試題二、\npublic class Something { public static void main(String[] args) { Other o = new Other(); new Something().addOne(o); } public void addOne(final Other o) { // o = new Other(); // 編譯錯誤 // 被加上final的物件 其屬性是可以修改的 o.i++; // 編譯、執行成功 } } class Other { public int i; } stactic final修飾屬性：代表本屬性為 全局常量 ","permalink":"https://sunwc2023.github.io/blog/final-finally-finalize/","tags":["Java"],"title":"Java - final, finally, finalize 的區別"},{"categories":["Java"],"contents":" encapsulation封裝性：Java提供了4種存取修飾符(private ,不寫(default), protected , public )來修飾類別及類別的內部結構，體現類別及內部結構在被存取時的可見性(visible)的大小\ninheritance繼承性：減少程式碼的冗餘，也方便功能的擴展，先有一個類別(子)去繼承另一個類別(父)，而有了父類與子類的關係，子類可以使用父類的所有功能，且子類還可以在父類的基礎之上擴展其他功能 =\u0026gt; is-a 關係(子類 is a 父類)\npolymorphism多型性：\n類別的繼承關係 子類要覆寫 (Override) 父類的方法，就能透過父類別使用子類別覆寫的功能 典型例子：資料庫連線 父、子類的設計 物件的多型性：只適用於方法 (Method) =\u0026gt; 又稱 存取虛擬方法 ；但不適用屬性 (Field)！ 多型的例子，請看下面：\npackage day08.oop; class Person { int age; int name; public Person() { this.age = 1; } public void eat() { System.out.println(\u0026#34;人吃飯\u0026#34;); } public void sleep() { System.out.println(\u0026#34;人睡覺\u0026#34;); } } class Student extends Person { int age; public Student() { this.age = 10; } @Override public void eat() { System.out.println(\u0026#34;學生要吃營養的食物\u0026#34;); } @Override public void sleep() { System.out.println(\u0026#34;學生要睡飽才會長高\u0026#34;); } public void study() { System.out.println(\u0026#34;學生認真學習！\u0026#34;); } } public class PolymorphismTest { public static void main(String[] args) { Person p1 = new Student(); p1.eat(); p1.sleep(); // 會存取到父類別的屬性 System.out.println(\u0026#34;age=\u0026#34;+p1.age); System.out.println(\u0026#34;====================\u0026#34;); // 如何才能使用 p1變數 存取子類別特有的屬性與方法？ // 使用向下轉型：使用強制轉型符 if (p1 instanceof Student) { // 為了避免轉型失敗拋出ClassCastException，先用 instanceof 關鍵字判斷 Student student = (Student) p1; // 會存取到子類別的屬性 System.out.println(\u0026#34;age=\u0026#34;+student.age); student.study(); student.sleep(); } } } 輸出結果：\n學生要吃營養的食物 學生要睡飽才會長高 age=1 ==================== age=10 學生認真學習！ 學生要睡飽才會長高 Overload (多載) vs. Override (覆寫)\nOverload (概念可稱同名方法) 在編譯 (compile) 時期就會去檢查 方法宣告的參數列表 是否符合 多載 的規定 Override 在編譯 (complie) 時期 會先以父類別變數去存取父類別方法來判斷編譯通不通過，直到執行 (run) 時期 若使用父類別變數存取的方法 子類別有覆寫 (多型概念)，則會是在執行時才在heap區去存取子類別覆寫的方法 PS. 編譯時期看左邊、執行時期看右邊\n","permalink":"https://sunwc2023.github.io/blog/oop/","tags":["Java"],"title":"Java - OOP 物件導性特性"},{"categories":["Practice"],"contents":" 值轉換數字失敗，會拋出NumberFormatException，詳情請看private static Double isNumeric(Object obj) function\n/** * 題目：取得一個Object Array，包含不同data types，排除不是數字、不是浮點型的值 * 再將剩下的值使用quick sort進行排序(不可使用Arrays.sort()) * @Description * @author sunwc * @Date 2023年3月19日下午10:39:17 * */ public class QuickSort { public static void main(String[] args) { Object[] objArr = {\u0026#34;2\u0026#34;, \u0026#34;0.3\u0026#34;, 38, null, \u0026#34;hello world\u0026#34;, \u0026#34;100\u0026#34;, 9.27, \u0026#34;-133\u0026#34;, \u0026#34;null\u0026#34;}; // 1. 排除任何不是numeric的值 // 2. 使用quick sort 將 numeric array 進行排序 double[] temp = new double[objArr.length]; int k = 0; for (int i = 0; i \u0026lt; objArr.length; i++) { if (isNumeric(objArr[i]) != null) { temp[k++] = isNumeric(objArr[i]); } } // 再copy array是為了排除temp[] null值的空間 double[] result = Arrays.copyOf(temp, k); // 快速排序 quickSort(result, 0, result.length-1); System.out.println(Arrays.toString(result)); } /** * 判斷object array元素是否為數字 * 是數字回傳Double 不是數字回傳null * @Description * @author sunwc * @Date 2023年3月19日下午10:37:26 * @param obj * @return */ private static Double isNumeric(Object obj) { Double result = null; if (obj == null) { return result; } if (obj instanceof String) { String str = (String) obj; try { result = Double.parseDouble(str); } catch (NumberFormatException e) { result = null; } } else if (obj instanceof Integer) { int temp = (int) obj; result = (double) temp; } else if (obj instanceof Double) { result = (double) obj; } return result; } /** * 快速排序法 * @Description * @author sunwc * @Date 2023年3月19日下午10:41:24 * @param array * @param left * @param right */ public static void quickSort(double[] array, int left, int right) { // 快速排序的終止條件就是當left不小於right if (left \u0026gt;= right) { return; } // 取得partition的標準數 double pivot = array[(left+right)/2]; int partitionInx = partition(array, left, right, pivot); quickSort(array, left, partitionInx - 1); quickSort(array, partitionInx, right); } /** * 使左邊的數比partitionInx小，右邊的數比partitionInx大 * @Description * @author sunwc * @Date 2023年3月19日下午9:29:55 * @param array * @param left * @param right * @param pivot * @return */ private static int partition(double[] array, int left, int right, double pivot) { while (left \u0026lt;= right) { // 只要左邊的值小於pivot就繼續往右移直到找到為止 while (array[left] \u0026lt; pivot) { left++; } // 只要右邊的值大於pivot就繼續往左移直到找到為止 while (array[right] \u0026gt; pivot) { right--; } if (left \u0026lt;= right) { // 兩值交換 swap(array, left, right); left++; right--; } } return left; } /** * 兩值交換 * @Description * @author sunwc * @Date 2023年3月19日下午9:33:43 * @param array * @param left * @param right */ private static void swap(double[] array, int left, int right) { double temp = array[left]; array[left] = array[right]; array[right] = temp; } } 輸出結果：\n[-133.0, 0.3, 2.0, 9.27, 38.0, 100.0] 參考來源： Algorithms: Quicksort\n","permalink":"https://sunwc2023.github.io/blog/quick-sort/","tags":["Java"],"title":"Java - 陣列快速排序法 Quick Sort"},{"categories":["Practice"],"contents":"public static void main(String[] args) { // 二分搜尋 // 前提：所要搜尋的陣列必須有序 int[] arr = {-98,-34,2,34,54,66,79,105,210,333}; int target = 34; int startInx = 0; int endInx = arr.length-1; boolean flag = true; while (startInx \u0026lt;= endInx) { int middleInx = (endInx - startInx) / 2 + startInx; if (arr[middleInx] == target) { System.out.println(\u0026#34;target=\u0026#34;+ target+\u0026#34;在index=\u0026#34;+middleInx+\u0026#34;找到了！\u0026#34;); flag = false; break; } else if (arr[middleInx] \u0026lt; target) { startInx = middleInx + 1; } else if (arr[middleInx] \u0026gt; target) { endInx = middleInx - 1; } } if (flag) { System.out.println(\u0026#34;很遺憾沒找到\u0026#34;); } } 輸出結果\ntarget=34在index=3找到了！ array中常見的異常(Exception)： 陣列索引越界：ArrayIndexOutOfBoundsException ","permalink":"https://sunwc2023.github.io/blog/array-search/","tags":["Java"],"title":"Java - 陣列二分搜尋"},{"categories":["Practice"],"contents":" 陣列反轉 public static void main(String[] args) { String[] arr = new String[] {\u0026#34;PP\u0026#34;,\u0026#34;BB\u0026#34;,\u0026#34;MM\u0026#34;,\u0026#34;GG\u0026#34;,\u0026#34;JJ\u0026#34;,\u0026#34;DD\u0026#34;,\u0026#34;MM\u0026#34;}; String temp; // 方式一、交換arr.length/2次 for (int i = 0; i \u0026lt; arr.length/2; i++) { // 定義臨時變數交換 temp = arr[i]; arr[i] = arr[arr.length -i-1]; arr[arr.length -i-1] = temp; } System.out.println(Arrays.toString(arr)); // 方式二、arr[i], arr[j]於陣列兩端進行交換 for (int i = 0, j = arr.length-1;i \u0026lt; j; i++, j--) { temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } System.out.println(Arrays.toString(arr)); } 輸出結果\n[MM, DD, JJ, GG, MM, BB, PP] 字串反轉 public static void main(String[] args) { String str = \u0026#34;Hello World\u0026#34;; char[] chars = str.toCharArray(); for (int i = 0; i \u0026lt; chars.length/2; i++) { char temp = chars[i]; chars[i] = chars[chars.length -i-1]; chars[chars.length -i-1] = temp; } System.out.println(chars); } 輸出結果\ndlroW olleH ","permalink":"https://sunwc2023.github.io/blog/array-reversion/","tags":["Java"],"title":"Java - 陣列反轉/字串反轉"},{"categories":["Practice"],"contents":"public static void main(String[] args) { for (int i = 2; i \u0026lt;= 100; i++) { boolean flag = true; // 質數是只能被1與自己整除，所以判斷非質數範圍就只能是 2 ~ (i-1) // for (int j = 2; j \u0026lt; i ; j++) { for (int j = 2; j \u0026lt;= Math.sqrt(i) ; j++) { // 優化二、j \u0026lt;= Math.sqrt(i)開根號：對質數的計算提升效率 if (i % j == 0) { // 非質數 flag = false; // 優化一、break對非質數的計算提升效率 break; } } if (flag) { System.out.println(\u0026#34;印出當前質數 : \u0026#34; + i); } } } 輸出結果\n印出當前質數 : 2 印出當前質數 : 3 印出當前質數 : 5 印出當前質數 : 7 印出當前質數 : 11 印出當前質數 : 13 印出當前質數 : 17 印出當前質數 : 19 印出當前質數 : 23 印出當前質數 : 29 印出當前質數 : 31 印出當前質數 : 37 印出當前質數 : 41 印出當前質數 : 43 印出當前質數 : 47 印出當前質數 : 53 印出當前質數 : 59 印出當前質數 : 61 印出當前質數 : 67 印出當前質數 : 71 印出當前質數 : 73 印出當前質數 : 79 印出當前質數 : 83 印出當前質數 : 89 印出當前質數 : 97 ","permalink":"https://sunwc2023.github.io/blog/find-prime-number/","tags":["Java"],"title":"Java - 找1-100中所有質數"},{"categories":["Practice"],"contents":" public static void main(String[] args) { /* 內層迴圈每次執行10次 第1行(i=5) 印星號 j=5 第2行(i=4) 印星號 j=4、6 第3行(i=3) 印星號 j=3、5、7 第4行(i=2) 印星號 j=2、4、6、8 第5行(i=1) 印星號 j=1、3、5、7、9 j其餘情況印一個空白 輸出上半部： * * * * * * * * * * * * * * * */ for (int i = 5; i \u0026gt; 0; i--) { // 計算當前是第幾行，第0行即不用找下一個印星號的位置 int line = 5 - i; int nextPosition = 0; for (int j = 1; j \u0026lt; 10; j++) { // 當 內層迴圈 第一次 i == j 的時候，就先去找下一個印*號的位置 // j == nextPosition(下一個印星號的位置)，就印星號 if (line \u0026gt;= 0 \u0026amp;\u0026amp; (j == i || nextPosition == j)) { System.out.print(\u0026#34;*\u0026#34;); if (line \u0026gt; 0) { // 當印出當前星號後，就開始找到再下個印星號的位置 nextPosition = j + 2; // 當line=0，代表當前這行的星號已經印完了 line--; } } else { // 印空白 System.out.print(\u0026#34; \u0026#34;); } } // 換行 System.out.println(); } /* 內層迴圈每次執行7次 第1行(i=5) 印星號 j=8、6、4、2 第2行(i=4) 印星號 j=7、5、3 第3行(i=3) 印星號 j=6、4 第4行(i=2) 印星號 j=5 j其餘情況印一個空白 輸出下半部： * * * * * * * * * * */ for (int i = 5; i \u0026gt; 1; i--) { // 每行開頭先印一個空白 System.out.print(\u0026#34; \u0026#34;); // 計算當前是第幾行，第0行即不用找下一個印星號的位置 int line = i - 2; int nextPosition = 0; for (int j = 8; j \u0026gt; 1; j--) { // 當 內層迴圈 第一次(i+3) == j 的時候，就先去找下一個印*號的位置 // j == nextPosition(下一個印星號的位置)，就印星號 if (line \u0026gt;= 0 \u0026amp;\u0026amp; (j == (i+3) || nextPosition == j)) { System.out.print(\u0026#34;*\u0026#34;); if (line \u0026gt; 0) { // 當印出當前星號後，就開始找到再下個印星號的位置 nextPosition = j - 2; // 當line=0，代表當前這行的星號已經印完了 line--; } } else { // 印空白 System.out.print(\u0026#34; \u0026#34;); } } // 換行 System.out.println(); } } 輸出結果：\n* * * * * * * * * * * * * * * * * * * * * * * * * ","permalink":"https://sunwc2023.github.io/blog/print-diamond/","tags":["Java"],"title":"Java - 打印菱形"},{"categories":["Practice"],"contents":" 思路：越下面的 case 被執行的機率越高，因此要從最下面的 case 1 倒著累加至第一個 case 12；由於沒有 break 語句，因此進入某個 case 後，其 case 下面的所有 case 都會被執行\n判斷該年份是否為閏年標準： 可以被4整除，但不可以被100整除 可以被400整除 public static void main(String[] args) { System.out.println(\u0026#34;請輸入年份 : \u0026#34;); Scanner scanner = new Scanner(System.in); int year = scanner.nextInt(); System.out.println(\u0026#34;請輸入月份 : \u0026#34;); int month = scanner.nextInt(); System.out.println(\u0026#34;請輸入日期 : \u0026#34;); int date = scanner.nextInt(); int result = 0; switch (month) { case 12: result += 30; case 11: result += 31; case 10: result += 30; case 9: result += 31; case 8: result += 31; case 7: result += 30; case 6: result += 31; case 5: result += 30; case 4: result += 31; case 3: // 判斷是否為閏年: true:29天 false:28天 int daysOfFeb = ((year % 4 == 0 \u0026amp;\u0026amp; year % 100 != 0) || year % 400 == 0) ? 29 : 28; result += daysOfFeb; case 2: result += 31; case 1: result += date; } System.out.println(month+\u0026#34;月\u0026#34;+date+\u0026#34;日為\u0026#34;+year+\u0026#34;年的第\u0026#34;+result+\u0026#34;天\u0026#34;); } 輸出結果： 請輸入年份 : 2008 請輸入月份 : 3 請輸入日期 : 17 3月17日為2008的第77天 ","permalink":"https://sunwc2023.github.io/blog/days-of-year/","tags":["Java"],"title":"Java - Switch-case 計算X年X月X日為第X年第幾天"},{"categories":["Java"],"contents":" 原始random區間為包含0.0且不包含1.0 =\u0026gt; [0.0,1.0)\n我們可以透過公式Math.random*(b-a+1)+a 取得區間[a,b)的一個數字\npublic static void main(String[] args) { // 原始random區間為包含0.0且不包含1.0 double random = Math.random();// [0.0,1.0) // [10-99] 如何取得10-99之間的數：公式 - (b-a+1)+a int result = (int)(Math.random() * (99 - 10) + 1 + 10); System.out.println(result); // [888-999] 如何取得888-999之間的數： result = (int)(Math.random() * (999 - 888 + 1) + 888); System.out.println(result); } 陣列長度10放入隨機數[10-99]、且不重複 public static void main(String[] args) { int[] arr = new int[10]; arr[0] = (int) (Math.random() * (99 - 10 + 1) + 10); // 用來判斷隨機數是否重複 Set set = new HashSet\u0026lt;Integer\u0026gt;(); set.add(arr[0]); int max = arr[0]; int min = arr[0]; int sum = 0; int average = 0; for (int i = 1; i \u0026lt; arr.length; i++) { // 隨機數都是兩位數 int random = (int) (Math.random() * (99 - 10 + 1) + 10); if (set.contains(random)) { i--; } else { // 未重複 arr[i] = random; // 計算總和 sum += arr[i]; // 計算最大值 if (max \u0026lt; arr[i]) { max = arr[i]; } // 計算最小值 if (min \u0026gt; arr[i]) { min = arr[i]; } set.add(random); } } System.out.println(\u0026#34;min=\u0026#34;+min+\u0026#34;,max=\u0026#34;+max+\u0026#34;,average=\u0026#34;+sum/arr.length); System.out.println(Arrays.toString(arr)); } ","permalink":"https://sunwc2023.github.io/blog/math-random/","tags":["Java"],"title":"Java - Math.random 使用"},{"categories":["Practice"],"contents":"學習目標: 多型 繼承 --多型-- 撰寫一個 Human 類別 代表人 在這裡我們有兩個衍伸類別 Man 與 Woman 他們用不同的規則活著： Man : 吃飯時 印出\u0026#34;好好吃\u0026#34; 睡覺時 印出\u0026#34;zzz\u0026#34; Woman: 吃飯時 印出\u0026#34;Orzz\u0026#34; 睡覺時 印出\u0026#34;:)\u0026#34; (印出代表用System.our.println(...)) 使用者會輸入一個字串 代表 男人與女人 的順序 ( b -\u0026gt; 男 g -\u0026gt; 女 大小寫皆可) 像是: bgGGBgb 代表 男人有3位 女人有4位 照這個順序排列 (左到右) 之後照著順序印出所有人 吃飯 及 睡覺 的情況 需使用多型 沒頭緒的話就讀熟多型的章節 Example Input bgGGBgb output 輸入字串： bgGGBgb 好好吃 Orzz Orzz Orzz 好好吃 Orzz 好好吃 zzz :) :) :) zzz :) zzz 題目來源\n建立Human抽象類別 public abstract class Human { abstract String eating(); abstract String sleeping(); } 建立男人類別繼承Human class Man extends Human { @Override String eating() { return \u0026#34;好好吃\u0026#34;; } @Override String sleeping() { return \u0026#34;zzz\u0026#34;; } } 建立女人類別繼承Human class Woman extends Human { @Override String eating() { return \u0026#34;Orzz\u0026#34;; } @Override String sleeping() { return \u0026#34;:)\u0026#34;; } } 讓使用者輸入字串，最後照著字串順序印出所有人 吃飯 及 睡覺 的情況 mport java.util.LinkedList; import java.util.List; import java.util.Locale; import java.util.Scanner; public abstract class Human { abstract String eating(); abstract String sleeping(); public static void main(String[] args) { System.out.println(\u0026#34;請輸入一個字串 代表 男人與女人 的順序 ( b -\u0026gt; 男 g -\u0026gt; 女 大小寫皆可)\\n\u0026#34; + \u0026#34;像是: bgGGBgb 代表 男人有3位 女人有4位 照這個順序排列 (左到右)\u0026#34;); // 取得使用者的輸入 Scanner scanner = new Scanner(System.in); // 將取得的字串轉英文小寫 String bgString = scanner.next().toLowerCase(Locale.ROOT); printHumanRoutine(bgString); } /** * 照著順序印出所有人 吃飯 及 睡覺 的情況 * @param bgString */ public static void printHumanRoutine(String bgString) { List\u0026lt;Human\u0026gt; humanList = new LinkedList\u0026lt;\u0026gt;(); // 遍歷字串將男人或女人放入human集合 for (int i = 0; i \u0026lt; bgString.length(); i++) { String str = bgString.charAt(i) + \u0026#34;\u0026#34;; Human human = null; if (\u0026#34;b\u0026#34;.equals(str)) { human = new Man(); } else if (\u0026#34;g\u0026#34;.equals(str)) { human = new Woman(); } System.out.println(human.eating()); humanList.add(human); } for (int i = 0; i \u0026lt; humanList.size(); i++) { Human human = humanList.get(i); System.out.println(human.sleeping()); } } } 結論 最後我覺得 水球潘 對於這個範例的解釋太好了，所以我決定放在這裡讓這個觀念好好住在心裡:)\n在這邊 男人跟女人 是 具體的子類別 因為很清楚 這是男人 這是女人 所以稱為\u0026#34;具體\u0026#34; 那人類呢? 人類具體嗎? Human 你不知道他是哪種人 因此稱之為 \u0026#34;抽象\u0026#34;，抽象的類別 就不該把具體的內容打清楚 所以在定義Human的函數時 會不知道要打什麼內容 抽象類別是不可以被new的 因為他是抽象的 抽象類別 可以定義抽象方法 就是只跟程式說 人類會吃飯 會睡覺 但我不說清楚其具體內容 你必須告訴我你是哪個具體子類別 我才知道你 在睡覺跟吃飯時要做什麼 參考來源\n","permalink":"https://sunwc2023.github.io/blog/abstract-human/","tags":["Java"],"title":"Java - 多型 繼承"},{"categories":["Experience"],"contents":" 有關如何使用 ThreadLocal 確保 Thread-safety，可以參考我的另一篇文章 Java - ThreadLocal 類的使用\n筆者曾經在不了解 ThreadLocal 類的情況下，錯用 ThreadLocal 客製Log物件的工具類，後來理解 ThreadLocal 運作原理後，在這裡特別記錄下來\n客製 LogBox 類 import java.text.SimpleDateFormat; import java.util.Date; import java.util.LinkedList; import java.util.List; public class LogBox { private static final ThreadLocal\u0026lt;LogBox\u0026gt; currentThreadLogBox = new ThreadLocal\u0026lt;\u0026gt;(); private static final ThreadLocal\u0026lt;SimpleDateFormat\u0026gt; currentThreadSDF = new ThreadLocal\u0026lt;\u0026gt;(); private final String title; private final static String timeType = \u0026#34;yyyy-MM-dd HH:mm:ss.SSS\u0026#34;; private final List\u0026lt;String\u0026gt; logMsgList = new LinkedList\u0026lt;\u0026gt;(); public LogBox(String title) { this.title = title; } /** * 日誌訊息層級 */ public enum MessageType { MESSAGE, DEBUG, WARNING, ERROR } /** * 建立當前執行緒logBox * @param title * @return */ public static LogBox createCurrentThreadLogBox(String title) { LogBox logBox = new LogBox(title); currentThreadLogBox.set(logBox); return logBox; } /** * 取得當前執行緒logBox * 當某個request流程跨function時 * 則可以使用同一個logBox * @return */ public static LogBox getCurrentThreadLogBox() { if (currentThreadLogBox.get() == null) { createCurrentThreadLogBox(\u0026#34;title unset\u0026#34;); } return currentThreadLogBox.get(); } /** * 清除當前執行緒LogBox * 清除當前執行緒SimpleDateTimeFormat * 並取得log字串 * @return */ public String removeLogBoxAndGetLog() { removeCurrentThreadSDF(); currentThreadLogBox.remove(); StringBuilder sb = new StringBuilder(); if (logMsgList.size() \u0026gt; 0) { sb.append(\u0026#34;Log Title : \u0026#34;).append(title); logMsgList.forEach(eachLine -\u0026gt; { sb.append(\u0026#34;\\n\u0026#34;).append(\u0026#34;\\t\u0026#34;).append(eachLine); }); } sb.append(\u0026#34;\\n\u0026#34;).append(\u0026#34;=========================================================\u0026#34;); return sb.toString(); } /** * 簡略示意客製添加 info 層級 log 訊息 * @param msg */ public void info(String msg) { SimpleDateFormat simpleDateFormat = currentThreadSDF.get(); String now = simpleDateFormat.format(new Date()); msg = String.format(\u0026#34;[%s] \u0026#39;%s\u0026#39; %s\u0026#34;, MessageType.MESSAGE, now, msg); logMsgList.add(msg); } // 接收 debug、warn、error 等 log 訊息 function...... /** * 建立當前執行緒SimpleDateFormat * @return */ public static SimpleDateFormat createCurrentThreadSDF() { SimpleDateFormat sdf = new SimpleDateFormat(timeType); currentThreadSDF.set(sdf); return sdf; } /** * 取得當前執行緒SimpleDateFormat * @return */ public static SimpleDateFormat getCurrentThreadSDF() { if (currentThreadSDF.get() == null) { createCurrentThreadSDF(); } return currentThreadSDF.get(); } /** * 清除當前執行緒SimpleDateFormat */ public void removeCurrentThreadSDF() { currentThreadSDF.remove(); } } LogBox 類使用情境 情境一、這個 LogBox 類實際上是可以應用在 Filter interface\n透過建立一個客製類實作 Filter 並實現 doFilter 方法，一開始透過 createCurrentThreadLogBox(title) 建立屬於該 request (該執行緒) 的 ThreadLocal\u0026lt;LogBox\u0026gt; 物件，中間還可以從 request 中取得 requestURI、requestParams 並取得 response 等資訊都加入 ThreadLocal\u0026lt;LogBox\u0026gt; ，等程式從controller層回到 doFilter 再 removeLogBoxAndGetLog() 清除當前執行緒 ThreadLocal\u0026lt;LogBox\u0026gt;\n因為有上面提及的這層操作，因此在SpringBoot framework 的 Controller 或 Service 層的 function 中，就只需要getCurrentThreadLogBox() 取得當前執行緒的 LogBox，並將當前API、業務邏輯所需顯示的 log 內容，透過 log.info(\u0026quot;xxxx\u0026quot;), log.error(exeption message),\u0026hellip; 將不同層級訊息加到 LogBox 中\n圖片來源\n情境二、這個 LogBox 類實際上是可以應用在 quartz 排程\n透過建立一個客製類繼承 QuartzJobBean 並覆寫 executeInternal 方法，一開始透過 createCurrentThreadLogBox(title) 建立屬於該排程 (該執行緒) 的 ThreadLocal\u0026lt;LogBox\u0026gt; 物件；不過，此方法可能會再存取 ScheduleService 類的方法，因此在 ScheduleService 層就只需要　getCurrentThreadLogBox() 取得當前執行緒的 LogBox ，並添加業務邏輯所需顯示的 log 內容，透過 log.info(\u0026quot;xxxx\u0026quot;), log.error(exeption message),\u0026hellip; 將不同層級訊息加到 LogBox 中，等排程快結束時程式回到 executeInternal 方法，再 removeLogBoxAndGetLog() 清除當前執行緒 ThreadLocal\u0026lt;LogBox\u0026gt;\n筆者在理解 ThreadLocal 後，但是卻在下面例子的當程式走到 callTransferLimitUpPer30Mins()內部時，該 function 的 log 都印不出來；\n原來的寫法： 在 callTransferLimitUpPer30Mins() function 的內部，才 getCurrentThreadLogBox() 取得當前執行緒的 LogBox，最後才發現這個坑是跟 ExecutorService interface 有關；\n改善後的寫法： 將 LogBox 物件當作傳參送到 callTransferLimitUpPer30Mins(logBox) ，才解決了問題，請看以下例子：\n@Slf4j @DisallowConcurrentExecution public class RaiseupTransferLimitJob extends QuartzJobBean { @Autowired CancelRaiseupLimitTask cancelRaiseupLimitTask; public static final String TASK_NAME = QuartzTaskNameConstants.raiseupTransferLimt; public static final String PROP_NAME = \u0026#34;quartz.findBeforeSystemTimeLessThan1Day\u0026#34;; public RaiseupTransferLimitJob() { QuartzJobService.descriptionMap.put(TASK_NAME, \u0026#34;re-send raiseupTransferLimit\u0026#34;); QuartzJobService.taskDisplayNameMap.put(TASK_NAME, TASK_NAME); } @Override public void executeInternal(JobExecutionContext jobExecutionContext) { String logTitle = new Exception().getStackTrace()[0].getClassName()+\u0026#34;.\u0026#34;+new Exception().getStackTrace()[0].getMethodName(); LogBox logBox = LogBox.createCurrentThreadLogBox(logTitle); logBox.info(\u0026#34;start running callTransferLimitUpPer30Mins\u0026#34;); try { cancelRaiseupLimitTask.cancelTaskPer60MINS(); } catch (Exception e) { logBox.error(e); } finally { logBox.info(\u0026#34;end run callTransferLimitUpPer30Mins\u0026#34;); String logString = logBox.removeLogBoxAndGetLog(); if (logString != null \u0026amp;\u0026amp; logString.trim().length() \u0026gt; 0) { log.info(logString); } } } } public void cancelTaskPer60MINS() throws Exception { LogBox logBox = LogBox.getThreadLocalLogBox(); ExecutorService executor = Executors.newSingleThreadExecutor(); Future\u0026lt;String\u0026gt; future = executor.submit(() -\u0026gt; { // 需求是若排程有timeout情況產生，單一排程至多執行60分鐘\tcallTransferLimitUpPer30Mins(logBox); // 排程業務邏輯 logBox.info(\u0026#34;callTransferLimitUpPer30Mins is completed!\u0026#34;); return \u0026#34;Ready!\u0026#34;; }); try { logBox.info(\u0026#34;Every 60 minutes is started..\u0026#34;); // 設置最大等待時間 logBox.info(future.get(60, TimeUnit.MINUTES)); logBox.info(\u0026#34;Every 60 minutes is finished!\u0026#34;); } catch (TimeoutException e) { // 允許取消正在運行的執行緒——以拋出異常的方式中斷 future.cancel(true); logBox.info(\u0026#34;callTransferLimitUpPer30Mins is terminated!\u0026#34;); } executor.shutdownNow(); logBox.info(\u0026#34;cancelTaskPer60MINS shutdown now\u0026#34;); } 圖片參考\n關於 log 印不出來，我的想法是 原來在主執行緒的 LogBox ，與 Executors 建立的單一執行緒裡的 LogBox 彼此之間是不互相影響的；但是只有主執行緒的 LogBox 可以印出 log (因為最後有 removeLogBoxAndGetLog() )，所以我就必須將主執行緒產生出來的 LogBox 當作傳參送入 callTransferLimitUpPer30Mins(logBox)，這樣就沒問題啦！\n","permalink":"https://sunwc2023.github.io/blog/thread-local-example/","tags":["Java"],"title":"Java - ThreadLocal 實際應用"},{"categories":["Java"],"contents":" 有關在實際工作上使用到 ThreadLocal 的例子，可以參考我的另一篇文章 Java - ThreadLocal 實際應用\nThreadLocal 實現原理 ThreadLocal 從字面義直翻，就是執行緒 (Thread) 的局部變數，是每一個執行緒所單獨持有，其他執行緒不能對其進行存取\nThreadLocal 支持泛型，也就是支持 value 是可以設置的，像是 ThreadLocal\u0026lt;Integer\u0026gt; 就是設置 value 為 Integer 類型\n每個執行緒會有自己一份 ThreadLocalMap 副本，去儲存這個執行緒自己想存放的 ThreadLocal\u0026lt;T\u0026gt; 變數們，ThreadLocalMap 副本內部儲存的是一個 key-value 對，其中 key 是某個 ThreadLocal\u0026lt;T\u0026gt; 物件實例 ， value 就是這個執行緒、該 ThreadLocal\u0026lt;T\u0026gt; 物件實例 set 的值，所以對一個執行緒來說，一個 ThreadLocal\u0026lt;T\u0026gt; 只能存一個值，而一個執行緒可以存放多個 ThrealLocal\u0026lt;T\u0026gt;\npublic class Thread implements Runnable { // Thread 類裡的threadLocals 存放此執行緒的專有 ThreadLocalMap 副本 ThreadLocal.ThreadLocalMap threadLocals = null; } public class ThreadLocal\u0026lt;T\u0026gt; { // 根據執行緒，取得那個執行緒自己的 ThreadLocalMap ThreadLocalMap getMap(Thread t) { return t.threadLocals; } static class ThreadLocalMap { // ThreadLocalMap 的 key 是使用 \u0026#34;弱引用\u0026#34; 的 ThreadLocal\u0026lt;T\u0026gt; static class Entry extends WeakReference\u0026lt;ThreadLocal\u0026lt;?\u0026gt;\u0026gt; { Object value; // ThreadLocalMap 中的 key 就是 ThreadLocal\u0026lt;T\u0026gt;，value 就是設置的值 Entry(ThreadLocal\u0026lt;?\u0026gt; k, Object v) { super(k); value = v; } } } public T get() { // 取得當前執行緒 Thread t = Thread.currentThread(); // 每個執行緒 都有一個自己的 ThreadLocalMap // ThreadLocalMap 裡就保存著所有的ThreadLocal\u0026lt;T\u0026gt;變數 ThreadLocalMap map = getMap(t); if (map != null) { // ThreadLocalMap 的 key 就是當前 ThreadLocal\u0026lt;T\u0026gt; 物件實例 // 多個 ThreadLocal\u0026lt;T\u0026gt; 變數都是放在這個 map 中的 ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) // 從 map 裡取出來的值就是我們需要的這個 ThreadLocal\u0026lt;T\u0026gt; 變數 T result = (T)e.value; return result; } } // 如果 map 沒有初始化，那麼在這裡初始化一下 return setInitialValue(); } public void set(T value) { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) { map.set(this, value); } else { createMap(t, value); } } public void remove() { ThreadLocalMap map = getMap(Thread.currentThread()); if (map != null) { map.remove(this); } } } ThreadLocal 常用方法 set(x) : 設置此執行緒的想要放的值 x get() : 取得此執行緒當初存放的值，如果沒有存放過則返回 null remove() : 刪除此執行緒的 key-value 對，也就是如果先執行 remove 再執行 get，會返回 null 可以創建多個 ThreadLocal\u0026lt;T\u0026gt; 物件，對每個 ThreadLocal\u0026lt;T\u0026gt; 都設置不同的值\n像是以下的例子，在 main 執行緒中的 ThreadLocalMap ，就有兩個 key-value 的映射，userIdThreadLocal -\u0026gt; 100、userNameThreadLocal -\u0026gt; hello public class Main { public static void main(String[] args){ ThreadLocal\u0026lt;Integer\u0026gt; userIdThreadLocal = new ThreadLocal\u0026lt;\u0026gt;(); ThreadLocal\u0026lt;String\u0026gt; userNameThreacLocal = new ThreadLocal\u0026lt;\u0026gt;(); userId.set(100); userName.set(\u0026#34;hello\u0026#34;); } } ThreadLocal 存在內存洩露 這邊不多去探討這個議題，內存洩漏是可以避免的，只要當前執行緒要結束前記得即時的remove()，也就是是使得 ThreadLocalMap 中不要存在這個 key-value 對，這樣才能確保 GC 能正確回收\n以下有更多的文章，仔細地談論 ThreadLocal 內存洩漏問題 與 Java 自身解決的方式，但都不治本！還是當前執行緒用完 ThreadLocal 記得呼叫remove()，才是確保線程安全的根本之道！\n參考資料：\nJava - ThreadLocal 類的使用\nThreadLocal使用與原理\nSimpleDateFormat 非線程安全？ 由於 SimpleDateFormat 本身非 synchronized ，所以如果在不同執行緒使用同一個 SimpleDateFormat ，就會導致輸出的時間異常，請看以下的例子\npublic static void main(String[] args) { DateFormat sdf = new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); Date date1 = new Date(1614820308016L); Date date2 = new Date(1615820309016L); System.out.println(\u0026#34;初始定義時間1 : \u0026#34; + sdf.format(date1)); System.out.println(\u0026#34;初始定義時間2 : \u0026#34; + sdf.format(date2)); Thread t1 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 100; i++) { String dateStr = sdf.format(date1); if (!\u0026#34;2021-03-04 09:11:48\u0026#34;.equals(dateStr)) { System.out.println(Thread.currentThread().getName() + \u0026#34;異常時間為 : \u0026#34; + dateStr); } } }, \u0026#34;thread 1\u0026#34;); Thread t2 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 100; i++) { String dateStr = sdf.format(date2); if (!\u0026#34;2021-03-15 22:58:29\u0026#34;.equals(dateStr)) { System.out.println(Thread.currentThread().getName() + \u0026#34;異常時間為 : \u0026#34; + dateStr); } } }, \u0026#34;Thread 2\u0026#34;); t1.start(); t2.start(); try { t1.join(); t2.join(); } catch (InterruptedException e) { e.printStackTrace(); } } 輸出異常：(Thread2 輸出了 Thread1 的時間)\n初始定義時間1 : 2021-03-04 09:11:48 初始定義時間2 : 2021-03-15 22:58:29 Thread 2異常時間為 : 2021-03-04 09:11:48 但是， ThreadLocal 可以解決非線程安全的問題，只要在各自的執行緒，持有各自的ThreadLocal\u0026lt;DateFormat\u0026gt;，就不會有問題了，請看下面的例子\npublic static void main(String[] args) { DateFormat sdf = new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); Date date1 = new Date(1614820308016L); Date date2 = new Date(1615820309016L); System.out.println(\u0026#34;初始定義時間1 : \u0026#34; + sdf.format(date1)); System.out.println(\u0026#34;初始定義時間2 : \u0026#34; + sdf.format(date2)); Thread t1 = new Thread(() -\u0026gt; { ThreadLocal\u0026lt;DateFormat\u0026gt; currentSDF = new ThreadLocal\u0026lt;\u0026gt;(); DateFormat df1 = new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); currentSDF.set(df1); DateFormat dateFormat1 = currentSDF.get(); for (int i = 0; i \u0026lt; 100; i++) { String dateStr = dateFormat1.format(date1); if (!\u0026#34;2021-03-04 09:11:48\u0026#34;.equals(dateStr)) { System.out.println(Thread.currentThread().getName() + \u0026#34;異常時間為 : \u0026#34; + dateStr); } } currentSDF.remove(); }, \u0026#34;thread 1\u0026#34;); Thread t2 = new Thread(() -\u0026gt; { ThreadLocal\u0026lt;DateFormat\u0026gt; currentSDF = new ThreadLocal\u0026lt;\u0026gt;(); DateFormat df2 = new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); currentSDF.set(df2); DateFormat dateFormat2 = currentSDF.get(); for (int i = 0; i \u0026lt; 100; i++) { String dateStr = dateFormat2.format(date2); if (!\u0026#34;2021-03-15 22:58:29\u0026#34;.equals(dateStr)) { System.out.println(Thread.currentThread().getName() + \u0026#34;異常時間為 : \u0026#34; + dateStr); } } currentSDF.remove(); }, \u0026#34;Thread 2\u0026#34;); t1.start(); t2.start(); try { t1.join(); t2.join(); } catch (InterruptedException e) { e.printStackTrace(); } } 輸出正常：\n初始定義時間1 : 2021-03-04 09:11:48 初始定義時間2 : 2021-03-15 22:58:29 參考來源\n","permalink":"https://sunwc2023.github.io/blog/thread-local/","tags":["Java"],"title":"Java - ThreadLocal 類的使用"},{"categories":["Java"],"contents":" 有關的例子，可以參考我的另一篇文章 Java - 多型 繼承\nabstract\nabstract 關鍵字只可以修飾 非final 類別, 非private、非static、非final 方法 抽象類別不可以實例化，抽象類別一定有constructor，以便讓子類別實例化的時候可以進行調用 抽象方法只有方法的宣告、沒有方法體 結論：\n包含 抽象方法 的類別，一定是抽象類別；反之，抽象類別中可以無抽象方法 若子類別覆寫父類別的所有抽象方法後，此子類別可以實例化；若子類別沒有覆寫父類的所有抽象方法，則此子類別也是一個抽象類別，需要使用abstract修飾 ","permalink":"https://sunwc2023.github.io/blog/abstract/","tags":["Java"],"title":"Java - 抽象類別 抽象方法"}]