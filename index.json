[{"categories":["Java"],"contents":"Collection 框架 interface Collection：單列集合，用來儲存一個一個的物件\ninterface List：儲存有序的、可重複的資料 =\u0026gt; \u0026ldquo;動態\u0026quot;陣列，替換原有的陣列\nArrayList：作為 interface List 的主要實現類；執行緒不安全的，效率高；底層使用Object[] elementData儲存資料 LinkedList：對於頻繁地插入、刪除操作，使用此類效率比ArrayList高；底層使用雙向鏈結串列儲存資料 Vector：作為 interface List 的古老實現類；執行緒安全，效率低；底層使用Object[] elementData儲存資料 interface Set：儲存無序的、不可重複的資料\n無序性：儲存的資料在底層陣列中並非按照陣列索引的順序新增，而是根據資料的 hash code 決定的 不可重複性： HashSet：作為 interface Set 的主要實現類別；執行緒不安全的；可以儲存null值\nHashSet 新增元素的過程： 我們向 HashSet 中新增元素a，首先調用元素a的 hashCode()，計算元素a的哈希值，以此哈希值計算出在 HashSet 底層陣列中的存放位置(即為：索引位置)，判斷陣列此索引位置上是否有元素：\n若此位置上沒有其他元素，則元素a新增成功 =\u0026gt; 情況1\r若此位置上有其他元素b(或以鏈結串列形式存在多個元素)，則比較元素a與元素b的哈希值\r若哈希值不相同，則元素a新增成功 =\u0026gt; 情況2\r若哈希值相同，進而需要調用元素a所在類別的 equals()\requals() 回傳true，元素a新增失敗\requals() 回傳false，元素a新增成功 =\u0026gt; 情況3\rHashSet 底層結構： 陣列 + 鏈結串列\nLinkedHashSet：作為 HashSet 的子類；遍歷其內部資料時，可以按照新增元素的順序進行遍歷 TreeSet：可以按照新增元素的指定屬性進行排序\n面試題：ArrayList, LinkedList, Vector 三者有何不同？ 見上\n相同點：三個類都是實現了 interface List，儲存資料的特點相同：儲存有序的、可重複的資料 ","permalink":"https://sunwc2023.github.io/blog/collection/list-set/","tags":["Java"],"title":"Java - Collection - ArrayList, LinkedList, Vector"},{"categories":["Java"],"contents":"/** * @author sunwc * @create 2023-03-28 上午 09:56 */ public class CollectionTest { @Test public void testCollection() { Collection collection = new ArrayList\u0026lt;\u0026gt;(); Person person = new Person(\u0026#34;Jerry\u0026#34;, 20); collection.add(person); collection.add(123); collection.add(456); collection.add(false); collection.add(new String(\u0026#34;Tom\u0026#34;)); // 每次集合調用iterator()時都會得到一個全新的 迭代器 Iterator iterator = collection.iterator(); while (iterator.hasNext()) { // 走到next()後，指針才下移；所以如果要調remove()的話，要先調next() Object next = iterator.next(); // 刪除集合中的Tom if (\u0026#34;Tom\u0026#34;.equals(next)) { iterator.remove(); // 迭代的過程進行移除元素 } System.out.println(next); } System.out.println(collection.contains(new String(\u0026#34;Tom\u0026#34;))); // false } } class Person { private String name; private int age; public Person() { } public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { final StringBuilder sb = new StringBuilder(\u0026#34;Person{\u0026#34;); sb.append(\u0026#34;name=\u0026#39;\u0026#34;).append(name).append(\u0026#39;\\\u0026#39;\u0026#39;); sb.append(\u0026#34;, age=\u0026#34;).append(age); sb.append(\u0026#39;}\u0026#39;); return sb.toString(); } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Person person = (Person) o; return age == person.age \u0026amp;\u0026amp; Objects.equals(name, person.name); } } JDK 5.0 新增 集合Collection 的增強for迴圈特性 練習題 String[] arr = new String[]{\u0026#34;MM\u0026#34;,\u0026#34;MM\u0026#34;,\u0026#34;MM\u0026#34;}; // 方式一、直接改變arr[index]的元素值 for(int i = 0; i \u0026lt; arr.length; i++) { arr[i] = \u0026#34;GG\u0026#34;; } for(int i = 0; i \u0026lt; arr.length; i++) { System.out.print(arr[i]+\u0026#34;\\t\u0026#34;); // GG GG GG } String[] arr = new String[]{\u0026#34;MM\u0026#34;,\u0026#34;MM\u0026#34;,\u0026#34;MM\u0026#34;}; // 方式二、從arr取出值後，將值複製一份給變數str for(String str: arr) { str = \u0026#34;GG\u0026#34;; } for(int i = 0; i \u0026lt; arr.length; i++) { System.out.println(arr[i]+\u0026#34;\\t\u0026#34;); // MM MM MM } ","permalink":"https://sunwc2023.github.io/blog/collection/collection-iterator/","tags":["Java"],"title":"Java - Collection - iterator 方法"},{"categories":["Java"],"contents":"為什麼要使用列舉類？ 當我們在開發中，有一組常數對應不同的狀態來顯示時，就可以考慮使用 enum class\n方式一、自定義列舉類 /** * 自定義列舉類 * @author sunwc * @create 2023-03-27 下午 03:53 */ public class Season { // 1. 宣告Season物件的屬性：private final 修飾 private final String name; private final String desc; // 2. 私有的建構子，將屬性指定值 private Season(String name, String desc) { this.name = name; this.desc = desc; } /** * 提供列舉物件：public static final 修飾 */ public static final Season SPRING = new Season(\u0026#34;spring\u0026#34;, \u0026#34;春暖花開\u0026#34;); public static final Season SUMMER = new Season(\u0026#34;summer\u0026#34;, \u0026#34;盛夏光年\u0026#34;); public static final Season AUTUMN = new Season(\u0026#34;autumn\u0026#34;, \u0026#34;秋高氣爽\u0026#34;); public static final Season WINTER = new Season(\u0026#34;winter\u0026#34;, \u0026#34;寒風凜凜\u0026#34;); public String getName() { return name; } public String getDesc() { return desc; } @Override public String toString() { final StringBuilder sb = new StringBuilder(\u0026#34;Season{\u0026#34;); sb.append(\u0026#34;name=\u0026#39;\u0026#34;).append(name).append(\u0026#39;\\\u0026#39;\u0026#39;); sb.append(\u0026#34;, desc=\u0026#39;\u0026#34;).append(desc).append(\u0026#39;\\\u0026#39;\u0026#39;); sb.append(\u0026#39;}\u0026#39;); return sb.toString(); } } class EnumClassTest { @Test public void getEnumSeason() { System.out.println(Season.SPRING.getName()); System.out.println(Season.AUTUMN.getDesc()); System.out.println(Season.WINTER.toString()); } } 方式二、使用 enum 關鍵字定義 列舉類 定義的列舉類 默認繼承於 java.lang.Enum\n常用方法\n1.values()\n2.valueOf()\n3.toString()\nenum 列舉類可以 implements interface\n/** * 使用enum關鍵字定義列舉類 * @author sunwc * @create 2023-03-27 下午 03:53 */ public enum Season1 implements Info { /** * 提供列舉物件 */ SPRING(\u0026#34;spring\u0026#34;, \u0026#34;春暖花開\u0026#34;) { @Override public void show() { System.out.println(\u0026#34;這是有關春天的訊息\u0026#34;); } }, SUMMER(\u0026#34;summer\u0026#34;, \u0026#34;盛夏光年\u0026#34;) { @Override public void show() { System.out.println(\u0026#34;這是有關夏天的訊息\u0026#34;); } }, AUTUMN(\u0026#34;autumn\u0026#34;, \u0026#34;秋高氣爽\u0026#34;) { @Override public void show() { System.out.println(\u0026#34;這是有關秋天的訊息\u0026#34;); } }, WINTER(\u0026#34;winter\u0026#34;, \u0026#34;寒風凜凜\u0026#34;) { @Override public void show() { System.out.println(\u0026#34;這是有關冬天的訊息\u0026#34;); } }; // 宣告Season1物件的屬性：private final 修飾 private final String name; private final String desc; // 2. 私有的建構子，將屬性指定值 private Season1(String name, String desc) { this.name = name; this.desc = desc; } public String getName() { return name; } public String getDesc() { return desc; } } class EnumKeywordTest { @Test public void getEnumSeason1() { System.out.println(Season1.class.getSuperclass()); // class java.lang.Enum System.out.println(Season1.SPRING.getName()); System.out.println(Season1.AUTUMN.getDesc()); System.out.println(Season1.WINTER); // 遍歷所有列舉物件並調用interface抽象方法 show() for (int i = 0; i \u0026lt; Season1.values().length; i++) { Season1.values()[i].show(); } } } /** * 自定義 interface */ interface Info { void show(); } 輸出結果：\nclass java.lang.Enum spring 秋高氣爽 WINTER 這是有關春天的訊息 這是有關夏天的訊息 這是有關秋天的訊息 這是有關冬天的訊息 ","permalink":"https://sunwc2023.github.io/blog/enum/enum-class/","tags":["Java"],"title":"Java - enum class"},{"categories":["Java"],"contents":"interface java.lang.Comparable override compartTo() 自然排序 override compareTo(obj) 的規則： 如果當前物件this大於傳入物件obj，則回傳正整數 如果當前物件this小於傳入物件obj，則回傳負整數 如果當前物件this等於傳入物件obj，則回傳0 實現 interface Comparable 的有String, wrapper class, java.util.Date等類別，也因為如此它們都可以進行排序 public class Date implements java.io.Serializable, Cloneable, Comparable\u0026lt;Date\u0026gt; { } Date date1 = new Date(2023-1900, 3-1,27); Date date2 = new Date(2023-1900, 8-1,27); System.out.println(date2.compareTo(date1)); // 1 自定義類 implements Comparable override compareTo() 進行物件排序 /** * 商品類 * @author sunwc * @create 2023-03-27 上午 11:27 */ public class Goods implements Comparable { private String name; private int price; public Goods(String name, int price) { this.name = name; this.price = price; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getPrice() { return price; } public void setPrice(int price) { this.price = price; } @Override public String toString() { final StringBuilder sb = new StringBuilder(\u0026#34;Goods{\u0026#34;); sb.append(\u0026#34;name=\u0026#39;\u0026#34;).append(name).append(\u0026#39;\\\u0026#39;\u0026#39;); sb.append(\u0026#34;, price=\u0026#34;).append(price); sb.append(\u0026#39;}\u0026#39;); return sb.toString(); } /** * 指定商品比較大小的方式：按照價格從低到高排序 * @param o * @return */ @Override public int compareTo(Object o) { if (o instanceof Goods) { Goods goods = (Goods) o; // 方式一 if (this.price \u0026gt; goods.price) { return 1; } else if (this.price \u0026lt; goods.price) { return -1; } else { // return 0; // 價格相同的還可以再用名稱作為排序條件 return this.name.compareTo(goods.name); } // 方式二 // return Double.compare(this.price, goods.price); } throw new RuntimeException(\u0026#34;傳入的資料型態不符\u0026#34;); } } /** * 商品排序測試類 */ class GoodsTest { @Test public void comparableTest() { Goods[] manyMouse = new Goods[6]; manyMouse[0] = new Goods(\u0026#34;microsoft\u0026#34;, 600); manyMouse[1] = new Goods(\u0026#34;lenovo\u0026#34;, 400); manyMouse[2] = new Goods(\u0026#34;logitech\u0026#34;, 800); manyMouse[3] = new Goods(\u0026#34;steelseries\u0026#34;, 500); manyMouse[4] = new Goods(\u0026#34;kinyo\u0026#34;, 500); manyMouse[5] = new Goods(\u0026#34;cherry\u0026#34;, 500); // 若要使用Arrays.sort()對自定義物件陣列進行小到大排序，自定義類別要先覆寫 compareTo方法 Arrays.sort(manyMouse); System.out.println(Arrays.toString(manyMouse)); } } 自定義物件排序後 輸出結果\n[Goods{name=\u0026#39;lenovo\u0026#39;, price=400}, Goods{name=\u0026#39;cherry\u0026#39;, price=500}, Goods{name=\u0026#39;kinyo\u0026#39;, price=500}, Goods{name=\u0026#39;steelseries\u0026#39;, price=500}, Goods{name=\u0026#39;microsoft\u0026#39;, price=600}, Goods{name=\u0026#39;logitech\u0026#39;, price=800}] interface java.util.Comparator 定制排序 使用匿名實現類 override compare()\noverride compare(Object obj1, Object obj2) 的規則，比較obj1和obj2大小： 如果obj1大於obj2，則回傳正整數 如果obj1小於obj2，則回傳負整數 如果obj1等於obj2，則回傳0 @Test public void comparatorTest() { Goods[] manyMouse = new Goods[6]; manyMouse[0] = new Goods(\u0026#34;microsoft\u0026#34;, 600); manyMouse[1] = new Goods(\u0026#34;lenovo\u0026#34;, 400); manyMouse[2] = new Goods(\u0026#34;logitech\u0026#34;, 800); manyMouse[3] = new Goods(\u0026#34;steelseries\u0026#34;, 500); manyMouse[4] = new Goods(\u0026#34;kinyo\u0026#34;, 500); manyMouse[5] = new Goods(\u0026#34;cherry\u0026#34;, 500); // 若要使用Arrays.sort()對自定義物件陣列進行大到小排序，匿名實現類別要先覆寫 compare方法 // 條件：先按照產品名稱從低到高、再按照價格從高到低 Arrays.sort(manyMouse, new Comparator\u0026lt;Goods\u0026gt;() { @Override public int compare(Goods o1, Goods o2) { String s1 = String.valueOf(o1.getName().charAt(0)); String s2 = String.valueOf(o2.getName().charAt(0)); // name first character 相同 if (s1.equals(s2)) { // 價格從高到低(compare()原邏輯從低到高，所以要加負號變相反) return -Integer.compare(o1.getPrice(), o2.getPrice()); } else { // name first character 不同 // 名稱從低到高(compareTo()默認從低到高) return o1.getName().compareTo(o2.getName()); } } }); System.out.println(Arrays.toString(manyMouse)); } 定制排序後 輸出結果：\n[Goods{name=\u0026#39;cherry\u0026#39;, price=500}, Goods{name=\u0026#39;kinyo\u0026#39;, price=500}, Goods{name=\u0026#39;logitech\u0026#39;, price=800}, Goods{name=\u0026#39;lenovo\u0026#39;, price=400}, Goods{name=\u0026#39;microsoft\u0026#39;, price=600}, Goods{name=\u0026#39;steelseries\u0026#39;, price=500}] 總結 interface Comparable vs. interface Comparator\nComparable 的實現類別在任何位置都可以比較大小； Comparator 的 匿名實現類是屬於臨時性的比較\n","permalink":"https://sunwc2023.github.io/blog/compare/comparator-comparable/","tags":["Java"],"title":"Java - interface Comparator vs. interface Comparable"},{"categories":["Java"],"contents":"String：不可變的 CharSequence\nStringBuffer：可變的 CharSequence、且thread-safety，所以效率較低\nStringBuilder：可變的 CharSequence、非thread-safety，所以效率較高\n執行效率：StringBuilder \u0026gt; StringBuffer \u0026gt; String\nJDK source code 分析 String str = new String(); // new char[0]; String str1 = new String(\u0026#34;abc\u0026#34;); // new char[]{\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;}; // 底層創建了一個空間16的陣列 StringBuffer sb1 = new StringBuffer(); // new char[16]; sb1.append(\u0026#39;a\u0026#39;); // value[0] = \u0026#39;a\u0026#39;; sb1.append(\u0026#39;b\u0026#39;); // value[1] = \u0026#39;b\u0026#39;; StringBuffer sb2 = new StringBuffer(\u0026#34;abc\u0026#34;); // char[] value = new char[\u0026#34;abc\u0026#34;.length()+16]; // 問題1 System.out.println(sb2.length()); // 3 =\u0026gt; 實際裝入陣列的長度 // 問題2 擴容問題：若要新增的資料底層的陣列盛不下了，那就需要擴容底層的陣列，默認情況下，擴容為原來容量的2倍再加2，同時將原有陣列中的元素複製到新的陣列中 // 開發中建議使用：StringBuffer(int capacity) 或 StringBuilder(int capacity)，避免一開始就擴容 StringBuffer, StringBuilder 常見方法 總結 增 append(xxx);\r刪 delete(int start, int end)\r改 setChar(int index, char ch)/ replace(int start, int end, String str)\r查 charAt(int index)\r插入 insert(int offset, xxx)\r長度 length()\r遍歷 for loop + charAt()\r","permalink":"https://sunwc2023.github.io/blog/string/string-buffer/","tags":["Java"],"title":"Java - StringBuffer, StringBuilder"},{"categories":["Java"],"contents":"JDK 8 以前日期時間API java.lang.System.currentTimeMillis()：回傳(long值)當前時間與1970年1月1日0時0分0秒之間以毫秒為單位的時間差(時間戳)\nUTC 統一標準時間 GMT 格林威治標準時間 CST 中央標準時間 java.util.Date\njava.sql.Date // 1. toString()：顯示當前的年、月、日、時、分、秒 // 2. getTime()：取得當前Date物件對應的毫秒數(時間戳) // 3.當前時間Date物件 Date date = new Date(); System.out.println(date.toString()); // Sun Mar 26 21:13:32 GMT+08:00 2023 System.out.println(date.getTime()); // 1679836437117 // 4. 指定毫秒數Date物件 Date date2 = new Date(1679836437117L); // Sun Mar 26 21:13:57 GMT+08:00 2023 // 5. 如何將java.sql.Date, java.util.Date 互轉 // java.sql.Date 轉 java.util.Date(子轉父) Date date3 = new java.sql.Date(1679836437117L); System.out.println(date3.toString()); // 2023-03-26 // java.util.Date 轉 java.sql.Date(父轉子) java.sql.Date date4 = new java.sql.Date(date3.getTime()); System.out.println(date4.toString()); // 2023-03-26 java.text.SimpleDateFormat：對Date類的格式化和解析 SimpleDateFormat sdf = new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); // 格式化：日期 -\u0026gt; 字串 System.out.println(sdf.format(new Date())); // 2023-03-26 21:46:26 // 解析：字串 -\u0026gt; 日期 Date parse = null; try { parse = sdf.parse(\u0026#34;2023-03-26 21:46:26\u0026#34;); } catch (ParseException e) { e.printStackTrace(); } if (parse != null) { System.out.println(parse.toString()); // Sun Mar 26 21:46:26 GMT+08:00 2023 } java.util.Calendar(抽象類)\n常用方法：\nget() set() add() getTime() setTime() 注意：\n取得月份時，一月是0、二月是1，以此類推\u0026hellip;十二月是11 取得星期時，週日是1、週一是2，以此類推\u0026hellip;週六是7 // Date 偏移量 YEAR從1900開始、月從0開始 Date date = new Date(2023-1900, 3-1, 27); System.out.println(date); // 方式一、創建其子類(GregorianCalendar)的物件 // 方式二、調用其靜態方法 getInstance() Calendar calendar = Calendar.getInstance(); System.out.println(calendar.getClass()); // class java.util.GregorianCalendar // get() int days = calendar.get(Calendar.DAY_OF_MONTH); System.out.println(days); // 這個月的第幾天 System.out.println(calendar.get(Calendar.DAY_OF_YEAR)); // 這個年的第幾天 // add() calendar.add(Calendar.DAY_OF_YEAR, -3); days = calendar.get(Calendar.DAY_OF_YEAR); System.out.println(days); // 這個年的第幾天 // getTime() Date date = calendar.getTime(); System.out.println(date); // Mon Mar 27 09:42:12 GMT+08:00 2023 // setTime() Date date1 = new Date(); calendar.setTime(date1); System.out.println(calendar.get(Calendar.DAY_OF_YEAR)); // 這個年的第幾天 練習 // 字串\u0026#34;2020-09-08\u0026#34; 轉換為 java.sql.Date SimpleDateFormat sdf = new SimpleDateFormat(\u0026#34;yyyy-MM-dd\u0026#34;); Date date = sdf.parse(\u0026#34;2020-09-08\u0026#34;); java.sql.Date date1 = new java.sql.Date(date.getTime()); System.out.println(date1);// 2020-09-08 JDK 8 以後日期時間API LocalDate LocalTime LocalDateTime @Test public void LocalDateTest() { // now() 取得當前日期、時間、日期+時間 LocalDate localDate = LocalDate.now(); LocalTime localTime = LocalTime.now(); LocalDateTime localDateTime = LocalDateTime.now(); // of() 設置指定的年、月、時、分、秒。沒有偏移量 LocalDateTime localDateTime1 = localDateTime.of(2023, 3, 27, 10, 13, 0); System.out.println(localDateTime1);// 2023-03-27T10:13 // getXxx() 取得相關屬性 System.out.println(localDateTime1.getDayOfMonth()); System.out.println(localDateTime1.getDayOfWeek()); System.out.println(localDateTime1.getMonth()); System.out.println(localDateTime1.getMonthValue()); System.out.println(localDateTime1.getMinute()); // LocalDate 不可變性 // withXxx() 設置相關屬性 LocalDate localDate1 = localDate.withDayOfMonth(31); System.out.println(localDate); // 2023-03-27 System.out.println(localDate1); // 2023-03-31 // LocalDateTime 不可變性 LocalDateTime localDateTime2 = localDateTime.withHour(12); System.out.println(localDateTime); // 2023-03-27T10:22:58.529 System.out.println(localDateTime2); // 2023-03-27T12:22:58.529 // plusXxx() LocalDateTime localDateTime3 = localDateTime.plusMonths(3); System.out.println(localDateTime); // 2023-03-27T10:24:37.844 System.out.println(localDateTime3); // 2023-06-27T10:24:37.844 // minusXxx() LocalDateTime localDateTime4 = localDateTime.minusDays(6); System.out.println(localDateTime); // 2023-03-27T10:25:47.916 System.out.println(localDateTime4); // 2023-03-21T10:25:47.916 } java.time.Instant @Test public void instantTest() { // now() 取得本初子午線對應的標準時間 Instant now = Instant.now(); // 考慮時區問題 UTC+8 小時 OffsetDateTime offsetDateTime = now.atOffset(ZoneOffset.ofHours(8)); System.out.println(offsetDateTime); // 2023-03-27T10:38:16.822+08:00 // 直接指定台灣台北時區 ZonedDateTime zonedDateTime = now.atZone(ZoneId.of(\u0026#34;Asia/Taipei\u0026#34;)); System.out.println(zonedDateTime.toLocalDateTime()); // 2023-03-27T10:43:59.249 // toEpochMills()：取得自1970年1月1日0時0分0秒(UTC)開始的毫秒數 long milli = now.toEpochMilli(); System.out.println(milli); // 1679885289697 // ofEpochMilli()：通過指定的毫秒數，取得Instant實例 Instant instant = Instant.ofEpochMilli(1679885289697L); OffsetDateTime offsetDateTime1 = instant.atOffset(ZoneOffset.ofHours(8)); System.out.println(offsetDateTime1); // 2023-03-27T10:48:09.697+08:00 ZonedDateTime zonedDateTime1 = instant.atZone(ZoneId.of(\u0026#34;Asia/Taipei\u0026#34;)); System.out.println(zonedDateTime1.toLocalDateTime()); // 2023-03-27T10:48:09.697 } ","permalink":"https://sunwc2023.github.io/blog/datetime/datetime-api/","tags":["Java"],"title":"Java - 時間相關API"},{"categories":["Java"],"contents":"例子 /** * String 代表不可變的CharSequence，簡稱不可變性 * @author sunwc * @create 2023-03-25 下午 02:51 */ public class StringTest { private String str = new String(\u0026#34;good\u0026#34;); private char[] ch = {\u0026#39;t\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;s\u0026#39;,\u0026#39;t\u0026#39;}; private void change(String str, char[] ch) { str = \u0026#34;test ok\u0026#34;; ch[0] = \u0026#39;b\u0026#39;; } public static void main(String[] args) { StringTest stringTest = new StringTest(); stringTest.change(stringTest.str, stringTest.ch); System.out.println(stringTest.str); // good System.out.println(stringTest.ch); // best } } 以圖解釋main()執行時，記憶體分配資源的示意圖 幫助理解為什麼String 是不可變的 String 常見面試題 第一題 取得兩個字串中最大相同子串。例如str1 = \u0026quot;abcwerthelloyuiodef\u0026quot;, str2 = \u0026quot;cvhellobnm\u0026quot;;\r提示：將較短的字串在每一輪時總長度--，並在這個長度下得出不同組合，\r例如 str2 = \u0026quot;cvhellobnm\u0026quot; 第一輪會變成 =\u0026gt; cvhellobnm =\u0026gt; str1進行比較；\r第二輪會變成 cvhellobn 與 vhellobnm =\u0026gt; str1進行比較；\r第三輪會變成 cvhellob 與 vhellobn 與 hellobnm =\u0026gt; str1進行比較；...以此類推 /** * @author sunwc * @create 2023-03-26 下午 01:08 */ public class StringDemo { @Test public void getLongestSubString() { String str1 = \u0026#34;abcwerthelloyuiodef\u0026#34;, str2 = \u0026#34;cvhellobnm\u0026#34;; // 1.定義較長與較短字串 String maxString = str1.length() \u0026gt; str2.length() ? str1 : str2; String minString = str1.length() \u0026lt; str2.length() ? str1 : str2; // 2.定義較短字串長度 int minLength = minString.length(); /** * 先假設minString = abcdefg * 第一輪 i = 0, substring(0, minLength) =\u0026gt; abcdefg; * 第二輪 i = 1, substring(0, minLength - 1) =\u0026gt; abcdef, * substring(1, minLength) =\u0026gt; bcdefg; * 第三輪 i = 2, substring(0, minLength - 2) =\u0026gt; abcde, * substring(1, minLength -1) =\u0026gt; bcdef, * substring(2, minLength) =\u0026gt; cdefg * 以此類推...... */ back:{ for (int i = 0; i \u0026lt; minLength; i++) { for (int start = 0, end = minLength - i; end \u0026lt;= minLength; start++, end++) { // 3. 取得此輪固定長度下的不同組合subString String subString = minString.substring(start, end); // 4. 判斷較長字串是否包含minString的substring if (maxString.contains(subString)) { System.out.println(\u0026#34;找到longest substring為：\u0026#34; + subString); // 直接挑出外層迴圈 break back; } } } } } } 輸出結果：\n找到longest substring為：hello 參考來源\n第二題 取得一個字串在另一個字串中出現的次數，例如：取得\u0026quot;ab\u0026quot;在\u0026quot;abkkcadkabkebfkabkskab\u0026quot;中出現的次數\r@Test public void duplicateString() { String minString = \u0026#34;ab\u0026#34;; String maxString = \u0026#34;abkkcadkabkebfkabkskab\u0026#34;; int count = 0; for (int i = 0; i \u0026lt; maxString.length();) { // 不是-1代表有找到 if (maxString.indexOf(minString) != -1) { count++; // startIndex後移minString.length()位 maxString = maxString.substring(i += minString.length()); } else { // startIndex後移1位 maxString = maxString.substring(++i); } } System.out.println(\u0026#34;字串在另一個字串中出現的次數為：\u0026#34; + count); } 輸出結果：\n字串在另一個字串中出現的次數為：4 第三題 對字串String str1 = \u0026ldquo;abcwerthelloyuiodef\u0026quot;中的字符進行自然順序排序\n提示\n1.字串變成char array\n2.對陣列排序(選擇排序、氣泡排序、Arrays.sort())\n3.將排序後的陣列變成字串\n@Test public void orderStringAlphabetical() { String str1 = \u0026#34;abcwerthelloyuiodef\u0026#34;; char[] chars = str1.toCharArray(); for (int i = 0; i \u0026lt; chars.length; i++) { for (int j = i+1; j \u0026lt; chars.length; j++) { if (chars[i] \u0026gt; chars[j]) { // swap char temp = chars[i]; chars[i] = chars[j]; chars[j] = temp; } } } System.out.println(chars); } 輸出結果：\nabcdeeefhilloortuwy 參考來源 Sort String Characters In Alphabetical Order\n","permalink":"https://sunwc2023.github.io/blog/string/unchangeable-string/","tags":["Java"],"title":"Java - String 不可變的"},{"categories":["Java"],"contents":"Thread Pool 特性 背景：經常創建和銷毀、使用量特別大的資源，例如併發情況下的執行緒，對效能影響很大 思路：提前創建 Multi thread，放入 Thread Pool中，使用時直接取得，使用完後放回池中。可以避免頻繁創建與銷毀、實現重複利用。類似生活中大眾交通工具 好處： 提高響應速度(減少了創建新 Thread 的時間) 降低資源消耗(重複利用Thread Pool中的Thread，不需要每次都創建) 便於 Thread 管理 corePoolSize: 核心池的大小 maximumPoolSize: 最大 Thread 數 keepAliveTime: Thread 在沒有任務時最多保持多長時間後會終止 Thread Pool 相關 API JDK 5.0 起提供了 Thread Pool 相關 API: ExecutorService和 Executors interface ExecutorService：它的常見子類別 ThreadPoolExecutor void execute(Runnable command)：執行任務/ 命令，沒有回傳值，一般用來執行 Runnable Future submit(Callable task)：執行任務，有回傳值，一般用來執行 Callable void shutdown()：關閉 Thread Pool interface Executor：工具類、Thread Pool 的工廠類，用於創建並回傳不同類型的 Thread Pool Executors.newCachedThreadPool()：創建一個可根據需要創建新 Thread的 Thread Pool Executors.newFixedThreadPool(n)：創建一個可重用固定 Thread 數的 Thread Pool Executors.newSingleThreadPool()：創建一個只有一個 Thread 的 Thread Pool Executors.newScheduledThreadPool(n)：創建一個 Thread Pool，它可以安排在給定延遲後 執行命令 或者 定期地執行 使用 Thread Pool 實現 Multi-threading 步驟 1.提供指定 Thread 數的 Thread Pool\n2.執行指定的 Thread，需要提供Runnable 或 Callable 的實現類別物件\n3.關閉 Thread Pool\n例子 /** * @author sunwc * @create 2023-03-25 上午 10:22 */ public class ThreadPool { public static void main(String[] args) { ExecutorService executorService = Executors.newFixedThreadPool(10); // 設置Thread Pool 屬性 // 1. 透過 interface ExecutorService.getClass() 取得它的實現類別 System.out.println(executorService.getClass());// java.util.concurrent.ThreadPoolExecutor // 2. 取得實現類ThreadPoolExecutor後，就可以更改Thread Pool 屬性了 ThreadPoolExecutor threadPoolExecutor = (ThreadPoolExecutor) executorService; threadPoolExecutor.setCorePoolSize(15); // 適合使用於Runnable executorService.execute(new EvenNumThread()); // 適合使用於Callable executorService.submit(new OddNumThread()); // 關閉 Thread Pool executorService.shutdown(); } } /** * 輸出1-25間的偶數 */ class EvenNumThread implements Runnable { @Override public void run() { Thread.currentThread().setName(\u0026#34;偶數執行緒\u0026#34;); for (int i = 1; i \u0026lt;= 25; i++) { if (i % 2 == 0) { System.out.println(Thread.currentThread().getName() + \u0026#34;:\u0026#34; + i); } } } } /** * 輸出1-25間的奇數 */ class OddNumThread implements Callable { @Override public Object call() throws Exception { Thread.currentThread().setName(\u0026#34;奇數執行緒\u0026#34;); for (int i = 1; i \u0026lt;= 25; i++) { if (i % 2 != 0) { System.out.println(Thread.currentThread().getName() + \u0026#34;:\u0026#34; + i); } } return null; } } 輸出結果：\nclass java.util.concurrent.ThreadPoolExecutor 偶數執行緒:2 偶數執行緒:4 偶數執行緒:6 偶數執行緒:8 偶數執行緒:10 偶數執行緒:12 偶數執行緒:14 偶數執行緒:16 偶數執行緒:18 偶數執行緒:20 偶數執行緒:22 偶數執行緒:24 奇數執行緒:1 奇數執行緒:3 奇數執行緒:5 奇數執行緒:7 奇數執行緒:9 奇數執行緒:11 奇數執行緒:13 奇數執行緒:15 奇數執行緒:17 奇數執行緒:19 奇數執行緒:21 奇數執行緒:23 奇數執行緒:25 總結 如何創建 Thread 相關的概念，不知不覺寫了好幾篇文章，雖然實際開發中，通常不會自己建，只要使用框架幫我們寫好的就可以了；但是有了 Thread 底層的基礎觀念，使用起來也比較確定用法是正確的 :)\n在把這個系列的文章集合起來：\n有關創建多執行緒 (Multi-threading) 的方式 - 繼承 Thread 類，可以參考我的另一篇文章 Java - Thread 執行緒(一)\n有關創建多執行緒的方式 - 實現 interface Runnable，可以參考我的另一篇文章 Java - Thread 執行緒(二) - interface Runnable\n有關創建多執行緒的方式 - 實現 interface Runnable，可以參考我的另一篇文章 Java - Thread 執行緒(三) - interface Callable\n","permalink":"https://sunwc2023.github.io/blog/thread/thread-pool/","tags":["Java"],"title":"Java -  Thread 執行緒(四) Thread Pool"},{"categories":["Java"],"contents":"JDK 5.0 新增\n新執行緒的創建 (Multi-threading) - 實現 interface Callable 之步驟 1.創建一個實現了 interface Callable 的類別\n2.實現類去實現 Callable 的抽象方法： call()，將此執行緒需要執行的程式寫在這裡\n3.創建實現類的物件\n4.將此物件作為參數傳遞到 FutureTask\u0026lt;T\u0026gt; 類的建構子(constructor)中\n5.將FutureTask\u0026lt;T\u0026gt;物件作為參數傳遞到 Thread 類的建構子(constructor)中並調用 start()\n6.取得 Callable 中 call()的回傳值\ninterface Callable vs. interface Runnable 的好處 call() 有回傳值 call() 可以拋出例外，被外面的操作捕獲，取得例外的訊息 Callable 支持泛型 例子 /** * 1-100之間求偶數之和 * @author sunwc * @create 2023-03-24 下午 08:46 */ public class EvenAmount { public static void main(String[] args) { NumberThread numberThread = new NumberThread(); FutureTask futureTask = new FutureTask(numberThread); new Thread(futureTask).start(); try { // get() 即為調用call() 的回傳值 Object sum = futureTask.get(); System.out.println(\u0026#34;偶數之和：\u0026#34; + sum); } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } } } class NumberThread implements Callable { @Override public Object call() throws Exception { int sum = 0; for (int i = 1; i \u0026lt;= 100 ; i++) { if (i % 2 == 0) { sum += i; } } return sum; } } 輸出結果：\n偶數之和：2550 延伸學習：有關透過 Thread Pool 達成 Multi-threading，可以參考我的另一篇文章 Java - Thread 執行緒(四) Thread Pool\n","permalink":"https://sunwc2023.github.io/blog/thread/implements-callable/","tags":["Java"],"title":"Java - Thread 執行緒(三) - interface Callable"},{"categories":["Practice"],"contents":"題目 生產者(Producer)將產品將給店員(Clerk)，而消費者(Consumer)從店員出取走商品，店員一次只能持有固定數量的產品(例如:20)，如果生產者試圖生產更多的產品，店員會較生產者暫停一下，如果店中有空位可以放產品了在通知生產者繼續生產；如果店中沒有產品了，店員會告知消費者等一下，如果店中有產品了再通知消費者來取走產品\n/** * @author sunwc * @create 2023-03-24 下午 03:49 */ public class ConcurrentProduct { public static void main(String[] args) { // 共享資源 Clerk clerk = new Clerk(); // 第一個生產者 Producer producer1 = new Producer(clerk); // 第一個消費者 Consumer consumer1 = new Consumer(clerk); Consumer consumer2 = new Consumer(clerk); producer1.setName(\u0026#34;生產者1\u0026#34;); consumer1.setName(\u0026#34;消費者1\u0026#34;); consumer1.setPriority(Thread.MAX_PRIORITY); consumer2.setName(\u0026#34;消費者2\u0026#34;); producer1.start(); consumer1.start(); consumer2.start(); } } /** * 店員類 */ class Clerk { private int prodouctAmount = 0; /** * 店員幫忙生產 */ synchronized public void doProduction() { if (this.prodouctAmount \u0026lt; 20) { this.prodouctAmount++; System.out.println(Thread.currentThread().getName() +\u0026#34;: 生產第 \u0026#34;+ prodouctAmount + \u0026#34;個產品\u0026#34;); try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } // 生產者生產一個產品，就可以喚醒消費者去消費商品了 this.notify(); } else { try { // 產品量夠了，休息一下 this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } /** * 店員幫忙銷售 */ synchronized public void doVending() { if (this.prodouctAmount \u0026gt; 0) { System.out.println(Thread.currentThread().getName()+\u0026#34;: 銷售第 \u0026#34;+ prodouctAmount + \u0026#34;個商品\u0026#34;); this.prodouctAmount--; try { Thread.sleep(200); } catch (InterruptedException e) { e.printStackTrace(); } // 消費者買了一個商品後，就可以喚醒生產者去生產了 this.notify(); } else { try { // 商品沒了，等等再來買哦~ this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } } /** * 生產者類 */ class Producer extends Thread { // 共享資源 private Clerk clerk; public Producer(Clerk clerk) { this.clerk = clerk; } @Override public void run() { while (true) { clerk.doProduction(); } } } /** * 消費者類 */ class Consumer extends Thread { // 共享資源 private Clerk clerk; public Consumer (Clerk clerk) { this.clerk = clerk; } @Override public void run() { while (true) { clerk.doVending(); } } } 輸出結果：\n生產者1: 生產第 1個產品 生產者1: 生產第 2個產品 生產者1: 生產第 3個產品 生產者1: 生產第 4個產品 生產者1: 生產第 5個產品 生產者1: 生產第 6個產品 生產者1: 生產第 7個產品 生產者1: 生產第 8個產品 生產者1: 生產第 9個產品 生產者1: 生產第 10個產品 生產者1: 生產第 11個產品 生產者1: 生產第 12個產品 生產者1: 生產第 13個產品 生產者1: 生產第 14個產品 生產者1: 生產第 15個產品 生產者1: 生產第 16個產品 生產者1: 生產第 17個產品 生產者1: 生產第 18個產品 生產者1: 生產第 19個產品 生產者1: 生產第 20個產品 消費者2: 銷售第 20個商品 消費者2: 銷售第 19個商品 消費者2: 銷售第 18個商品 消費者2: 銷售第 17個商品 消費者2: 銷售第 16個商品 消費者2: 銷售第 15個商品 消費者2: 銷售第 14個商品 消費者1: 銷售第 13個商品 消費者1: 銷售第 12個商品 消費者1: 銷售第 11個商品 消費者1: 銷售第 10個商品 消費者1: 銷售第 9個商品 消費者1: 銷售第 8個商品 消費者1: 銷售第 7個商品 消費者1: 銷售第 6個商品 消費者1: 銷售第 5個商品 消費者1: 銷售第 4個商品 消費者1: 銷售第 3個商品 消費者1: 銷售第 2個商品 消費者1: 銷售第 1個商品 生產者1: 生產第 1個產品 消費者1: 銷售第 1個商品 生產者1: 生產第 1個產品 生產者1: 生產第 2個產品 生產者1: 生產第 3個產品 消費者1: 銷售第 3個商品 消費者1: 銷售第 2個商品 消費者1: 銷售第 1個商品 生產者1: 生產第 1個產品 生產者1: 生產第 2個產品 消費者1: 銷售第 2個商品 消費者1: 銷售第 1個商品 生產者1: 生產第 1個產品 生產者1: 生產第 2個產品 生產者1: 生產第 3個產品 消費者1: 銷售第 3個商品 消費者1: 銷售第 2個商品 消費者1: 銷售第 1個商品 生產者1: 生產第 1個產品 消費者1: 銷售第 1個商品 生產者1: 生產第 1個產品 生產者1: 生產第 2個產品 生產者1: 生產第 3個產品 生產者1: 生產第 4個產品 消費者1: 銷售第 4個商品 消費者1: 銷售第 3個商品 消費者1: 銷售第 2個商品 ....... ","permalink":"https://sunwc2023.github.io/blog/thread/concurrent-product/","tags":["Java"],"title":"Java - 多執行緒 通訊"},{"categories":["Java"],"contents":"執行緒通訊 Multi-threading 中 如何讓執行緒可以交互執行 會涉及到三個方法：\njava.lang.Object.wait()：一但執行此方法，當前執行緒就會進入阻塞狀態，並釋放同步鎖 java.lang.Object.notify()：一但執行此方法，就會喚醒正在wait()中的執行緒。如果有多個執行緒wait()中，就先喚醒優先級較高的 java.lang.Object.notifyAll()：一但執行此方法，就會喚醒所有wait()中的執行緒 wait(),notify(),notifyAll()使用前提 這三個方法只能使用在synchronized修飾的區塊 或 同步方法中 這三個方法的調用者必須是同步鎖this；若調用此三個方法的物件與同步鎖不一致，會出現IllegalMonitorStateException 例子 /** * @author sunwc * @create 2023-03-24 下午 03:02 */ public class PrintNumberInteraction { public static void main(String[] args) { Number number = new Number(); Thread t1 = new Thread(number); Thread t2 = new Thread(number); t1.setName(\u0026#34;thread 1\u0026#34;); t2.setName(\u0026#34;thread 2\u0026#34;); t1.start(); t2.start(); } } class Number implements Runnable { private int number = 1; @Override public void run() { while (number \u0026lt;= 50) { synchronized (this) { // 喚醒阻塞中的執行緒 this.notify(); if (number \u0026lt;= 50) { System.out.println(Thread.currentThread().getName() + \u0026#34;: number - \u0026#34; + number); number++; } try { // 當前執行緒阻塞並釋放同步鎖，讓其它執行緒進入 this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } } } 輸出結果：\nthread 2: number - 1 thread 1: number - 2 thread 2: number - 3 thread 1: number - 4 thread 2: number - 5 thread 1: number - 6 thread 2: number - 7 thread 1: number - 8 thread 2: number - 9 thread 1: number - 10 thread 2: number - 11 thread 1: number - 12 thread 2: number - 13 thread 1: number - 14 thread 2: number - 15 thread 1: number - 16 thread 2: number - 17 thread 1: number - 18 thread 2: number - 19 thread 1: number - 20 thread 2: number - 21 thread 1: number - 22 thread 2: number - 23 thread 1: number - 24 thread 2: number - 25 thread 1: number - 26 thread 2: number - 27 thread 1: number - 28 thread 2: number - 29 thread 1: number - 30 thread 2: number - 31 thread 1: number - 32 thread 2: number - 33 thread 1: number - 34 thread 2: number - 35 thread 1: number - 36 thread 2: number - 37 thread 1: number - 38 thread 2: number - 39 thread 1: number - 40 thread 2: number - 41 thread 1: number - 42 thread 2: number - 43 thread 1: number - 44 thread 2: number - 45 thread 1: number - 46 thread 2: number - 47 thread 1: number - 48 thread 2: number - 49 thread 1: number - 50 總結 java.lang.Thread.sleep() vs. java.lang.Object.wait() 相同點：一但執行方法，都可以使得當前執行緒進入阻塞狀態 不同點： 1.調用的要求不同：sleep()可以在任何需要的場景下使用；wait()必須使用在 synchronized修飾的區塊 或 同步方法中\n2.關於是否釋放同步鎖：若兩的方法都使用在 synchronized 結構中，sleep不會釋放鎖；而wait()會釋放鎖\n","permalink":"https://sunwc2023.github.io/blog/thread/wait-notify/","tags":["Java"],"title":"Java - 執行緒 交互輸出1-50的數字"},{"categories":["Practice"],"contents":"方式一、 使用鎖 import java.util.concurrent.locks.ReentrantLock; /** * 演示案例：銀行有一個帳戶 * 有兩個存戶分別向同一個帳戶存3000元，每次存1000，存3次。 * 每次存完輸出帳戶餘額 * @author sunwc * @create 2023-03-24 下午 12:23 */ public class ConcurrentAccount { public static void main(String[] args) { // 帳戶為共享資源，只new一次 Account account = new Account(); Depositor depositor = new Depositor(account); Thread t1 = new Thread(depositor); Thread t2 = new Thread(depositor); t1.setName(\u0026#34;存戶1\u0026#34;); t2.setName(\u0026#34;存戶2\u0026#34;); t1.start(); t2.start(); } } /** * 帳戶類 */ class Account { /** * 存款餘額 */ private double balance; /** * 存入金額並輸出帳戶餘額 * @param amount */ synchronized void deposit(int amount) {// 同步鎖默認為this if (amount \u0026gt; 0) { this.balance += amount; // 看會不會增加執行緒不安全問題 try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \u0026#34; 帳戶餘額：\u0026#34; + this.balance); } } } /** * 存戶類 */ class Depositor implements Runnable { private Account account; public Depositor(Account account) { this.account = account; } /** * 鎖，設置執行緒先進先出 */ private ReentrantLock reentrantLock = new ReentrantLock(true); @Override public void run() { // 每個存戶 每次存1000、存3次 for (int i = 0; i \u0026lt; 3; i++) { try { reentrantLock.lock(); // 存1000 account.deposit(1000); } finally { reentrantLock.unlock(); } } } } 輸出結果：\n存戶1 帳戶餘額：1000.0 存戶2 帳戶餘額：2000.0 存戶1 帳戶餘額：3000.0 存戶2 帳戶餘額：4000.0 存戶1 帳戶餘額：5000.0 存戶2 帳戶餘額：6000.0 方式二、使用 synchronized 機制 /** * @author sunwc * @create 2023-03-24 下午 12:52 */ public class ConcurrentAccount2 { public static void main(String[] args) { Depositor2 depositor1 = new Depositor2(); Depositor2 depositor2 = new Depositor2(); depositor1.setName(\u0026#34;存戶1\u0026#34;); depositor2.setName(\u0026#34;存戶2\u0026#34;); depositor1.start(); depositor2.start(); } } /** * 帳戶類 */ class Account2 { /** * 存款餘額 */ private double balance; public double getBalance() { return balance; } public void setBalance(double balance) { this.balance = balance; } } /** * 存戶類 */ class Depositor2 extends Thread { /** * 帳戶(共享資源) */ private static Account2 account; /** * constrctor在創建存戶時一併創建帳戶 */ public Depositor2() { synchronized (Depositor.class) { if (account == null) { account = new Account2(); } } } @Override public void run() { for (int i = 0; i \u0026lt; 3; i++) { // 存1000 synchronized (Depositor2.class) { deposit(1000); } } } /** * 存錢操作 * @param amount */ private void deposit(int amount) { if (amount \u0026gt; 0) { // 先取得餘額 double currnetBalance = account.getBalance(); // 增加存款金額 currnetBalance += amount; account.setBalance(currnetBalance); try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \u0026#34; 存錢成功，帳戶餘額：\u0026#34; + account.getBalance()); } } } 輸出結果：\n存戶1 存錢成功，帳戶餘額：1000.0 存戶2 存錢成功，帳戶餘額：2000.0 存戶2 存錢成功，帳戶餘額：3000.0 存戶1 存錢成功，帳戶餘額：4000.0 存戶1 存錢成功，帳戶餘額：5000.0 存戶2 存錢成功，帳戶餘額：6000.0 總結 我們在下面兩篇文章已經了解到解決執行緒不安全的兩種方式\n有關透過鎖 Lock 解決執行緒不安全問題，可以參考我的另一篇文章 Java - Lock - 解決執行緒不安全\n有關透過實現類 implements interface Runnable 達成 Multi-threading，可以參考我的另一篇文章 Java - Thread 執行緒(二) - interface Runnable\n本篇文章是舉例另一個可能會造成執行緒不安全的現實例子，能夠對於同步的機制更加印象深刻\n","permalink":"https://sunwc2023.github.io/blog/thread/deposit-concurrent-example/","tags":["Java"],"title":"Java - Lock \u0026 synchronized 使用"},{"categories":["Java"],"contents":"為什麼要用鎖(Lock)？ 鎖 相對於 synchronized 機制，是更加靈活的，它一樣能夠解決執行緒不安全的問題；\n不同點在於：synchronized機制在執行完相應的區塊後，會自動釋放同步鎖；而Lock就需要手動啟動同步 以及 手動結束同步 java.util.concurrent.locks.ReentrantLock; 是JDK 5.0新增的特性，新特性可以考慮優先使用 例子 /** * 演示使用Lock解決執行緒不安全問題 * @author sunwc * @create 2023-03-24 上午 11:18 */ public class LockTest { public static void main(String[] args) { Window window = new Window(); Thread t1 = new Thread(window); t1.setName(\u0026#34;窗口1\u0026#34;); Thread t2 = new Thread(window); t2.setName(\u0026#34;窗口2\u0026#34;); Thread t3 = new Thread(window); t3.setName(\u0026#34;窗口3\u0026#34;); t1.start(); t2.start(); t3.start(); } } /** * 窗口類 */ class Window implements Runnable { private int ticketAmount = 20; @Override public void run() { while (ticketAmount \u0026gt; 0) { if (ticketAmount \u0026gt; 0) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() +\u0026#34; : 售出的票號 - \u0026#34;+ ticketAmount); ticketAmount--; } } } } 演示執行緒不安全輸出結果：\n窗口3 : 售出的票號 - 20 窗口1 : 售出的票號 - 20 窗口2 : 售出的票號 - 20 窗口1 : 售出的票號 - 17 窗口3 : 售出的票號 - 17 窗口2 : 售出的票號 - 17 窗口3 : 售出的票號 - 14 窗口2 : 售出的票號 - 14 窗口1 : 售出的票號 - 14 窗口2 : 售出的票號 - 11 窗口1 : 售出的票號 - 11 窗口3 : 售出的票號 - 11 窗口2 : 售出的票號 - 8 窗口1 : 售出的票號 - 8 窗口3 : 售出的票號 - 8 窗口3 : 售出的票號 - 5 窗口1 : 售出的票號 - 5 窗口2 : 售出的票號 - 5 窗口1 : 售出的票號 - 2 窗口3 : 售出的票號 - 2 窗口2 : 售出的票號 - 2 窗口1 : 售出的票號 - -1 使用 ReentrantLock 使得 Thread-safety 修改窗口類\nclass Window implements Runnable { private int ticketAmount = 20; // 1.創建Lock物件 // new ReentrantLock(boolean fair) fair默認false；若設置true，執行緒先進來先執行(先進先出) ReentrantLock reentrantLock = new ReentrantLock(true); @Override public void run() { while (ticketAmount \u0026gt; 0) { try { // 2. 手動取得同步鎖 reentrantLock.lock(); if (ticketAmount \u0026gt; 0) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() +\u0026#34; : 售出的票號 - \u0026#34;+ ticketAmount); ticketAmount--; } } finally { // 3.手動釋放同步鎖 reentrantLock.unlock(); } } } } 解決執行緒不安全輸出結果：\n窗口1 : 售出的票號 - 20 窗口2 : 售出的票號 - 19 窗口3 : 售出的票號 - 18 窗口1 : 售出的票號 - 17 窗口2 : 售出的票號 - 16 窗口3 : 售出的票號 - 15 窗口1 : 售出的票號 - 14 窗口2 : 售出的票號 - 13 窗口3 : 售出的票號 - 12 窗口1 : 售出的票號 - 11 窗口2 : 售出的票號 - 10 窗口3 : 售出的票號 - 9 窗口1 : 售出的票號 - 8 窗口2 : 售出的票號 - 7 窗口3 : 售出的票號 - 6 窗口1 : 售出的票號 - 5 窗口2 : 售出的票號 - 4 窗口3 : 售出的票號 - 3 窗口1 : 售出的票號 - 2 窗口2 : 售出的票號 - 1 總結 本文介紹了如何使用鎖 將部分程式邏輯達到同步的效果，Lock的使用實際上會更靈活，因為它比較偏向人為去控制，哪時候開執行同步、哪時候結束同步，達到立竿見影的效果\n基礎鞏固：有關透過實現類 implements interface Runnable 達成 Multi-threading，可以參考我的另一篇文章 Java - Thread 執行緒(二) - interface Runnable\n","permalink":"https://sunwc2023.github.io/blog/thread/lock-reentrantlock/","tags":["Java"],"title":"Java - Lock - 解決執行緒不安全"},{"categories":["Java"],"contents":"什麼是死鎖？ 當不同執行緒分別占用對方需要的同步資源不放棄，都在等待對方放棄自己需要的同步資源，就形成了執行緒的死鎖\n死鎖出現後的現象？ 出現死鎖後，不會出現例外，也不會有提示，只是所有執行緒都處於阻塞的狀態；因此我們在使用 synchronized 的時候，要避免死鎖的情況發生\n如何避免死鎖？ 盡量減少同步資源的宣告，例如 有 static 關鍵字 避免嵌套synchronized(同步鎖){} 例子 /** * 演示執行緒死鎖問題 * @author sunwc * @create 2023-03-24 上午 10:49 */ public class DeadlockTest { public static void main(String[] args) { // 1. 第一個同步鎖 StringBuffer s1 = new StringBuffer(); // 2. 第二個同步鎖 StringBuffer s2 = new StringBuffer(); // 3.匿名子類創建執行緒(子Thread1) new Thread() { @Override public void run() { synchronized (s1) { s1.append(\u0026#34;1\u0026#34;); s2.append(\u0026#34;a\u0026#34;); // 5. 阻塞0.1秒，增加死鎖概率 try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (s2) { s1.append(\u0026#34;2\u0026#34;); s2.append(\u0026#34;b\u0026#34;); Thread.currentThread().setName(\u0026#34;子Thread1\u0026#34;); System.out.println(Thread.currentThread().getName() + \u0026#34; : \u0026#34; + s1); System.out.println(Thread.currentThread().getName() + \u0026#34; : \u0026#34; + s2); } } } }.start(); // 4. 匿名實現類創建執行緒 new Thread(new Runnable() { @Override public void run() { synchronized (s2) { s1.append(\u0026#34;3\u0026#34;); s2.append(\u0026#34;c\u0026#34;); // 6. 阻塞0.1秒，增加死鎖概率 try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (s1) { s1.append(\u0026#34;4\u0026#34;); s2.append(\u0026#34;d\u0026#34;); Thread.currentThread().setName(\u0026#34;子Thread2\u0026#34;); System.out.println(Thread.currentThread().getName() + \u0026#34; : \u0026#34; + s1); System.out.println(Thread.currentThread().getName() + \u0026#34; : \u0026#34; + s2); } } } }).start(); } } 總結 本文使用一個例子演示了兩個執行緒如何剛好都在等對方持有的那把鎖，而導致程式整個卡住了，因此使用 synchronized 機制時，還是要思考一下如何避免死鎖的情況產生，就像我們使用迴圈也會避免出現死循環一樣\n","permalink":"https://sunwc2023.github.io/blog/thread/thread-deadlock/","tags":["Java"],"title":"Java - Thread 的 Deadlock"},{"categories":["Java"],"contents":"JDK中用Thread.State類定義了執行緒的幾種狀態如下：\npublic enum State { NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED } Java語言使用 Thread 類及其子類別的物件來表示執行緒，在它一個完整的生命週期中通常要經歷如下五個狀態：\n1. 新建：當一個 Thread 類或其子類別的物件被宣告並創建時，新的執行緒物件處於新建狀態\r2. 就緒：處於新建狀態的執行緒被start()後，將進入執行緒隊列等待、以取得一段能夠搶占CPU的使用時長，此時它已具備了執行的條件，只是還沒分配到CPU資源\r3. 執行：當就緒的執行緒被調度並取得CPU資源時，便進入執行狀態，run()中定義了執行緒的操作和功能\r4. 阻塞：在某種特殊的情況下，被人為掛起或執行輸入輸出操作時，讓出CPU並臨時中止自己的執行，進入阻塞狀態\r5. 死亡：當執行緒完成了它的全部工作或執行緒被提前強制性地終止或出現例外導致結束\r總結 本文概略的介紹了執行緒的生命週期，了解到從 就緒 到 執行 狀態是雙向的關係，以及在生命週期關係圖中，提及一些 java.lang.Object的方法，例如wait(), notify(), notifyAll()等，因此關於方法的介紹請看\n我的另一篇文章 Java - 執行緒 交互輸出1-50的數字\n","permalink":"https://sunwc2023.github.io/blog/thread/thread-lifecycle/","tags":["Java"],"title":"Java - Thread 的 生命週期"},{"categories":["Java"],"contents":" 有關創建多執行緒 (Multi-threading) 的方式 - 繼承 Thread 類，可以參考我的另一篇文章 Java - Thread 執行緒(一)\n除了上述說的方式創建新的執行緒；\n在實際應用面，以透過實現 interface Runnable 來做是更好的方式，詳細的說明如下：\n新執行緒的創建 (Multi-threading) - 實現 interface Runnable 之步驟 1.創建一個實現了 interface Runnable 的類別\n2.實現類去實現 Runnable 的抽象方法： run()\n3.創建實現類的物件\n4.將此物件作為參數傳遞到 Thread 類的建構子(constructor)中\n5.通過 Thread 類的物件調用 start()\n[ 註 ] 以下的例子為非thread-safety，還必須優化；本文最後會介紹兩種優化方法\n例子 /** * 售票窗口類 */ class Window implements Runnable { private int ticketAmount = 20; @Override public void run() { while (true) { if (ticketAmount \u0026gt; 0) { // 進行賣票操作 System.out.println(Thread.currentThread().getName() + \u0026#34; : 售出票號 - \u0026#34; + ticketAmount); ticketAmount--; } else { break; } } } } /** * 測試類 * @author sunwc * @create 2023-03-23 下午 03:01 */ public class ImplementsRunnableTest { public static void main(String[] args) { Window window = new Window(); Thread t1 = new Thread(window); t1.setName(\u0026#34;Window 1\u0026#34;); Thread t2 = new Thread(window); t2.setName(\u0026#34;Window 2\u0026#34;); Thread t3 = new Thread(window); t3.setName(\u0026#34;Window 3\u0026#34;); t1.start(); t2.start(); t3.start(); } } 演示執行緒不安全輸出結果：\nWindow 1 : 售出票號 - 20 Window 2 : 售出票號 - 20 Window 3 : 售出票號 - 20 Window 2 : 售出票號 - 18 Window 2 : 售出票號 - 16 Window 1 : 售出票號 - 19 Window 2 : 售出票號 - 15 Window 3 : 售出票號 - 17 Window 2 : 售出票號 - 13 Window 2 : 售出票號 - 11 Window 2 : 售出票號 - 10 Window 2 : 售出票號 - 9 Window 2 : 售出票號 - 8 Window 2 : 售出票號 - 7 Window 2 : 售出票號 - 6 Window 2 : 售出票號 - 5 Window 2 : 售出票號 - 4 Window 2 : 售出票號 - 3 Window 2 : 售出票號 - 2 Window 2 : 售出票號 - 1 Window 1 : 售出票號 - 14 Window 3 : 售出票號 - 12 創建新執行緒：繼承 Thread 類 vs. 實現 interface Runnable 開發中會優先選擇 實現 interface Runnable 方式\n原因：\n實現的方式沒有 類別單一繼承 的侷限性 實現的方式更適合來處理 Multi-threading 有共享資料的情況 其實原生的 Thread 類別 也是 interface Runnable 的實現類， 所以不管是子類繼承 Thread 類 或 實現類實現 interface Runnable ，相同點是： 需要 Override run()，將執行緒要執行的邏輯寫在 run() 中\n上面的售票的執行緒安全問題，問題點解釋： 售票過程中，出現了重複售出同一個票號的票、超賣的情況 原因：當某個執行緒操作車票的過程中，尚未操作完成時，其它的執行緒就參與進來 如何解決執行緒安全問題： 當一個執行緒A在操作ticket的時候，其它執行緒不能參與進來。直到執行緒A操作完ticket時，其它執行緒才可以開始操作ticket。這種情況即使執行A被阻塞了，其它執行緒也一定要等待\n現實例子：\n當某A在使用唯一一間廁所時，某B即使肚子痛要使用，也要等某A使用完才可以進入。因為某A鎖門了，某B只好等了\n在Java中，我們通過同步機制，來解決執行緒安全的問題 優化方式一、同步程式區塊 synchronized(同步鎖) { // 需要被同步的程式 } 說明：\n將共享資料的程式用synchronized(同步鎖){}包起來，當一個thread先進入這層，其它thread要先在這層外面等\n共享資料：指的是Multi-threading中共同操作的一個變數，以例子來說 ticketAmount 就是共享的資料\n什麼是同步鎖？\n任何一個類別的物件都可以充當鎖，但是Multi-threading 中的每個 thread 進入這層時都必須使用同一把鎖\n侷限性：在同步程式區塊內，只能有一個執行緒參與，其它執行緒等待。區塊內相當於是一個單執行緒的過程，效率會比較低\n例子 優化後(一)的售票窗口類： /** * 售票窗口類 */ class Window implements Runnable { private int ticketAmount = 20; @Override public void run() { while(true) { // 同步程式區塊 - Window.class(當前類別)充當唯一一把鎖 // 因為類別只會加載一次，當作唯一鎖相對安全 // 用this的話要看這個類別在主執行緒(main方法)中new了幾個物件 // 若只有一個就可以用this當唯一鎖 synchronized (Window.class) { // 或 synchronized (this) if (ticketAmount \u0026gt; 0) { // 執行緒阻塞，提高執行緒不安全機率 try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } // 進行賣票操作 System.out.println(Thread.currentThread().getName() + \u0026#34; : 售出票號 - \u0026#34; + ticketAmount); ticketAmount--; } else { break; } } } } } 解決執行緒不安全輸出結果：\nWindow 1 : 售出票號 - 20 Window 1 : 售出票號 - 19 Window 1 : 售出票號 - 18 Window 1 : 售出票號 - 17 Window 1 : 售出票號 - 16 Window 1 : 售出票號 - 15 Window 1 : 售出票號 - 14 Window 3 : 售出票號 - 13 Window 2 : 售出票號 - 12 Window 2 : 售出票號 - 11 Window 2 : 售出票號 - 10 Window 2 : 售出票號 - 9 Window 2 : 售出票號 - 8 Window 2 : 售出票號 - 7 Window 2 : 售出票號 - 6 Window 3 : 售出票號 - 5 Window 3 : 售出票號 - 4 Window 1 : 售出票號 - 3 Window 1 : 售出票號 - 2 Window 1 : 售出票號 - 1 優化方式二、同步方法 若使用到共享資料的程式完整的寫在一個方法中，我們不妨將此方法宣告成同步的\n同步方法仍然涉及到同步鎖，只是不需要我們顯示的宣告\n同步鎖 ：\n非靜態的同步方法：this (當前物件本身)\n靜態的同步方法：當前類別本身\n例子 優化後(二)的售票窗口類： /** * 售票窗口類 */ class Window implements Runnable { private static int ticketAmount = 20; @Override public void run() { while (ticketAmount \u0026gt; 0) { // 售票 sellTicket(); } } // private synchronized void sellTicket() {// 默認使用this當作鎖 private static synchronized void sellTicket() { // 默認使用Window.class當鎖 if (ticketAmount \u0026gt; 0) { // 執行緒阻塞，提高執行緒不安全機率 try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } // 進行賣票操作 System.out.println(Thread.currentThread().getName() + \u0026#34; : 售出票號 - \u0026#34; + ticketAmount); ticketAmount--; } } } 解決執行緒不安全輸出結果：\nWindow 1 : 售出票號 - 20 Window 1 : 售出票號 - 19 Window 1 : 售出票號 - 18 Window 3 : 售出票號 - 17 Window 3 : 售出票號 - 16 Window 3 : 售出票號 - 15 Window 3 : 售出票號 - 14 Window 3 : 售出票號 - 13 Window 3 : 售出票號 - 12 Window 3 : 售出票號 - 11 Window 3 : 售出票號 - 10 Window 3 : 售出票號 - 9 Window 3 : 售出票號 - 8 Window 3 : 售出票號 - 7 Window 2 : 售出票號 - 6 Window 2 : 售出票號 - 5 Window 2 : 售出票號 - 4 Window 2 : 售出票號 - 3 Window 2 : 售出票號 - 2 Window 2 : 售出票號 - 1 總結 本文幫助了解如何\n1.透過實現類 implements interface Runnable 達成 Multi-threading\n2.透過將共享資源宣告成「同步的」以解決執行緒不安全問題\n延伸學習：有關透過鎖 Lock 解決執行緒不安全問題，可以參考我的另一篇文章 Java - Lock - 解決執行緒不安全\n","permalink":"https://sunwc2023.github.io/blog/thread/implements-runnable/","tags":["Java"],"title":"Java - Thread 執行緒(二) - interface Runnable"},{"categories":["Java"],"contents":"\n什麼是Process？ 通常一個應用程序執行起來，就會在記憶體加載一個 Process ，對應到工作管理員(上圖)來看，一個 Process 就會對應到一個 PID (Process Identification)； 而一個 Process 會有 Multi-threading (Thread)，代表這個應用程序支持我們能夠使用它 同時在裡面做很多事情\n例如 執行一個 Java 應用程序java.exe，其實至少有三個執行緒被執行：main() 主執行緒、gc() 資源回收執行緒、例外處理執行緒。當然若有例外發生，就可能會影響主執行緒\n什麼是併行 與 併發？ 併行：多個CPU同時執行多個任務。例如 多個人同時做不同的事情\n併發：一個CPU快速切換不同執行緒以執行任務。例如 搶演唱會門票、多個人做同一件事情\nJVM 的記憶體結構 每個 Thread 都有獨立的一套 VM Stack 與 Program Counter Register\r每個 Process 有獨立的一套 Method Area 與 Heap，即 Multi-threading 一起共用這些資源\r有關創建多執行緒的方式 - 實現 interface Runnable，可以參考我的另一篇文章 Java - Thread 執行緒(二) - interface Runnable\n新執行緒的創建 (Multi-threading) - 繼承 Thread 類 之步驟 1.創建一個繼承於 Thread 類的子類別\n2.覆寫 Thread 類的run()\n3.創建 Thread 類的子類別物件\n4.通過此物件調用start()\n例子 class MyThread extends Thread { /** * 子執行緒輸出偶數 */ @Override public void run() { // 在這裡寫在 子執行緒 要做的事情 for (int i = 1; i \u0026lt;= 10; i++) { if (i % 2 == 0) { System.out.println(Thread.currentThread().getName() + \u0026#34; : \u0026#34; + i); } } } } /** * 多執行緒的創建 * 遍歷10以內的所有偶數 * @author sunwc * @create 2023-03-23 上午 10:23 */ public class ThreadTest { public static void main(String[] args) { // 主執行緒創建一個新執行緒 MyThread t1 = new MyThread(); // 主執行緒啟動子執行緒(會去執行run()) t1.start(); // 測試一、不能通過調用run()的方式啟動執行緒 // t1.run(); // 測試二、子執行緒已經t1.start()啟動，不能再用一樣的語句再啟動一次，會拋出java.lang.IllegalThreadStateException // 若 threadStatus != 0 會拋此例外 // t1.start(); // 再創建第二個子執行緒 MyThread t2 = new MyThread(); t2.start(); // 主執行緒輸出奇數 for (int i = 1; i \u0026lt;= 10; i++) { if (i % 2 != 0) { System.out.println(Thread.currentThread().getName() + \u0026#34; : \u0026#34; + i); } } } } 輸出結果\nThread-0 : 2 Thread-1 : 2 main : 1 Thread-1 : 4 Thread-0 : 4 Thread-0 : 6 Thread-0 : 8 Thread-0 : 10 Thread-1 : 6 main : 3 main : 5 main : 7 main : 9 Thread-1 : 8 Thread-1 : 10 使用匿名子類創建子執行緒 /** * 使用匿名子類創建兩個子執行緒 * 一個執行緒 印奇數 * 一個執行緒 印偶數 * @author sunwc * @create 2023-03-23 上午 11:05 */ public class NonTitleThreadTest { public static void main(String[] args) { new Thread() { @Override public void run() { for (int i = 1; i \u0026lt;= 10; i++) { if (i % 2 != 0) { Thread.currentThread().setName(\u0026#34;thread 1\u0026#34;); System.out.println(Thread.currentThread().getName() + \u0026#34; : \u0026#34; + i); } } } }.start(); new Thread() { @Override public void run() { for (int i = 1; i \u0026lt;= 10; i++) { if (i % 2 == 0) { Thread.currentThread().setName(\u0026#34;thread 2\u0026#34;); System.out.println(Thread.currentThread().getName() + \u0026#34; : \u0026#34; + i); } } } }.start(); } } 輸出結果\nthread 1 : 1 thread 1 : 3 thread 1 : 5 thread 1 : 7 thread 1 : 9 thread 2 : 2 thread 2 : 4 thread 2 : 6 thread 2 : 8 thread 2 : 10 Thread 類常見的方法 1. start()：啟動當前執行緒；調用當前執行緒的run()\r2. run()：通常需要覆寫Thread類中的此方法，將創建的執行緒要執行的操作寫在此方法中\r3. currentThread()：靜態方法，回傳當前程式的執行緒\r4. getName()：取得當前執行緒的名稱\r5. setName()：設置當前執行緒的名稱\r6. yield()：釋放當前CPU的執行權\r7. join()：在 執行緒A 中調用 執行緒B的join()，此時執行緒A就進入阻塞狀態，直到執行緒B全部執行完後，執行緒A才結束阻塞狀態\r8. stop：已過時不使用。當執行此方法時，強制結束當前執行緒\r9. sleep(long millitime)：讓當前執行緒“睡眠”指定的毫秒數，在指定的millitime時間內，當前的執行緒是阻塞狀態\r10. isAlive()：判斷當前執行緒是否還存活\rThread 類的優先級 1. MAX_PRIORITY: 10\rMIN_PRIORITY: 1\rNORM_PRIORITY: 5\r2. 如何取得和設置當前執行緒的優先級\rgetPriority()：取得執行緒的優先級\rsetPriority(int priority)：設置執行緒的優先級\r總結 本文介紹的內容比較多，包含：\n1.在作業系統中的 Process 以及它與 Thread 之間的關係\n2.如何透過繼承 Thread 類的方式創建新的執行緒來達成 Multi-threading\n3.用比較懶的方式(使用匿名子類)、在不用創建子類別繼承 Thread 類的方式創建新的執行緒來達成 Multi-threading\n4.Thread 類的常見方法、執行的優先級等\n","permalink":"https://sunwc2023.github.io/blog/thread/thread/","tags":["Java"],"title":"Java - Thread 執行緒(一)"},{"categories":["Java"],"contents":" Error：此錯誤是 Java虛擬機 (JVM) 無法解決的嚴重問題。例如 JVM系統內部錯誤、資源耗盡等嚴重情況 java.lang.StackOverflowError堆疊溢出 =\u0026gt; 例如 recursion終止條件沒寫好 java.lang.OutOfMemoryError 堆積溢出 =\u0026gt; 例如 Integer[] arr = new Integer[1024*1024*1024]; Exception：由於程式編輯錯誤或偶然的外在因素的一般性問題，可以使用針對性的程式進行處理 請看以下error/ exception 架構圖進行了解：\n例外體系結構： java.lang.Throwable java.lang.Error： 一般不編寫針對性的程式進行處理 java.lang.Exception： 可以進行例外的處理 compile 時異常(checked) IOExpetion FileNotFoundException ClassNotFoundException run 時異常(unchecked, RuntimeException) NullPointerException ArrayIndexOutBoundsException StringIndexOutBoundsException ClassCastException NumberFormatException InputMismatchException ArithmeticException 例外處理的方式： 方式一、try-catch-finally\n狼來了，自己把狼驅走，保護好羊群\n能夠處理 compile 時期的例外，run 時期仍可能出現例外，相當於延遲例外情況到執行的時候才可能會出現；通常我們在開發時一定是先處理編譯時例外，執行時例外視情況處理\n方式二、throws + 例外類型\n狼來了，自己趕快大喊，捕狼人來幫幫忙哦～ (自己沒辦法保護好羊群)\n拋給方法的調用者去處理\n手動拋出一個例外物件，視業務邏輯必要時使用： 使用 throw 關鍵字\nclass Student { private int id; public void register(int id) throws Exception { if (id \u0026gt; 0) { this.id = id; } else { // 手動拋出例外物件 throw new RuntimeException(\u0026#34;您輸入的學號是不合規範的\u0026#34;); } } } 總結 本文介紹\n1.Error/Exception 架構 父子層 關係\n因此我們在需要捕獲多個例外時，若例外類別之間彼此有父子類關係，就先寫子類、再寫父類\r2.例外處理的兩種方式\n3.視業務邏輯使用 throw 關鍵字拋出例外物件並輸出自定義訊息\n","permalink":"https://sunwc2023.github.io/blog/exception/exception-example/","tags":["Java"],"title":"Java - 例外處理 (Exception)"},{"categories":["Java"],"contents":"interface 特性 interface 可以定義全局常量、抽象方法、靜態方法與默認方法\ninterface 沒有 constructor，因此也不可以實例化\nJava類可以 implements 多個 interface ，彌補了 Java 單繼承的侷限性 (先寫繼承後寫實現)\npublic final class String extends Object implements java.io.Serializable, Comparable\u0026lt;String\u0026gt;, CharSequence { } interface 之間可以多重繼承 interface 體現多型的特性 可以把 interface 看作是一種規範 (contract) 現實例子： USB adaptor、JDBC interface 資料庫連線的規範(MySQL Driver, MSSQL Driver, Oracle Driver,\u0026hellip;.)\n例子 /** * interface USB * @Description * @author sunwc * @Date 2023年3月22日下午12:31:17 * */ interface USB { // 全局常量：定義了長、寬、高、最小傳輸速度等 public static final int WIDTH = 3; // 開始驅動 public abstract void start(); // public abstract可省略 // 移除驅動 void stop(); // 靜態方法(有方法體) public static void staticMethod() { System.out.println(\u0026#34;interface USB靜態方法\u0026#34;); } // 默認方法(有方法體) public default void defaultMethod1() { System.out.println(\u0026#34;interface USB默認方法1\u0026#34;); } public default void defaultMethod2() { System.out.println(\u0026#34;interface USB默認方法2\u0026#34;); } } /** * 創見USB 實現 interface USB * @Description * @author sunwc * @Date 2023年3月22日下午12:33:16 * */ class Transcend implements USB { @Override public void start() { System.out.println(\u0026#34;Transcend USB開啟工作\u0026#34;); } @Override public void stop() { System.out.println(\u0026#34;Transcend USB結束工作\u0026#34;); } @Override public void defaultMethod1() { System.out.println(\u0026#34;Transcend覆寫defaultMethod1\u0026#34;); } public void myMethod() { // 調用自己定義的覆寫方法 defaultMethod1(); // 調用interface中的默認方法 USB.super.defaultMethod1(); } } /** * 電腦類 * @Description * @author sunwc * @Date 2023年3月22日下午12:33:01 * */ class Computer { /** * 傳輸資料 * @Description * @author sunwc * @Date 2023年3月22日下午2:58:08 * @param usb */ public void transferData(USB usb) { usb.start(); System.out.println(\u0026#34;具體傳輸資料細節\u0026#34;); usb.stop(); } } /** * 測試類 * @Description * @author sunwc * @Date 2023年3月22日下午12:33:27 * */ public class USBTest { public static void main(String[] args) { Computer computer = new Computer(); Transcend transcend = new Transcend();// Usb usb = new Transcend(); computer.transferData(transcend); System.out.println(\u0026#34;=============================\u0026#34;); // interface的靜態方法只能透過interface進行調用 USB.staticMethod(); // 實現類可以覆寫interface的default方法 transcend.defaultMethod1(); // 若實現類沒有覆寫interface的default方法，則執行原本default方法的內容 transcend.defaultMethod2(); System.out.println(\u0026#34;==============================\u0026#34;); transcend.myMethod(); } } 輸出結果：\nTranscend USB開啟工作 具體傳輸資料細節 Transcend USB結束工作 ============================= interface USB靜態方法 Transcend覆寫defaultMethod1 interface USB默認方法2 ============================== Transcend覆寫defaultMethod1 interface USB默認方法1 結論：\ninterface 與 抽象類別 都不能被實例化，因此均體現 多型 的特性，需要子類別來繼承 或 實現類來實現\r以上面的例子來說，電腦傳輸資料時，均接受符合USB規範的各種物件，這就是多型的體現方式，因為電腦不用管USB adaptor、硬碟 (hard disk) 是哪種牌子，只要是符合interface USB規範都可以，也就能夠透過USB usb變數接受的不同 實現類別 而執行不同的 開始驅動 與 移除驅動 的方法了，藉以展現不同的行為模式\n","permalink":"https://sunwc2023.github.io/blog/abstract/interface/","tags":["Java"],"title":"Java - interface"},{"categories":["Java"],"contents":" 有關的例子，可以參考我的另一篇文章 Java - 多型 繼承\nabstract的特性 abstract 關鍵字只可以修飾 非final 的類別、 非private、非static、非final 的方法 抽象類別不可以實例化，抽象類別一定有constructor，以便讓子類別實例化的時候可以進行調用 抽象方法只有方法的宣告、沒有方法體 總結： 包含 抽象方法 的類別，一定是抽象類別；反之，抽象類別中可以無抽象方法 若子類別覆寫父類別的所有抽象方法後，此子類別可以實例化；若子類別沒有覆寫父類的所有抽象方法，則此子類別也是一個抽象類別，需要使用 abstract 修飾 ","permalink":"https://sunwc2023.github.io/blog/abstract/abstract/","tags":["Java"],"title":"Java - 抽象類別 抽象方法"},{"categories":["Java"],"contents":" static 關鍵字： 有些時候，我們希望「某些特定資料在記憶體中只有一份」，且這份資料是大家共享的，而不會隨著物件而不同的，例如：存款利率、最低存款金額、工具類\naccess 靜態變數 實例變數\r類別 Yes No\r物件 Yes Yes\rstatic 特性： static 可以修飾 屬性、方法、程式區塊、內部類 靜態程式區塊 (static block)：(用於類別初始化) 隨著類別加載時，就會執行，且只會執行一次 static { System.out.println(\u0026#34;只要本類別在加載時，我會被輸出\u0026#34;); } 非靜態程式區塊 (non-static block) 隨著每次物件被new時，就會被執行；執行順序優於建構子 (constructor) { System.out.println(\u0026#34;只要本類別在new一個物件時，我會被輸出\u0026#34;); } 靜態變數/靜態方法 是與類別 同時加載的，因此 靜態變數 是早於物件創建 由於類別只會加載一次，因此靜態修飾的結構只會在記憶體中存在一份資料，存在在方法區的靜態域 靜態方法只可以存取靜態變數與靜態方法(早出生不能調晚出生的)；實例方法可以存取靜態結構與實例結構(晚出生能調早出生的)，原因是看在生命週期被創建的時間點 單例設計模式： 所謂類別的單例設計模式，就是採取一定的方法保證在整個程式系統中，對某個類別只能存在一個物件實例。\n如何實現： 具體參考如下\n單例模式的優點： 由於單例模式指生成一個實例，減少了系統性能開銷，當一個物件的產生需要比較多的資源時，如讀取配置、產生其他依賴物件時，則可以通過在應用程式啟動時直接產生一個單例物件，然後永久駐留記憶體的方式來解決，例如 java.lang.Runtime\n現實例子： 網站的計數器 應用程式的日誌應用 資料庫連線池 讀取配置文件的類別 Application 就是單例的典型應用 Windows的Task Manager(任務管理器) Windows的Recycle Bin(資源回收桶) 單例設計模式 方式一 // 餓漢式 public class SingletonTest { public static void main(String[] args) { Bank bank1 = Bank.getInstance(); Bank bank2 = Bank.getInstance(); // 同一個地址值 System.out.println(\u0026#34;bank1 == bank2 : \u0026#34; + (bank1 == bank2)); } } class Bank { // 1. 私有化類別的建構子 private Bank() { } // 2. 類別的內部創建類別的私有物件，且宣告為靜態的 private static Bank instance = new Bank(); // 3. 提供公共靜態的方法，回傳類別的物件 public static Bank getInstance() { return instance; } } 輸出結果：\r```txt\rbank1 == bank2 : true 單例設計模式 方式二 // 懶漢式 public class SingletonTest2 { public static void main(String[] args) { Order order1 = Order.getInstance(); Order order2 = Order.getInstance(); // 同一個地址值 System.out.println(\u0026#34;order1 == order2 : \u0026#34; + (order1 == order2)); } } class Order { static { System.out.println(\u0026#34;static block 類別加載中…\u0026#34;); } // 1. 私有化類別的建構子 private Order() { } // 2. 類別的內部宣告類別變數，但不初始化 private static Order instance = null; // 3. 提供公共靜態的方法，回傳類別的物件 // 要調用的時候再new(非執行緒安全) =\u0026gt; 方法加上 synchronized 關鍵字就成了同步方法(執行緒安全) public static synchronized Order getInstance() { if (instance == null) { // 只new一次 instance = new Order(); } return instance; } { System.out.println(\u0026#34;non-static block 類別物件被new出來了…\u0026#34;); } } 輸出結果：\nstatic block 類別加載中… non-static block 類別物件被new出來了… order1 == order2 : true ","permalink":"https://sunwc2023.github.io/blog/static/static-example/","tags":["Java"],"title":"Java - static 關鍵字 vs. 單例 (Singleton) 設計模式"},{"categories":["Java"],"contents":"Object 的 euqals() 與 == 作用是相同的 是比較兩個物件的記憶體地址是否相同\npublic boolean equals(Object obj) { return (this == obj); } String, java.util.Date, File, wrapper class的 equals() 都已經覆寫Object的 euqals()，比較的不是兩個物件的地址值是否相等，而是比較實體內容是否相同 String s1 = new String(\u0026#34;sunwc\u0026#34;); String s2 = new String(\u0026#34;sunwc\u0026#34;); System.out.println(s1.equals(s2)); //true Date date1 = new Date(32432525324L); Date date2 = new Date(32432525324L); System.out.println(date1.equals(date2)); //true 自定義類別 覆寫 equals() public class Customer { private int age; private String name; public Customer() { super(); } public Customer(int age, String name) { super(); this.age = age; this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } /** * 手動實現 * 覆寫的原則：比較兩個物件的實體內容(即name和age)是否相同 */ @Override public boolean equals(Object obj) { if (this == obj) { return true; } if (obj instanceof Customer) { Customer customer = (Customer) obj; return customer.age == this.age \u0026amp;\u0026amp; customer.name.equals(this.name); } return false; } } /** * IDE 自動生成 equals() 覆寫：比較兩個物件的實體內容(即name和age)是否相同 */ @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Customer other = (Customer) obj; if (age != other.age) return false; if (name == null) { if (other.name != null) return false; } else if (!name.equals(other.name)) return false; return true; } 測試類\npublic class CustomerTest { public static void main(String[] args) { Customer c1 = new Customer(18, \u0026#34;Lucy\u0026#34;); Customer c2 = new Customer(18, \u0026#34;Lucy\u0026#34;); System.out.println(c1.equals(c2)); //true } } 理解 Collection API: contains(), containsAll(), remove(), removeAll()判斷 與 Collection元素擁有equals() 的邏輯判斷有關，主要看該 equals() 是比較記憶體地址 還是 屬性內容？ /** * @author sunwc * @create 2023-03-28 上午 09:56 */ public class CollectionTest { @Test public void collectionTest() { Collection collection = new ArrayList\u0026lt;\u0026gt;(); Person person = new Person(\u0026#34;Jerry\u0026#34;, 20); collection.add(person); System.out.println(collection.size()); // 1 boolean contains = collection.contains(person); // true System.out.println(contains); // 在自定義Person尚未 Override equals()時，默認是使用Object類的 equals()，比較的是 == 的概念 // 因此 比較的是 記憶體的地址 // 所以這時候如果問 new Person(\u0026#34;Jerry\u0026#34;, 20) 是否有包含在集合中時，就會回傳false // 但是如果Person類 Override equals()後，比較的就會是 Person類中的屬性了 // 所以這時候如果問 new Person(\u0026#34;Jerry\u0026#34;, 20) 是否有包含在集合中時，就會回傳true System.out.println(collection.contains(new Person(\u0026#34;Jerry\u0026#34;, 20))); // collection.remove() 與 collection.contains() 的調用的結果，會隨著自定義類別是否覆寫過 equals() 而有不同 boolean jerry = collection.remove(new Person(\u0026#34;Jerry\u0026#34;, 20)); System.out.println(jerry); } } class Person { private String name; private int age; public Person() { } public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { final StringBuilder sb = new StringBuilder(\u0026#34;Person{\u0026#34;); sb.append(\u0026#34;name=\u0026#39;\u0026#34;).append(name).append(\u0026#39;\\\u0026#39;\u0026#39;); sb.append(\u0026#34;, age=\u0026#34;).append(age); sb.append(\u0026#39;}\u0026#39;); return sb.toString(); } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Person person = (Person) o; return age == person.age \u0026amp;\u0026amp; Objects.equals(name, person.name); } } 總結 向 interface Collection 的實現類別的物件容器中，新增元素 obj 時，要求 obj 所在類別要覆寫 equals()\n補充知識 Collection 集合\n特性：元素有序性、元素可重複性 removeAll()：求差集 =\u0026gt; 刪除兩個集合中一樣的所有元素，而保留其他不一樣的元素 retainAll()：求交集 =\u0026gt; 刪除兩個集合中所有不一樣的元素，而保留其他一樣的元素 集合 \u0026ndash;\u0026gt; array Collection collection = new ArrayList\u0026lt;\u0026gt;(); collection.add(123); collection.add(456); Object[] arr = collection.toArray(); System.out.println(Arrays.toString(arr)); // [123, 456] array \u0026ndash;\u0026gt; 集合 List\u0026lt;Integer\u0026gt; list = Arrays.asList(new Integer[]{123,456}); System.out.println(list); // [123, 456] ","permalink":"https://sunwc2023.github.io/blog/compare/equals/","tags":["Java"],"title":"Java - equals 方法"},{"categories":["Java"],"contents":"finalize 方法 一般來說，在物件被回收之前會先存取 物件.finalize()，但是我們不要主動去調finalize()，gc回收機制會主動去調 物件.finalize()\nfinal 關鍵字 * final 修飾類別： 代表本類別就不能被繼承，例如 String, System, StringBuffer 類別\r* final 修飾方法： 代表本方法不能被覆寫 (Override)，例如Object類別的getClass()\r* final 修飾變數： 代表本變數為常量，不能做修改；可以考慮指定值的位置有：顯示初始化、non-static-block 中初始化、constructor 中初始化\r```java\rpublic class SingletonTest2 {\rfinal int WIDTH;\rfinal int HEIGHT;\rfinal double PI;\r// non-static-block\r{\rPI = Math.PI;\r}\r// construtor1\rpublic SingletonTest2() {\rWIDTH = 2;\rHEIGHT = 4;\r}\r// construtor2\rpublic SingletonTest2(int height) {\rWIDTH = 2;\rHEIGHT = height;\r}\r}\r```\rfinal面試題一、\r```java\rpublic class Something {\rpublic int addOne(final int x) {\rreturn ++x; // 編譯錯誤\r// return x + 1; // 編譯、執行成功\r}\r}\r```\rfinal面試題二、\r```java\rpublic class Something {\rpublic static void main(String[] args) {\rOther o = new Other();\rnew Something().addOne(o);\r}\rpublic void addOne(final Other o) {\r// o = new Other(); // 編譯錯誤\r// 被加上final的物件 其屬性是可以修改的\ro.i++; // 編譯、執行成功 }\r}\rclass Other {\rpublic int i;\r}\r```\r* stactic final修飾屬性：代表本屬性為 全局常數\rtry-catch-finally： finally 區塊：一定會被執行的程式\n當 catch 區塊中又出現例外 當 try 區塊有 return 語句 public class ExeptionTest { public static void main(String[] args) { ExeptionTest exeptionTest = new ExeptionTest(); String numberString = exeptionTest.exceptionTest(); System.out.println(numberString); } public String exceptionTest() { try { int[] arr = new int[3]; System.out.println(arr[3]); return \u0026#34;0\u0026#34;; } catch (ArrayIndexOutOfBoundsException e) { System.out.println(\u0026#34;進catch~\u0026#34;); return \u0026#34;1\u0026#34;; } finally { System.out.println(\u0026#34;進finally~\u0026#34;); return \u0026#34;2\u0026#34;; } } } 輸出結果：(finally 區塊執行完畢後，才會執行其他區塊的 return 語句)\n進catch~ 進finally~ 2 finally 關閉資源 JVM 對於物理連接，例如資料庫連線、輸入輸出流、Socket連線銷毀無能為力，否則有內存洩漏的危險，此時資源的釋放，就需要宣告在finally中 @Test public void testFinallyClose() { FileInputStream fis = null; try { File file = new File(\u0026#34;hello.txt\u0026#34;); fis = new FileInputStream(file); // 讀取一個字符 int data = fis.read(); while(data != -1) { System.out.print((char) data); data = fis.read(); } } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } finally { if (fis != null) { try { fis.close(); } catch (IOException e2) { e2.printStackTrace(); } } } } 總結 面試中考題層出現問它們三倆有什麼關係 final, finally, finalize，其實並沒有關係，只是長得像就被放在一起了，透過這篇文章能夠更了解各自的意義，不要下次又搞混了就好了 :)\n","permalink":"https://sunwc2023.github.io/blog/final/final-finally-finalize/","tags":["Java"],"title":"Java - final, finally, finalize 的區別"},{"categories":["Java"],"contents":"encapsulation封裝性： Java提供了4種存取修飾符private ,不寫(default), protected , public來修飾類別及類別的內部結構，體現類別及內部結構在被存取時的可見性(visible)的大小\ninheritance繼承性： 減少程式碼的冗餘，也方便功能的擴展，先有一個類別(子)去繼承另一個類別(父)，而有了父類與子類的關係，子類可以使用父類的所有功能，且子類還可以在父類的基礎之上擴展其他功能 =\u0026gt; is-a 關係(子類 is a 父類)\npolymorphism多型性： 類別的繼承關係 子類要覆寫 (Override) 父類的方法，就能透過父類別使用子類別覆寫的功能 典型例子：資料庫連線 父、子類的設計 物件的多型性：只適用於方法 (Method) =\u0026gt; 又稱 存取虛擬方法 ；但不適用屬性 (Field)！ 多型 例子 package day08.oop; class Person { int age; int name; public Person() { this.age = 1; } public void eat() { System.out.println(\u0026#34;人吃飯\u0026#34;); } public void sleep() { System.out.println(\u0026#34;人睡覺\u0026#34;); } } class Student extends Person { int age; public Student() { this.age = 10; } @Override public void eat() { System.out.println(\u0026#34;學生要吃營養的食物\u0026#34;); } @Override public void sleep() { System.out.println(\u0026#34;學生要睡飽才會長高\u0026#34;); } public void study() { System.out.println(\u0026#34;學生認真學習！\u0026#34;); } } public class PolymorphismTest { public static void main(String[] args) { Person p1 = new Student(); p1.eat(); p1.sleep(); // 會存取到父類別的屬性 System.out.println(\u0026#34;age=\u0026#34;+p1.age); System.out.println(\u0026#34;====================\u0026#34;); // 如何才能使用 p1變數 存取子類別特有的屬性與方法？ // 使用向下轉型：使用強制轉型符 if (p1 instanceof Student) { // 為了避免轉型失敗拋出ClassCastException，先用 instanceof 關鍵字判斷 Student student = (Student) p1; // 會存取到子類別的屬性 System.out.println(\u0026#34;age=\u0026#34;+student.age); student.study(); student.sleep(); } } } 輸出結果：\n學生要吃營養的食物 學生要睡飽才會長高 age=1 ==================== age=10 學生認真學習！ 學生要睡飽才會長高 Overload (多載) vs. Override (覆寫) Overload (概念可稱同名方法) 在編譯 (compile) 時期就會去檢查 方法宣告的參數列表 是否符合 多載 的規定 Override 在編譯 (complie) 時期 會先以父類別變數去存取父類別方法來判斷編譯通不通過，直到執行 (run) 時期 若使用父類別變數存取的方法 子類別有覆寫 (多型概念)，則會是在執行時才在heap區去存取子類別覆寫的方法 PS. 編譯時期看左邊、執行時期看右邊\n","permalink":"https://sunwc2023.github.io/blog/abstract/oop/","tags":["Java"],"title":"Java - OOP 物件導向特性"},{"categories":["Practice"],"contents":" 值轉換數字失敗，會拋出NumberFormatException，詳情請看private static Double isNumeric(Object obj) function\n題目 取得一個Object Array，包含不同data types，排除不是數字、不是浮點型的值\n再將剩下的值使用quick sort進行排序(不可使用Arrays.sort())\n/** * @Description * @author sunwc * @Date 2023年3月19日下午10:39:17 * */ public class QuickSort { public static void main(String[] args) { Object[] objArr = {\u0026#34;2\u0026#34;, \u0026#34;0.3\u0026#34;, 38, null, \u0026#34;hello world\u0026#34;, \u0026#34;100\u0026#34;, 9.27, \u0026#34;-133\u0026#34;, \u0026#34;null\u0026#34;}; // 1. 排除任何不是numeric的值 // 2. 使用quick sort 將 numeric array 進行排序 double[] temp = new double[objArr.length]; int k = 0; for (int i = 0; i \u0026lt; objArr.length; i++) { if (isNumeric(objArr[i]) != null) { temp[k++] = isNumeric(objArr[i]); } } // 再copy array是為了排除temp[] null值的空間 double[] result = Arrays.copyOf(temp, k); // 快速排序 quickSort(result, 0, result.length-1); System.out.println(Arrays.toString(result)); } /** * 判斷object array元素是否為數字 * 是數字回傳Double 不是數字回傳null * @Description * @author sunwc * @Date 2023年3月19日下午10:37:26 * @param obj * @return */ private static Double isNumeric(Object obj) { Double result = null; if (obj == null) { return result; } if (obj instanceof String) { String str = (String) obj; try { result = Double.parseDouble(str); } catch (NumberFormatException e) { result = null; } } else if (obj instanceof Integer) { int temp = (int) obj; result = (double) temp; } else if (obj instanceof Double) { result = (double) obj; } return result; } /** * 快速排序法 * @Description * @author sunwc * @Date 2023年3月19日下午10:41:24 * @param array * @param left * @param right */ public static void quickSort(double[] array, int left, int right) { // 快速排序的終止條件就是當left不小於right if (left \u0026gt;= right) { return; } // 取得partition的標準數 double pivot = array[(left+right)/2]; int partitionInx = partition(array, left, right, pivot); quickSort(array, left, partitionInx - 1); quickSort(array, partitionInx, right); } /** * 使左邊的數比partitionInx小，右邊的數比partitionInx大 * @Description * @author sunwc * @Date 2023年3月19日下午9:29:55 * @param array * @param left * @param right * @param pivot * @return */ private static int partition(double[] array, int left, int right, double pivot) { while (left \u0026lt;= right) { // 只要左邊的值小於pivot就繼續往右移直到找到為止 while (array[left] \u0026lt; pivot) { left++; } // 只要右邊的值大於pivot就繼續往左移直到找到為止 while (array[right] \u0026gt; pivot) { right--; } if (left \u0026lt;= right) { // 兩值交換 swap(array, left, right); left++; right--; } } return left; } /** * 兩值交換 * @Description * @author sunwc * @Date 2023年3月19日下午9:33:43 * @param array * @param left * @param right */ private static void swap(double[] array, int left, int right) { double temp = array[left]; array[left] = array[right]; array[right] = temp; } } 輸出結果：\n[-133.0, 0.3, 2.0, 9.27, 38.0, 100.0] 參考來源： Algorithms: Quicksort\n","permalink":"https://sunwc2023.github.io/blog/array/quick-sort/","tags":["Java"],"title":"Java - 陣列快速排序法 Quick Sort"},{"categories":["Practice"],"contents":"public static void main(String[] args) { // 二分搜尋 // 前提：所要搜尋的陣列必須有序 int[] arr = {-98,-34,2,34,54,66,79,105,210,333}; int target = 34; int startInx = 0; int endInx = arr.length-1; boolean flag = true; while (startInx \u0026lt;= endInx) { int middleInx = (endInx - startInx) / 2 + startInx; if (arr[middleInx] == target) { System.out.println(\u0026#34;target=\u0026#34;+ target+\u0026#34;在index=\u0026#34;+middleInx+\u0026#34;找到了！\u0026#34;); flag = false; break; } else if (arr[middleInx] \u0026lt; target) { startInx = middleInx + 1; } else if (arr[middleInx] \u0026gt; target) { endInx = middleInx - 1; } } if (flag) { System.out.println(\u0026#34;很遺憾沒找到\u0026#34;); } } 輸出結果\ntarget=34在index=3找到了！ array中常見的異常(Exception)： 陣列索引越界：ArrayIndexOutOfBoundsException ","permalink":"https://sunwc2023.github.io/blog/array/array-search/","tags":["Java"],"title":"Java - 陣列二分搜尋"},{"categories":["Practice"],"contents":"陣列反轉 public static void main(String[] args) { String[] arr = new String[] {\u0026#34;PP\u0026#34;,\u0026#34;BB\u0026#34;,\u0026#34;MM\u0026#34;,\u0026#34;GG\u0026#34;,\u0026#34;JJ\u0026#34;,\u0026#34;DD\u0026#34;,\u0026#34;MM\u0026#34;}; String temp; // 方式一、交換arr.length/2次 for (int i = 0; i \u0026lt; arr.length/2; i++) { // 定義臨時變數交換 temp = arr[i]; arr[i] = arr[arr.length -i-1]; arr[arr.length -i-1] = temp; } System.out.println(Arrays.toString(arr)); // 方式二、arr[i], arr[j]於陣列兩端進行交換 for (int i = 0, j = arr.length-1;i \u0026lt; j; i++, j--) { temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } System.out.println(Arrays.toString(arr)); // s1中反轉bcd123，在輸出s1 String s1 = \u0026#34;abcd1234\u0026#34;; char[] chars = s1.toCharArray(); for (int i = 1; i \u0026lt; (chars.length)/2; i++) { char temp = chars[i]; chars[i] = chars[chars.length-1-i]; chars[chars.length-1-i] = temp; } System.out.println(new String(chars)); // a321dcb4 } 輸出結果\n[MM, DD, JJ, GG, MM, BB, PP] 字串反轉 public static void main(String[] args) { // 方式一、 String str = \u0026#34;Hello World\u0026#34;; char[] chars = str.toCharArray(); for (int i = 0; i \u0026lt; chars.length/2; i++) { char temp = chars[i]; chars[i] = chars[chars.length -i-1]; chars[chars.length -i-1] = temp; } System.out.println(chars); // 方式二、 StringBuilder sb1 = new StringBuilder(str); sb1.reverse(); System.out.println(sb1); } 輸出結果\ndlroW olleH ","permalink":"https://sunwc2023.github.io/blog/reversion/array-reversion/","tags":["Java"],"title":"Java - 陣列反轉/字串反轉"},{"categories":["Practice"],"contents":"public static void main(String[] args) { for (int i = 2; i \u0026lt;= 100; i++) { boolean flag = true; // 質數是只能被1與自己整除，所以判斷非質數範圍就只能是 2 ~ (i-1) // for (int j = 2; j \u0026lt; i ; j++) { for (int j = 2; j \u0026lt;= Math.sqrt(i) ; j++) { // 優化二、j \u0026lt;= Math.sqrt(i)開根號：對質數的計算提升效率 if (i % j == 0) { // 非質數 flag = false; // 優化一、break對非質數的計算提升效率 break; } } if (flag) { System.out.println(\u0026#34;印出當前質數 : \u0026#34; + i); } } } 輸出結果\n印出當前質數 : 2 印出當前質數 : 3 印出當前質數 : 5 印出當前質數 : 7 印出當前質數 : 11 印出當前質數 : 13 印出當前質數 : 17 印出當前質數 : 19 印出當前質數 : 23 印出當前質數 : 29 印出當前質數 : 31 印出當前質數 : 37 印出當前質數 : 41 印出當前質數 : 43 印出當前質數 : 47 印出當前質數 : 53 印出當前質數 : 59 印出當前質數 : 61 印出當前質數 : 67 印出當前質數 : 71 印出當前質數 : 73 印出當前質數 : 79 印出當前質數 : 83 印出當前質數 : 89 印出當前質數 : 97 ","permalink":"https://sunwc2023.github.io/blog/exmaple/find-prime-number/","tags":["Java"],"title":"Java - 找1-100中所有質數"},{"categories":["Practice"],"contents":" public static void main(String[] args) { /* 內層迴圈每次執行10次 第1行(i=5) 印星號 j=5 第2行(i=4) 印星號 j=4、6 第3行(i=3) 印星號 j=3、5、7 第4行(i=2) 印星號 j=2、4、6、8 第5行(i=1) 印星號 j=1、3、5、7、9 j其餘情況印一個空白 輸出上半部： * * * * * * * * * * * * * * * */ for (int i = 5; i \u0026gt; 0; i--) { // 計算當前是第幾行，第0行即不用找下一個印星號的位置 int line = 5 - i; int nextPosition = 0; for (int j = 1; j \u0026lt; 10; j++) { // 當 內層迴圈 第一次 i == j 的時候，就先去找下一個印*號的位置 // j == nextPosition(下一個印星號的位置)，就印星號 if (line \u0026gt;= 0 \u0026amp;\u0026amp; (j == i || nextPosition == j)) { System.out.print(\u0026#34;*\u0026#34;); if (line \u0026gt; 0) { // 當印出當前星號後，就開始找到再下個印星號的位置 nextPosition = j + 2; // 當line=0，代表當前這行的星號已經印完了 line--; } } else { // 印空白 System.out.print(\u0026#34; \u0026#34;); } } // 換行 System.out.println(); } /* 內層迴圈每次執行7次 第1行(i=5) 印星號 j=8、6、4、2 第2行(i=4) 印星號 j=7、5、3 第3行(i=3) 印星號 j=6、4 第4行(i=2) 印星號 j=5 j其餘情況印一個空白 輸出下半部： * * * * * * * * * * */ for (int i = 5; i \u0026gt; 1; i--) { // 每行開頭先印一個空白 System.out.print(\u0026#34; \u0026#34;); // 計算當前是第幾行，第0行即不用找下一個印星號的位置 int line = i - 2; int nextPosition = 0; for (int j = 8; j \u0026gt; 1; j--) { // 當 內層迴圈 第一次(i+3) == j 的時候，就先去找下一個印*號的位置 // j == nextPosition(下一個印星號的位置)，就印星號 if (line \u0026gt;= 0 \u0026amp;\u0026amp; (j == (i+3) || nextPosition == j)) { System.out.print(\u0026#34;*\u0026#34;); if (line \u0026gt; 0) { // 當印出當前星號後，就開始找到再下個印星號的位置 nextPosition = j - 2; // 當line=0，代表當前這行的星號已經印完了 line--; } } else { // 印空白 System.out.print(\u0026#34; \u0026#34;); } } // 換行 System.out.println(); } } 輸出結果：\n* * * * * * * * * * * * * * * * * * * * * * * * * ","permalink":"https://sunwc2023.github.io/blog/exmaple/print-diamond/","tags":["Java"],"title":"Java - 打印菱形"},{"categories":["Practice"],"contents":" 思路：越下面的 case 被執行的機率越高，因此要從最下面的 case 1 倒著累加至第一個 case 12；由於沒有 break 語句，因此進入某個 case 後，其 case 下面的所有 case 都會被執行\n判斷該年份是否為閏年標準： 可以被4整除，但不可以被100整除 可以被400整除 public static void main(String[] args) { System.out.println(\u0026#34;請輸入年份 : \u0026#34;); Scanner scanner = new Scanner(System.in); int year = scanner.nextInt(); System.out.println(\u0026#34;請輸入月份 : \u0026#34;); int month = scanner.nextInt(); System.out.println(\u0026#34;請輸入日期 : \u0026#34;); int date = scanner.nextInt(); int result = 0; switch (month) { case 12: result += 30; case 11: result += 31; case 10: result += 30; case 9: result += 31; case 8: result += 31; case 7: result += 30; case 6: result += 31; case 5: result += 30; case 4: result += 31; case 3: // 判斷是否為閏年: true:29天 false:28天 int daysOfFeb = ((year % 4 == 0 \u0026amp;\u0026amp; year % 100 != 0) || year % 400 == 0) ? 29 : 28; result += daysOfFeb; case 2: result += 31; case 1: result += date; } System.out.println(month+\u0026#34;月\u0026#34;+date+\u0026#34;日為\u0026#34;+year+\u0026#34;年的第\u0026#34;+result+\u0026#34;天\u0026#34;); } 輸出結果： 請輸入年份 : 2008 請輸入月份 : 3 請輸入日期 : 17 3月17日為2008的第77天 ","permalink":"https://sunwc2023.github.io/blog/exmaple/days-of-year/","tags":["Java"],"title":"Java - Switch-case 計算X年X月X日為第X年第幾天"},{"categories":["Java"],"contents":" 原始random區間為包含0.0且不包含1.0 =\u0026gt; [0.0,1.0)\n我們可以透過公式Math.random*(b-a+1)+a 取得區間[a,b)的一個數字\n例子 public static void main(String[] args) { // 原始random區間為包含0.0且不包含1.0 double random = Math.random();// [0.0,1.0) // [10-99] 如何取得10-99之間的數：公式 - (b-a+1)+a int result = (int)(Math.random() * (99 - 10) + 1 + 10); System.out.println(result); // [888-999] 如何取得888-999之間的數： result = (int)(Math.random() * (999 - 888 + 1) + 888); System.out.println(result); } 例子 陣列長度10放入隨機數[10-99]、且不重複 public static void main(String[] args) { int[] arr = new int[10]; arr[0] = (int) (Math.random() * (99 - 10 + 1) + 10); // 用來判斷隨機數是否重複 Set set = new HashSet\u0026lt;Integer\u0026gt;(); set.add(arr[0]); int max = arr[0]; int min = arr[0]; int sum = 0; int average = 0; for (int i = 1; i \u0026lt; arr.length; i++) { // 隨機數都是兩位數 int random = (int) (Math.random() * (99 - 10 + 1) + 10); if (set.contains(random)) { i--; } else { // 未重複 arr[i] = random; // 計算總和 sum += arr[i]; // 計算最大值 if (max \u0026lt; arr[i]) { max = arr[i]; } // 計算最小值 if (min \u0026gt; arr[i]) { min = arr[i]; } set.add(random); } } System.out.println(\u0026#34;min=\u0026#34;+min+\u0026#34;,max=\u0026#34;+max+\u0026#34;,average=\u0026#34;+sum/arr.length); System.out.println(Arrays.toString(arr)); } ","permalink":"https://sunwc2023.github.io/blog/exmaple/math-random/","tags":["Java"],"title":"Java - Math.random 使用"},{"categories":["Practice"],"contents":"學習目標: 多型 繼承 --多型-- 撰寫一個 Human 類別 代表人 在這裡我們有兩個衍伸類別 Man 與 Woman 他們用不同的規則活著： Man : 吃飯時 印出\u0026#34;好好吃\u0026#34; 睡覺時 印出\u0026#34;zzz\u0026#34; Woman: 吃飯時 印出\u0026#34;Orzz\u0026#34; 睡覺時 印出\u0026#34;:)\u0026#34; (印出代表用System.our.println(...)) 使用者會輸入一個字串 代表 男人與女人 的順序 ( b -\u0026gt; 男 g -\u0026gt; 女 大小寫皆可) 像是: bgGGBgb 代表 男人有3位 女人有4位 照這個順序排列 (左到右) 之後照著順序印出所有人 吃飯 及 睡覺 的情況 需使用多型 沒頭緒的話就讀熟多型的章節 Example Input bgGGBgb output 輸入字串： bgGGBgb 好好吃 Orzz Orzz Orzz 好好吃 Orzz 好好吃 zzz :) :) :) zzz :) zzz 題目來源\n建立Human抽象類別 public abstract class Human { abstract String eating(); abstract String sleeping(); } 建立男人類別繼承Human class Man extends Human { @Override String eating() { return \u0026#34;好好吃\u0026#34;; } @Override String sleeping() { return \u0026#34;zzz\u0026#34;; } } 建立女人類別繼承Human class Woman extends Human { @Override String eating() { return \u0026#34;Orzz\u0026#34;; } @Override String sleeping() { return \u0026#34;:)\u0026#34;; } } 讓使用者輸入字串，最後照著字串順序印出所有人 吃飯 及 睡覺 的情況 mport java.util.ArrayList; import java.util.List; import java.util.Locale; import java.util.Scanner; public abstract class Human { abstract String eating(); abstract String sleeping(); public static void main(String[] args) { System.out.println(\u0026#34;請輸入一個字串 代表 男人與女人 的順序 ( b -\u0026gt; 男 g -\u0026gt; 女 大小寫皆可)\\n\u0026#34; + \u0026#34;像是: bgGGBgb 代表 男人有3位 女人有4位 照這個順序排列 (左到右)\u0026#34;); // 取得使用者的輸入 Scanner scanner = new Scanner(System.in); // 將取得的字串轉英文小寫 String bgString = scanner.next().toLowerCase(Locale.ROOT); printHumanRoutine(bgString); } /** * 照著順序印出所有人 吃飯 及 睡覺 的情況 * @param bgString */ public static void printHumanRoutine(String bgString) { List\u0026lt;Human\u0026gt; humanList = new ArrayList\u0026lt;\u0026gt;(); // 遍歷字串將男人或女人放入human集合 for (int i = 0; i \u0026lt; bgString.length(); i++) { String str = bgString.charAt(i) + \u0026#34;\u0026#34;; Human human = null; if (\u0026#34;b\u0026#34;.equals(str)) { human = new Man(); } else if (\u0026#34;g\u0026#34;.equals(str)) { human = new Woman(); } System.out.println(human.eating()); humanList.add(human); } for (int i = 0; i \u0026lt; humanList.size(); i++) { Human human = humanList.get(i); System.out.println(human.sleeping()); } } } 總結 最後我覺得 水球潘 對於這個範例的解釋太好了，所以我決定放在這裡讓這個觀念好好住在心裡:)\n在這邊 男人跟女人 是 具體的子類別 因為很清楚 這是男人 這是女人 所以稱為\u0026#34;具體\u0026#34; 那人類呢? 人類具體嗎? Human 你不知道他是哪種人 因此稱之為 \u0026#34;抽象\u0026#34;，抽象的類別 就不該把具體的內容打清楚 所以在定義Human的函數時 會不知道要打什麼內容 抽象類別是不可以被new的 因為他是抽象的 抽象類別 可以定義抽象方法 就是只跟程式說 人類會吃飯 會睡覺 但我不說清楚其具體內容 你必須告訴我你是哪個具體子類別 我才知道你 在睡覺跟吃飯時要做什麼 參考來源\n","permalink":"https://sunwc2023.github.io/blog/abstract/abstract-human/","tags":["Java"],"title":"Java - 多型 繼承"},{"categories":["Experience"],"contents":" 有關如何使用 ThreadLocal 確保 Thread-safety，可以參考我的另一篇文章 Java - ThreadLocal 類的使用\n筆者曾經在不了解 ThreadLocal 類的情況下，錯用 ThreadLocal 客製Log物件的工具類，後來理解 ThreadLocal 運作原理後，在這裡特別記錄下來\n客製 LogBox 類 import java.text.SimpleDateFormat; import java.util.Date; import java.util.LinkedList; import java.util.List; public class LogBox { private static final ThreadLocal\u0026lt;LogBox\u0026gt; currentThreadLogBox = new ThreadLocal\u0026lt;\u0026gt;(); private static final ThreadLocal\u0026lt;SimpleDateFormat\u0026gt; currentThreadSDF = new ThreadLocal\u0026lt;\u0026gt;(); private final String title; private final static String timeType = \u0026#34;yyyy-MM-dd HH:mm:ss.SSS\u0026#34;; private final List\u0026lt;String\u0026gt; logMsgList = new LinkedList\u0026lt;\u0026gt;(); public LogBox(String title) { this.title = title; } /** * 日誌訊息層級 */ public enum MessageType { MESSAGE, DEBUG, WARNING, ERROR } /** * 建立當前執行緒logBox * @param title * @return */ public static LogBox createCurrentThreadLogBox(String title) { LogBox logBox = new LogBox(title); currentThreadLogBox.set(logBox); return logBox; } /** * 取得當前執行緒logBox * 當某個request流程跨function時 * 則可以使用同一個logBox * @return */ public static LogBox getCurrentThreadLogBox() { if (currentThreadLogBox.get() == null) { createCurrentThreadLogBox(\u0026#34;title unset\u0026#34;); } return currentThreadLogBox.get(); } /** * 清除當前執行緒LogBox * 清除當前執行緒SimpleDateTimeFormat * 並取得log字串 * @return */ public String removeLogBoxAndGetLog() { removeCurrentThreadSDF(); currentThreadLogBox.remove(); StringBuilder sb = new StringBuilder(); if (logMsgList.size() \u0026gt; 0) { sb.append(\u0026#34;Log Title : \u0026#34;).append(title); logMsgList.forEach(eachLine -\u0026gt; { sb.append(\u0026#34;\\n\u0026#34;).append(\u0026#34;\\t\u0026#34;).append(eachLine); }); } sb.append(\u0026#34;\\n\u0026#34;).append(\u0026#34;=========================================================\u0026#34;); return sb.toString(); } /** * 簡略示意客製添加 info 層級 log 訊息 * @param msg */ public void info(String msg) { SimpleDateFormat simpleDateFormat = currentThreadSDF.get(); String now = simpleDateFormat.format(new Date()); msg = String.format(\u0026#34;[%s] \u0026#39;%s\u0026#39; %s\u0026#34;, MessageType.MESSAGE, now, msg); logMsgList.add(msg); } // 接收 debug、warn、error 等 log 訊息 function...... /** * 建立當前執行緒SimpleDateFormat * @return */ public static SimpleDateFormat createCurrentThreadSDF() { SimpleDateFormat sdf = new SimpleDateFormat(timeType); currentThreadSDF.set(sdf); return sdf; } /** * 取得當前執行緒SimpleDateFormat * @return */ public static SimpleDateFormat getCurrentThreadSDF() { if (currentThreadSDF.get() == null) { createCurrentThreadSDF(); } return currentThreadSDF.get(); } /** * 清除當前執行緒SimpleDateFormat */ public void removeCurrentThreadSDF() { currentThreadSDF.remove(); } } LogBox 類使用情境\n情境一、這個 LogBox 類實際上是可以應用在 Filter interface 透過建立一個客製類實作 Filter 並實現 doFilter 方法，一開始透過 createCurrentThreadLogBox(title) 建立屬於該 request (該執行緒) 的 ThreadLocal\u0026lt;LogBox\u0026gt; 物件，中間還可以從 request 中取得 requestURI、requestParams 並取得 response 等資訊都加入 ThreadLocal\u0026lt;LogBox\u0026gt; ，等程式從controller層回到 doFilter 再 removeLogBoxAndGetLog() 清除當前執行緒 ThreadLocal\u0026lt;LogBox\u0026gt;\n因為有上面提及的這層操作，因此在SpringBoot framework 的 Controller 或 Service 層的 function 中，就只需要getCurrentThreadLogBox() 取得當前執行緒的 LogBox，並將當前API、業務邏輯所需顯示的 log 內容，透過 log.info(\u0026quot;xxxx\u0026quot;), log.error(exeption message),\u0026hellip; 將不同層級訊息加到 LogBox 中\n圖片來源\n情境二、這個 LogBox 類實際上是可以應用在 quartz 排程 透過建立一個客製類繼承 QuartzJobBean 並覆寫 executeInternal 方法，一開始透過 createCurrentThreadLogBox(title) 建立屬於該排程 (該執行緒) 的 ThreadLocal\u0026lt;LogBox\u0026gt; 物件；不過，此方法可能會再存取 ScheduleService 類的方法，因此在 ScheduleService 層就只需要　getCurrentThreadLogBox() 取得當前執行緒的 LogBox ，並添加業務邏輯所需顯示的 log 內容，透過 log.info(\u0026quot;xxxx\u0026quot;), log.error(exeption message),\u0026hellip; 將不同層級訊息加到 LogBox 中，等排程快結束時程式回到 executeInternal 方法，再 removeLogBoxAndGetLog() 清除當前執行緒 ThreadLocal\u0026lt;LogBox\u0026gt;\n筆者在理解 ThreadLocal 後，但是卻在下面例子的當程式走到 callTransferLimitUpPer30Mins()內部時，該 function 的 log 都印不出來；\n原來的寫法： 在 callTransferLimitUpPer30Mins() function 的內部，才 getCurrentThreadLogBox() 取得當前執行緒的 LogBox，最後才發現這個坑是跟 ExecutorService interface 有關；\n改善後的寫法： 將 LogBox 物件當作傳參送到 callTransferLimitUpPer30Mins(logBox) ，才解決了問題\n例子 quartz入口類 @Slf4j @DisallowConcurrentExecution public class RaiseupTransferLimitJob extends QuartzJobBean { @Autowired CancelRaiseupLimitTask cancelRaiseupLimitTask; public static final String TASK_NAME = QuartzTaskNameConstants.raiseupTransferLimt; public static final String PROP_NAME = \u0026#34;quartz.findBeforeSystemTimeLessThan1Day\u0026#34;; public RaiseupTransferLimitJob() { QuartzJobService.descriptionMap.put(TASK_NAME, \u0026#34;re-send raiseupTransferLimit\u0026#34;); QuartzJobService.taskDisplayNameMap.put(TASK_NAME, TASK_NAME); } @Override public void executeInternal(JobExecutionContext jobExecutionContext) { String logTitle = new Exception().getStackTrace()[0].getClassName()+\u0026#34;.\u0026#34;+new Exception().getStackTrace()[0].getMethodName(); LogBox logBox = LogBox.createCurrentThreadLogBox(logTitle); logBox.info(\u0026#34;start running callTransferLimitUpPer30Mins\u0026#34;); try { cancelRaiseupLimitTask.cancelTaskPer60MINS(); } catch (Exception e) { logBox.error(e); } finally { logBox.info(\u0026#34;end run callTransferLimitUpPer30Mins\u0026#34;); String logString = logBox.removeLogBoxAndGetLog(); if (logString != null \u0026amp;\u0026amp; logString.trim().length() \u0026gt; 0) { log.info(logString); } } } } quartz入口類呼叫ScheduleService類方法 public void cancelTaskPer60MINS() throws Exception { LogBox logBox = LogBox.getThreadLocalLogBox(); ExecutorService executor = Executors.newSingleThreadExecutor(); Future\u0026lt;String\u0026gt; future = executor.submit(() -\u0026gt; { // 需求是若排程有timeout情況產生，單一排程至多執行60分鐘\tcallTransferLimitUpPer30Mins(logBox); // 排程業務邏輯 logBox.info(\u0026#34;callTransferLimitUpPer30Mins is completed!\u0026#34;); return \u0026#34;Ready!\u0026#34;; }); try { logBox.info(\u0026#34;Every 60 minutes is started..\u0026#34;); // 設置最大等待時間 logBox.info(future.get(60, TimeUnit.MINUTES)); logBox.info(\u0026#34;Every 60 minutes is finished!\u0026#34;); } catch (TimeoutException e) { // 允許取消正在運行的執行緒——以拋出異常的方式中斷 future.cancel(true); logBox.info(\u0026#34;callTransferLimitUpPer30Mins is terminated!\u0026#34;); } executor.shutdownNow(); logBox.info(\u0026#34;cancelTaskPer60MINS shutdown now\u0026#34;); } 圖片參考\n總結 關於 log 印不出來，我的想法是 原來在主執行緒的 LogBox ，與 Executors 建立的單一執行緒裡的 LogBox 彼此之間是不互相影響的；但是只有主執行緒的 LogBox 可以印出 log (因為最後有 removeLogBoxAndGetLog() )，所以我就必須將主執行緒產生出來的 LogBox 當作傳參送入 callTransferLimitUpPer30Mins(logBox)，這樣就沒問題啦！\n","permalink":"https://sunwc2023.github.io/blog/thread/thread-local-example/","tags":["Java"],"title":"Java - ThreadLocal 實際應用"},{"categories":["Java"],"contents":" 有關在實際工作上使用到 ThreadLocal 的例子，可以參考我的另一篇文章 Java - ThreadLocal 實際應用\nThreadLocal 實現原理 ThreadLocal 從字面義直翻，就是執行緒 (Thread) 的局部變數，是每一個執行緒所單獨持有，其他執行緒不能對其進行存取\nThreadLocal 支持泛型，也就是支持 value 是可以設置的，像是 ThreadLocal\u0026lt;Integer\u0026gt; 就是設置 value 為 Integer 類型\n每個執行緒會有自己一份 ThreadLocalMap 副本，去儲存這個執行緒自己想存放的 ThreadLocal\u0026lt;T\u0026gt; 變數們，ThreadLocalMap 副本內部儲存的是一個 key-value 對，其中 key 是某個 ThreadLocal\u0026lt;T\u0026gt; 物件實例 ， value 就是這個執行緒、該 ThreadLocal\u0026lt;T\u0026gt; 物件實例 set 的值，所以對一個執行緒來說，一個 ThreadLocal\u0026lt;T\u0026gt; 只能存一個值，而一個執行緒可以存放多個 ThrealLocal\u0026lt;T\u0026gt;\nJDK Souce code public class Thread implements Runnable { // Thread 類裡的threadLocals 存放此執行緒的專有 ThreadLocalMap 副本 ThreadLocal.ThreadLocalMap threadLocals = null; } public class ThreadLocal\u0026lt;T\u0026gt; { // 根據執行緒，取得那個執行緒自己的 ThreadLocalMap ThreadLocalMap getMap(Thread t) { return t.threadLocals; } static class ThreadLocalMap { // ThreadLocalMap 的 key 是使用 \u0026#34;弱引用\u0026#34; 的 ThreadLocal\u0026lt;T\u0026gt; static class Entry extends WeakReference\u0026lt;ThreadLocal\u0026lt;?\u0026gt;\u0026gt; { Object value; // ThreadLocalMap 中的 key 就是 ThreadLocal\u0026lt;T\u0026gt;，value 就是設置的值 Entry(ThreadLocal\u0026lt;?\u0026gt; k, Object v) { super(k); value = v; } } } public T get() { // 取得當前執行緒 Thread t = Thread.currentThread(); // 每個執行緒 都有一個自己的 ThreadLocalMap // ThreadLocalMap 裡就保存著所有的ThreadLocal\u0026lt;T\u0026gt;變數 ThreadLocalMap map = getMap(t); if (map != null) { // ThreadLocalMap 的 key 就是當前 ThreadLocal\u0026lt;T\u0026gt; 物件實例 // 多個 ThreadLocal\u0026lt;T\u0026gt; 變數都是放在這個 map 中的 ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) // 從 map 裡取出來的值就是我們需要的這個 ThreadLocal\u0026lt;T\u0026gt; 變數 T result = (T)e.value; return result; } } // 如果 map 沒有初始化，那麼在這裡初始化一下 return setInitialValue(); } public void set(T value) { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) { map.set(this, value); } else { createMap(t, value); } } public void remove() { ThreadLocalMap map = getMap(Thread.currentThread()); if (map != null) { map.remove(this); } } } ThreadLocal 常用方法 set(x) : 設置此執行緒的想要放的值 x get() : 取得此執行緒當初存放的值，如果沒有存放過則返回 null remove() : 刪除此執行緒的 key-value 對，也就是如果先執行 remove 再執行 get，會返回 null 可以創建多個 ThreadLocal\u0026lt;T\u0026gt; 物件，對每個 ThreadLocal\u0026lt;T\u0026gt; 都設置不同的值\n像是以下的例子，在 main 執行緒中的 ThreadLocalMap ，就有兩個 key-value 的映射，userIdThreadLocal -\u0026gt; 100、userNameThreadLocal -\u0026gt; hello 例子 public class Main { public static void main(String[] args){ ThreadLocal\u0026lt;Integer\u0026gt; userIdThreadLocal = new ThreadLocal\u0026lt;\u0026gt;(); ThreadLocal\u0026lt;String\u0026gt; userNameThreacLocal = new ThreadLocal\u0026lt;\u0026gt;(); userId.set(100); userName.set(\u0026#34;hello\u0026#34;); } } ThreadLocal 存在內存洩露 這邊不多去探討這個議題，內存洩漏是可以避免的，只要當前執行緒要結束前記得即時的remove()，也就是是使得 ThreadLocalMap 中不要存在這個 key-value 對，這樣才能確保 GC 能正確回收\n以下有更多的文章，仔細地談論 ThreadLocal 內存洩漏問題 與 Java 自身解決的方式，但都不治本！還是當前執行緒用完 ThreadLocal 記得呼叫remove()，才是確保線程安全的根本之道！\n參考資料：\nJava - ThreadLocal 類的使用\nThreadLocal使用與原理\nSimpleDateFormat 非線程安全？ 由於 SimpleDateFormat 本身非 synchronized ，所以如果在不同執行緒使用同一個 SimpleDateFormat ，就會導致輸出的時間異常，請看以下的例子\n例子 public static void main(String[] args) { DateFormat sdf = new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); Date date1 = new Date(1614820308016L); Date date2 = new Date(1615820309016L); System.out.println(\u0026#34;初始定義時間1 : \u0026#34; + sdf.format(date1)); System.out.println(\u0026#34;初始定義時間2 : \u0026#34; + sdf.format(date2)); Thread t1 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 100; i++) { String dateStr = sdf.format(date1); if (!\u0026#34;2021-03-04 09:11:48\u0026#34;.equals(dateStr)) { System.out.println(Thread.currentThread().getName() + \u0026#34;異常時間為 : \u0026#34; + dateStr); } } }, \u0026#34;thread 1\u0026#34;); Thread t2 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 100; i++) { String dateStr = sdf.format(date2); if (!\u0026#34;2021-03-15 22:58:29\u0026#34;.equals(dateStr)) { System.out.println(Thread.currentThread().getName() + \u0026#34;異常時間為 : \u0026#34; + dateStr); } } }, \u0026#34;Thread 2\u0026#34;); t1.start(); t2.start(); try { t1.join(); t2.join(); } catch (InterruptedException e) { e.printStackTrace(); } } 輸出異常：(Thread2 輸出了 Thread1 的時間)\n初始定義時間1 : 2021-03-04 09:11:48 初始定義時間2 : 2021-03-15 22:58:29 Thread 2異常時間為 : 2021-03-04 09:11:48 但是， ThreadLocal 可以解決非線程安全的問題，只要在各自的執行緒，持有各自的ThreadLocal\u0026lt;DateFormat\u0026gt;，就不會有問題了，請看下面的例子\npublic static void main(String[] args) { DateFormat sdf = new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); Date date1 = new Date(1614820308016L); Date date2 = new Date(1615820309016L); System.out.println(\u0026#34;初始定義時間1 : \u0026#34; + sdf.format(date1)); System.out.println(\u0026#34;初始定義時間2 : \u0026#34; + sdf.format(date2)); Thread t1 = new Thread(() -\u0026gt; { ThreadLocal\u0026lt;DateFormat\u0026gt; currentSDF = new ThreadLocal\u0026lt;\u0026gt;(); DateFormat df1 = new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); currentSDF.set(df1); DateFormat dateFormat1 = currentSDF.get(); for (int i = 0; i \u0026lt; 100; i++) { String dateStr = dateFormat1.format(date1); if (!\u0026#34;2021-03-04 09:11:48\u0026#34;.equals(dateStr)) { System.out.println(Thread.currentThread().getName() + \u0026#34;異常時間為 : \u0026#34; + dateStr); } } currentSDF.remove(); }, \u0026#34;thread 1\u0026#34;); Thread t2 = new Thread(() -\u0026gt; { ThreadLocal\u0026lt;DateFormat\u0026gt; currentSDF = new ThreadLocal\u0026lt;\u0026gt;(); DateFormat df2 = new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); currentSDF.set(df2); DateFormat dateFormat2 = currentSDF.get(); for (int i = 0; i \u0026lt; 100; i++) { String dateStr = dateFormat2.format(date2); if (!\u0026#34;2021-03-15 22:58:29\u0026#34;.equals(dateStr)) { System.out.println(Thread.currentThread().getName() + \u0026#34;異常時間為 : \u0026#34; + dateStr); } } currentSDF.remove(); }, \u0026#34;Thread 2\u0026#34;); t1.start(); t2.start(); try { t1.join(); t2.join(); } catch (InterruptedException e) { e.printStackTrace(); } } 輸出正常：\n初始定義時間1 : 2021-03-04 09:11:48 初始定義時間2 : 2021-03-15 22:58:29 參考來源\n","permalink":"https://sunwc2023.github.io/blog/thread/thread-local/","tags":["Java"],"title":"Java - ThreadLocal 類的使用"}]