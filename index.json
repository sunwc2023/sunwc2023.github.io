[{"categories":["Practice"],"contents":"/** * 題目：取得一個Object Array，包含不同data types，排除不是數字、不是浮點型的值 * 再將剩下的值使用quick sort進行排序 * @Description * @author sunwc * @Date 2023年3月19日下午10:39:17 * */ public class QuickSort { public static void main(String[] args) { Object[] objArr = {\u0026#34;2\u0026#34;, \u0026#34;0.3\u0026#34;, 38, null, \u0026#34;hello world\u0026#34;, \u0026#34;100\u0026#34;, 9.27, \u0026#34;-133\u0026#34;, \u0026#34;null\u0026#34;}; // 1. 排除任何不是numeric的值 // 2. 使用quick sort 將 numeric array 進行排序 double[] temp = new double[objArr.length]; int k = 0; for (int i = 0; i \u0026lt; objArr.length; i++) { if (isNumeric(objArr[i]) != null) { temp[k++] = isNumeric(objArr[i]); } } // 再copy array是為了排除temp[] null值的空間 double[] result = Arrays.copyOf(temp, k); // 快速排序 quickSort(result, 0, result.length-1); System.out.println(Arrays.toString(result)); } /** * 判斷object array元素是否為數字 * 是數字回傳Double 不是數字回傳null * @Description * @author sunwc * @Date 2023年3月19日下午10:37:26 * @param obj * @return */ private static Double isNumeric(Object obj) { Double result = null; if (obj == null) { return result; } if (obj instanceof String) { String str = (String) obj; try { result = Double.parseDouble(str); } catch (NumberFormatException e) { result = null; } } else if (obj instanceof Integer) { int temp = (int) obj; result = (double) temp; } else if (obj instanceof Double) { result = (double) obj; } return result; } /** * 快速排序法 * @Description * @author sunwc * @Date 2023年3月19日下午10:41:24 * @param array * @param left * @param right */ public static void quickSort(double[] array, int left, int right) { // 快速排序的終止條件就是當left不小於right if (left \u0026gt;= right) { return; } // 進行partition的標準數 double pivot = array[(left+right)/2]; int partitionInx = partition(array, left, right, pivot); quickSort(array, left, partitionInx - 1); quickSort(array, partitionInx, right); } /** * 使左邊的數比partitionInx小，右邊的數比partitionInx大 * @Description * @author sunwc * @Date 2023年3月19日下午9:29:55 * @param array * @param left * @param right * @param pivot * @return */ private static int partition(double[] array, int left, int right, double pivot) { while (left \u0026lt;= right) { // 只要左邊的值小於pivot就繼續往右移直到找到為止 while (array[left] \u0026lt; pivot) { left++; } // 只要右邊的值大於pivot就繼續往左移直到找到為止 while (array[right] \u0026gt; pivot) { right--; } if (left \u0026lt;= right) { // 兩值交換 swap(array, left, right); left++; right--; } } return left; } /** * 兩值交換 * @Description * @author sunwc * @Date 2023年3月19日下午9:33:43 * @param array * @param left * @param right */ private static void swap(double[] array, int left, int right) { double temp = array[left]; array[left] = array[right]; array[right] = temp; } } 輸出結果：\n[-133.0, 0.3, 2.0, 9.27, 38.0, 100.0] ","permalink":"https://sunwc2023.github.io/blog/quick-sort/","tags":["Java"],"title":"Java - 陣列快速排序法 Quick Sort"},{"categories":["Practice"],"contents":"public static void main(String[] args) { // 二分搜尋 // 前提：所要搜尋的陣列必須有序 int[] arr = {-98,-34,2,34,54,66,79,105,210,333}; int target = 34; int startInx = 0; int endInx = arr.length-1; boolean flag = true; while (startInx \u0026lt;= endInx) { int middleInx = (endInx - startInx) / 2 + startInx; if (arr[middleInx] == target) { System.out.println(\u0026#34;target=\u0026#34;+ target+\u0026#34;在index=\u0026#34;+middleInx+\u0026#34;找到了！\u0026#34;); flag = false; break; } else if (arr[middleInx] \u0026lt; target) { startInx = middleInx + 1; } else if (arr[middleInx] \u0026gt; target) { endInx = middleInx - 1; } } if (flag) { System.out.println(\u0026#34;很遺憾沒找到\u0026#34;); } } 輸出結果\ntarget=34在index=3找到了！ ","permalink":"https://sunwc2023.github.io/blog/array-search/","tags":["Java"],"title":"Java - 陣列二分搜尋"},{"categories":["Practice"],"contents":" 陣列反轉 public static void main(String[] args) { String[] arr = new String[] {\u0026#34;PP\u0026#34;,\u0026#34;BB\u0026#34;,\u0026#34;MM\u0026#34;,\u0026#34;GG\u0026#34;,\u0026#34;JJ\u0026#34;,\u0026#34;DD\u0026#34;,\u0026#34;MM\u0026#34;}; String temp; // 方式一、交換arr.length/2次 for (int i = 0; i \u0026lt; arr.length/2; i++) { // 定義臨時變數交換 temp = arr[i]; arr[i] = arr[arr.length -i-1]; arr[arr.length -i-1] = temp; } System.out.println(Arrays.toString(arr)); // 方式二、arr[i], arr[j]於陣列兩端進行交換 for (int i = 0, j = arr.length-1;i \u0026lt; j; i++, j--) { temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } System.out.println(Arrays.toString(arr)); } 輸出結果\n[MM, DD, JJ, GG, MM, BB, PP] 字串反轉 public static void main(String[] args) { String str = \u0026#34;Hello World\u0026#34;; char[] chars = str.toCharArray(); for (int i = 0; i \u0026lt; chars.length/2; i++) { char temp = chars[i]; chars[i] = chars[chars.length -i-1]; chars[chars.length -i-1] = temp; } System.out.println(chars); } 輸出結果\ndlroW olleH ","permalink":"https://sunwc2023.github.io/blog/array-reversion/","tags":["Java"],"title":"Java - 陣列反轉/字串反轉"},{"categories":["Practice"],"contents":"public static void main(String[] args) { for (int i = 2; i \u0026lt;= 100; i++) { boolean flag = true; // 質數是只能被1與自己整除，所以判斷非質數範圍就只能是 2 ~ (i-1) // for (int j = 2; j \u0026lt; i ; j++) { for (int j = 2; j \u0026lt;= Math.sqrt(i) ; j++) { // 優化二、j \u0026lt;= Math.sqrt(i)開根號：對質數的計算提升效率 if (i % j == 0) { // 非質數 flag = false; // 優化一、break對非質數的計算提升效率 break; } } if (flag) { System.out.println(\u0026#34;印出當前質數 : \u0026#34; + i); } } } 輸出結果\n印出當前質數 : 2 印出當前質數 : 3 印出當前質數 : 5 印出當前質數 : 7 印出當前質數 : 11 印出當前質數 : 13 印出當前質數 : 17 印出當前質數 : 19 印出當前質數 : 23 印出當前質數 : 29 印出當前質數 : 31 印出當前質數 : 37 印出當前質數 : 41 印出當前質數 : 43 印出當前質數 : 47 印出當前質數 : 53 印出當前質數 : 59 印出當前質數 : 61 印出當前質數 : 67 印出當前質數 : 71 印出當前質數 : 73 印出當前質數 : 79 印出當前質數 : 83 印出當前質數 : 89 印出當前質數 : 97 ","permalink":"https://sunwc2023.github.io/blog/find-prime-number/","tags":["Java"],"title":"Java - 找1-100中所有質數"},{"categories":["Practice"],"contents":" public static void main(String[] args) { /* 內層迴圈每次執行10次 第1行(i=5) 印星號 j=5 第2行(i=4) 印星號 j=4、6 第3行(i=3) 印星號 j=3、5、7 第4行(i=2) 印星號 j=2、4、6、8 第5行(i=1) 印星號 j=1、3、5、7、9 j其餘情況印一個空白 輸出上半部： * * * * * * * * * * * * * * * */ for (int i = 5; i \u0026gt; 0; i--) { // 計算當前是第幾行，第0行即不用找下一個印星號的位置 int line = 5 - i; int nextPosition = 0; for (int j = 1; j \u0026lt; 10; j++) { // 當 內層迴圈 第一次 i == j 的時候，就先去找下一個印*號的位置 // j == nextPosition(下一個印星號的位置)，就印星號 if (line \u0026gt;= 0 \u0026amp;\u0026amp; (j == i || nextPosition == j)) { System.out.print(\u0026#34;*\u0026#34;); if (line \u0026gt; 0) { // 當印出當前星號後，就開始找到再下個印星號的位置 nextPosition = j + 2; // 當line=0，代表當前這行的星號已經印完了 line--; } } else { // 印空白 System.out.print(\u0026#34; \u0026#34;); } } // 換行 System.out.println(); } /* 內層迴圈每次執行7次 第1行(i=5) 印星號 j=8、6、4、2 第2行(i=4) 印星號 j=7、5、3 第3行(i=3) 印星號 j=6、4 第4行(i=2) 印星號 j=5 j其餘情況印一個空白 輸出下半部： * * * * * * * * * * */ for (int i = 5; i \u0026gt; 1; i--) { // 每行開頭先印一個空白 System.out.print(\u0026#34; \u0026#34;); // 計算當前是第幾行，第0行即不用找下一個印星號的位置 int line = i - 2; int nextPosition = 0; for (int j = 8; j \u0026gt; 1; j--) { // 當 內層迴圈 第一次(i+3) == j 的時候，就先去找下一個印*號的位置 // j == nextPosition(下一個印星號的位置)，就印星號 if (line \u0026gt;= 0 \u0026amp;\u0026amp; (j == (i+3) || nextPosition == j)) { System.out.print(\u0026#34;*\u0026#34;); if (line \u0026gt; 0) { // 當印出當前星號後，就開始找到再下個印星號的位置 nextPosition = j - 2; // 當line=0，代表當前這行的星號已經印完了 line--; } } else { // 印空白 System.out.print(\u0026#34; \u0026#34;); } } // 換行 System.out.println(); } } 輸出結果：\n* * * * * * * * * * * * * * * * * * * * * * * * * ","permalink":"https://sunwc2023.github.io/blog/print-diamond/","tags":["Java"],"title":"Java - 打印菱形"},{"categories":["Practice"],"contents":" 思路：越下面的 case 被執行的機率越高，因此要從最下面的 case 1 倒著累加至第一個 case 12；由於沒有 break 語句，因此進入某個 case 後，其 case 下面的所有 case 都會被執行\n判斷該年份是否為閏年標準： 可以被4整除，但不可以被100整除 可以被400整除 public static void main(String[] args) { System.out.println(\u0026#34;請輸入年份 : \u0026#34;); Scanner scanner = new Scanner(System.in); int year = scanner.nextInt(); System.out.println(\u0026#34;請輸入月份 : \u0026#34;); int month = scanner.nextInt(); System.out.println(\u0026#34;請輸入日期 : \u0026#34;); int date = scanner.nextInt(); int result = 0; switch (month) { case 12: result += 30; case 11: result += 31; case 10: result += 30; case 9: result += 31; case 8: result += 31; case 7: result += 30; case 6: result += 31; case 5: result += 30; case 4: result += 31; case 3: // 判斷是否為閏年: true:29天 false:28天 int daysOfFeb = ((year % 4 == 0 \u0026amp;\u0026amp; year % 100 != 0) || year % 400 == 0) ? 29 : 28; result += daysOfFeb; case 2: result += 31; case 1: result += date; } System.out.println(month+\u0026#34;月\u0026#34;+date+\u0026#34;日為\u0026#34;+year+\u0026#34;年的第\u0026#34;+result+\u0026#34;天\u0026#34;); } 輸出結果： 請輸入年份 : 2008 請輸入月份 : 3 請輸入日期 : 17 3月17日為2008的第77天 ","permalink":"https://sunwc2023.github.io/blog/days-of-year/","tags":["Java"],"title":"Java - Switch-case 計算X年X月X日為第X年第幾天"},{"categories":["Java"],"contents":" 原始random區間為包含0.0且不包含1.0 =\u0026gt; [0.0,1.0)\n我們可以透過公式Math.random*(b-a+1)+a 取得區間[a,b)的一個數字\npublic static void main(String[] args) { // 原始random區間為包含0.0且不包含1.0 double random = Math.random();// [0.0,1.0) // [10-99] 如何取得10-99之間的數：公式 - (b-a+1)+a int result = (int)(Math.random() * (99 - 10) + 1 + 10); System.out.println(result); // [888-999] 如何取得888-999之間的數： result = (int)(Math.random() * (999 - 888 + 1) + 888); System.out.println(result); } 陣列長度10放入隨機數[10-99]、且不重複 public static void main(String[] args) { int[] arr = new int[10]; arr[0] = (int) (Math.random() * (99 - 10 + 1) + 10); // 用來判斷隨機數是否重複 Set set = new HashSet\u0026lt;Integer\u0026gt;(); set.add(arr[0]); int max = arr[0]; int min = arr[0]; int sum = 0; int average = 0; for (int i = 1; i \u0026lt; arr.length; i++) { // 隨機數都是兩位數 int random = (int) (Math.random() * (99 - 10 + 1) + 10); if (set.contains(random)) { i--; } else { // 未重複 arr[i] = random; // 計算總和 sum += arr[i]; // 計算最大值 if (max \u0026lt; arr[i]) { max = arr[i]; } // 計算最小值 if (min \u0026gt; arr[i]) { min = arr[i]; } set.add(random); } } System.out.println(\u0026#34;min=\u0026#34;+min+\u0026#34;,max=\u0026#34;+max+\u0026#34;,average=\u0026#34;+sum/arr.length); System.out.println(Arrays.toString(arr)); } ","permalink":"https://sunwc2023.github.io/blog/math-random/","tags":["Java"],"title":"Java - Math.random 使用"},{"categories":["Practice"],"contents":"學習目標: 多型 繼承 --多型-- 撰寫一個 Human 類別 代表人 在這裡我們有兩個衍伸類別 Man 與 Woman 他們用不同的規則活著： Man : 吃飯時 印出\u0026#34;好好吃\u0026#34; 睡覺時 印出\u0026#34;zzz\u0026#34; Woman: 吃飯時 印出\u0026#34;Orzz\u0026#34; 睡覺時 印出\u0026#34;:)\u0026#34; (印出代表用System.our.println(...)) 使用者會輸入一個字串 代表 男人與女人 的順序 ( b -\u0026gt; 男 g -\u0026gt; 女 大小寫皆可) 像是: bgGGBgb 代表 男人有3位 女人有4位 照這個順序排列 (左到右) 之後照著順序印出所有人 吃飯 及 睡覺 的情況 需使用多型 沒頭緒的話就讀熟多型的章節 Example Input bgGGBgb output 輸入字串： bgGGBgb 好好吃 Orzz Orzz Orzz 好好吃 Orzz 好好吃 zzz :) :) :) zzz :) zzz 題目來源\n建立Human抽象類別 public abstract class Human { abstract String eating(); abstract String sleeping(); } 建立男人類別繼承Human class Man extends Human { @Override String eating() { return \u0026#34;好好吃\u0026#34;; } @Override String sleeping() { return \u0026#34;zzz\u0026#34;; } } 建立女人類別繼承Human class Woman extends Human { @Override String eating() { return \u0026#34;Orzz\u0026#34;; } @Override String sleeping() { return \u0026#34;:)\u0026#34;; } } 讓使用者輸入字串，最後照著字串順序印出所有人 吃飯 及 睡覺 的情況 mport java.util.LinkedList; import java.util.List; import java.util.Locale; import java.util.Scanner; public abstract class Human { abstract String eating(); abstract String sleeping(); public static void main(String[] args) { System.out.println(\u0026#34;請輸入一個字串 代表 男人與女人 的順序 ( b -\u0026gt; 男 g -\u0026gt; 女 大小寫皆可)\\n\u0026#34; + \u0026#34;像是: bgGGBgb 代表 男人有3位 女人有4位 照這個順序排列 (左到右)\u0026#34;); // 取得使用者的輸入 Scanner scanner = new Scanner(System.in); // 將取得的字串轉英文小寫 String bgString = scanner.next().toLowerCase(Locale.ROOT); printHumanRoutine(bgString); } /** * 照著順序印出所有人 吃飯 及 睡覺 的情況 * @param bgString */ public static void printHumanRoutine(String bgString) { List\u0026lt;Human\u0026gt; humanList = new LinkedList\u0026lt;\u0026gt;(); // 遍歷字串將男人或女人放入human集合 for (int i = 0; i \u0026lt; bgString.length(); i++) { String str = bgString.charAt(i) + \u0026#34;\u0026#34;; Human human = null; if (\u0026#34;b\u0026#34;.equals(str)) { human = new Man(); } else if (\u0026#34;g\u0026#34;.equals(str)) { human = new Woman(); } System.out.println(human.eating()); humanList.add(human); } for (int i = 0; i \u0026lt; humanList.size(); i++) { Human human = humanList.get(i); System.out.println(human.sleeping()); } } } 結論 最後我覺得 水球潘 對於這個範例的解釋太好了，所以我決定放在這裡讓這個觀念好好住在心裡:)\n在這邊 男人跟女人 是 具體的子類別 因為很清楚 這是男人 這是女人 所以稱為\u0026#34;具體\u0026#34; 那人類呢? 人類具體嗎? Human 你不知道他是哪種人 因此稱之為 \u0026#34;抽象\u0026#34;，抽象的類別 就不該把具體的內容打清楚 所以在定義Human的函數時 會不知道要打什麼內容 抽象類別是不可以被new的 因為他是抽象的 抽象類別 可以定義抽象方法 就是只跟程式說 人類會吃飯 會睡覺 但我不說清楚其具體內容 你必須告訴我你是哪個具體子類別 我才知道你 在睡覺跟吃飯時要做什麼 參考來源\n","permalink":"https://sunwc2023.github.io/blog/abstract-human/","tags":["Java"],"title":"Java - 多型 繼承"},{"categories":["Experience"],"contents":" 有關如何使用 ThreadLocal 確保 Thread-safety，可以參考我的另一篇文章 Java - ThreadLocal 類的使用\n筆者曾經在不了解 ThreadLocal 類的情況下，錯用 ThreadLocal 客製Log物件的工具類，後來理解 ThreadLocal 運作原理後，在這裡特別記錄下來\n客製 LogBox 類 import java.text.SimpleDateFormat; import java.util.Date; import java.util.LinkedList; import java.util.List; public class LogBox { private static final ThreadLocal\u0026lt;LogBox\u0026gt; currentThreadLogBox = new ThreadLocal\u0026lt;\u0026gt;(); private static final ThreadLocal\u0026lt;SimpleDateFormat\u0026gt; currentThreadSDF = new ThreadLocal\u0026lt;\u0026gt;(); private final String title; private final static String timeType = \u0026#34;yyyy-MM-dd HH:mm:ss.SSS\u0026#34;; private final List\u0026lt;String\u0026gt; logMsgList = new LinkedList\u0026lt;\u0026gt;(); public LogBox(String title) { this.title = title; } /** * 日誌訊息層級 */ public enum MessageType { MESSAGE, DEBUG, WARNING, ERROR } /** * 建立當前執行緒logBox * @param title * @return */ public static LogBox createCurrentThreadLogBox(String title) { LogBox logBox = new LogBox(title); currentThreadLogBox.set(logBox); return logBox; } /** * 取得當前執行緒logBox * 當某個request流程跨function時 * 則可以使用同一個logBox * @return */ public static LogBox getCurrentThreadLogBox() { if (currentThreadLogBox.get() == null) { createCurrentThreadLogBox(\u0026#34;title unset\u0026#34;); } return currentThreadLogBox.get(); } /** * 清除當前執行緒LogBox * 清除當前執行緒SimpleDateTimeFormat * 並取得log字串 * @return */ public String removeLogBoxAndGetLog() { removeCurrentThreadSDF(); currentThreadLogBox.remove(); StringBuilder sb = new StringBuilder(); if (logMsgList.size() \u0026gt; 0) { sb.append(\u0026#34;Log Title : \u0026#34;).append(title); logMsgList.forEach(eachLine -\u0026gt; { sb.append(\u0026#34;\\n\u0026#34;).append(\u0026#34;\\t\u0026#34;).append(eachLine); }); } sb.append(\u0026#34;\\n\u0026#34;).append(\u0026#34;=========================================================\u0026#34;); return sb.toString(); } /** * 簡略示意客製添加 info 層級 log 訊息 * @param msg */ public void info(String msg) { SimpleDateFormat simpleDateFormat = currentThreadSDF.get(); String now = simpleDateFormat.format(new Date()); msg = String.format(\u0026#34;[%s] \u0026#39;%s\u0026#39; %s\u0026#34;, MessageType.MESSAGE, now, msg); logMsgList.add(msg); } // 接收 debug、warn、error 等 log 訊息 function...... /** * 建立當前執行緒SimpleDateFormat * @return */ public static SimpleDateFormat createCurrentThreadSDF() { SimpleDateFormat sdf = new SimpleDateFormat(timeType); currentThreadSDF.set(sdf); return sdf; } /** * 取得當前執行緒SimpleDateFormat * @return */ public static SimpleDateFormat getCurrentThreadSDF() { if (currentThreadSDF.get() == null) { createCurrentThreadSDF(); } return currentThreadSDF.get(); } /** * 清除當前執行緒SimpleDateFormat */ public void removeCurrentThreadSDF() { currentThreadSDF.remove(); } } LogBox 類使用情境 情境一、這個 LogBox 類實際上是可以應用在 Filter interface\n透過建立一個客製類實作 Filter 並實現 doFilter 方法，一開始透過 createCurrentThreadLogBox(title) 建立屬於該 request (該執行緒) 的 ThreadLocal\u0026lt;LogBox\u0026gt; 物件，中間還可以從 request 中取得 requestURI、requestParams 並取得 response 等資訊都加入 ThreadLocal\u0026lt;LogBox\u0026gt; ，等程式從controller層回到 doFilter 再 removeLogBoxAndGetLog() 清除當前執行緒 ThreadLocal\u0026lt;LogBox\u0026gt;\n因為有上面提及的這層操作，因此在SpringBoot framework 的 Controller 或 Service 層的 function 中，就只需要getCurrentThreadLogBox() 取得當前執行緒的 LogBox，並將當前API、業務邏輯所需顯示的 log 內容，透過 log.info(\u0026quot;xxxx\u0026quot;), log.error(exeption message),\u0026hellip; 將不同層級訊息加到 LogBox 中\n圖片來源\n情境二、這個 LogBox 類實際上是可以應用在 quartz 排程\n透過建立一個客製類繼承 QuartzJobBean 並覆寫 executeInternal 方法，一開始透過 createCurrentThreadLogBox(title) 建立屬於該排程 (該執行緒) 的 ThreadLocal\u0026lt;LogBox\u0026gt; 物件；不過，此方法可能會再存取 ScheduleService 類的方法，因此在 ScheduleService 層就只需要　getCurrentThreadLogBox() 取得當前執行緒的 LogBox ，並添加業務邏輯所需顯示的 log 內容，透過 log.info(\u0026quot;xxxx\u0026quot;), log.error(exeption message),\u0026hellip; 將不同層級訊息加到 LogBox 中，等排程快結束時程式回到 executeInternal 方法，再 removeLogBoxAndGetLog() 清除當前執行緒 ThreadLocal\u0026lt;LogBox\u0026gt;\n筆者在理解 ThreadLocal 後，但是卻在下面例子的當程式走到 callTransferLimitUpPer30Mins()內部時，該 function 的 log 都印不出來；\n原來的寫法： 在 callTransferLimitUpPer30Mins() function 的內部，才 getCurrentThreadLogBox() 取得當前執行緒的 LogBox，最後才發現這個坑是跟 ExecutorService interface 有關；\n改善後的寫法： 將 LogBox 物件當作傳參送到 callTransferLimitUpPer30Mins(logBox) ，才解決了問題，請看以下例子：\n@Slf4j @DisallowConcurrentExecution public class RaiseupTransferLimitJob extends QuartzJobBean { @Autowired CancelRaiseupLimitTask cancelRaiseupLimitTask; public static final String TASK_NAME = QuartzTaskNameConstants.raiseupTransferLimt; public static final String PROP_NAME = \u0026#34;quartz.findBeforeSystemTimeLessThan1Day\u0026#34;; public RaiseupTransferLimitJob() { QuartzJobService.descriptionMap.put(TASK_NAME, \u0026#34;re-send raiseupTransferLimit\u0026#34;); QuartzJobService.taskDisplayNameMap.put(TASK_NAME, TASK_NAME); } @Override public void executeInternal(JobExecutionContext jobExecutionContext) { String logTitle = new Exception().getStackTrace()[0].getClassName()+\u0026#34;.\u0026#34;+new Exception().getStackTrace()[0].getMethodName(); LogBox logBox = LogBox.createCurrentThreadLogBox(logTitle); logBox.info(\u0026#34;start running callTransferLimitUpPer30Mins\u0026#34;); try { cancelRaiseupLimitTask.cancelTaskPer60MINS(); } catch (Exception e) { logBox.error(e); } finally { logBox.info(\u0026#34;end run callTransferLimitUpPer30Mins\u0026#34;); String logString = logBox.removeLogBoxAndGetLog(); if (logString != null \u0026amp;\u0026amp; logString.trim().length() \u0026gt; 0) { log.info(logString); } } } } public void cancelTaskPer60MINS() throws Exception { LogBox logBox = LogBox.getThreadLocalLogBox(); ExecutorService executor = Executors.newSingleThreadExecutor(); Future\u0026lt;String\u0026gt; future = executor.submit(() -\u0026gt; { // 需求是若排程有timeout情況產生，單一排程至多執行60分鐘\tcallTransferLimitUpPer30Mins(logBox); // 排程業務邏輯 logBox.info(\u0026#34;callTransferLimitUpPer30Mins is completed!\u0026#34;); return \u0026#34;Ready!\u0026#34;; }); try { logBox.info(\u0026#34;Every 60 minutes is started..\u0026#34;); // 設置最大等待時間 logBox.info(future.get(60, TimeUnit.MINUTES)); logBox.info(\u0026#34;Every 60 minutes is finished!\u0026#34;); } catch (TimeoutException e) { // 允許取消正在運行的執行緒——以拋出異常的方式中斷 future.cancel(true); logBox.info(\u0026#34;callTransferLimitUpPer30Mins is terminated!\u0026#34;); } executor.shutdownNow(); logBox.info(\u0026#34;cancelTaskPer60MINS shutdown now\u0026#34;); } 圖片參考\n關於 log 印不出來，我的想法是 原來在主執行緒的 LogBox ，與 Executors 建立的單一執行緒裡的 LogBox 彼此之間是不互相影響的；但是只有主執行緒的 LogBox 可以印出 log (因為最後有 removeLogBoxAndGetLog() )，所以我就必須將主執行緒產生出來的 LogBox 當作傳參送入 callTransferLimitUpPer30Mins(logBox)，這樣就沒問題啦！\n","permalink":"https://sunwc2023.github.io/blog/thread-local-example/","tags":["Java"],"title":"Java - ThreadLocal 實際應用"},{"categories":["Java"],"contents":" 有關在實際工作上使用到 ThreadLocal 的例子，可以參考我的另一篇文章 Java - ThreadLocal 實際應用\nThreadLocal 實現原理 ThreadLocal 從字面義直翻，就是執行緒 (Thread) 的局部變數，是每一個執行緒所單獨持有，其他執行緒不能對其進行存取\nThreadLocal 支持泛型，也就是支持 value 是可以設置的，像是 ThreadLocal\u0026lt;Integer\u0026gt; 就是設置 value 為 Integer 類型\n每個執行緒會有自己一份 ThreadLocalMap 副本，去儲存這個執行緒自己想存放的 ThreadLocal\u0026lt;T\u0026gt; 變數們，ThreadLocalMap 副本內部儲存的是一個 key-value 對，其中 key 是某個 ThreadLocal\u0026lt;T\u0026gt; 物件實例 ， value 就是這個執行緒、該 ThreadLocal\u0026lt;T\u0026gt; 物件實例 set 的值，所以對一個執行緒來說，一個 ThreadLocal\u0026lt;T\u0026gt; 只能存一個值，而一個執行緒可以存放多個 ThrealLocal\u0026lt;T\u0026gt;\npublic class Thread implements Runnable { // Thread 類裡的threadLocals 存放此執行緒的專有 ThreadLocalMap 副本 ThreadLocal.ThreadLocalMap threadLocals = null; } public class ThreadLocal\u0026lt;T\u0026gt; { // 根據執行緒，取得那個執行緒自己的 ThreadLocalMap ThreadLocalMap getMap(Thread t) { return t.threadLocals; } static class ThreadLocalMap { // ThreadLocalMap 的 key 是使用 \u0026#34;弱引用\u0026#34; 的 ThreadLocal\u0026lt;T\u0026gt; static class Entry extends WeakReference\u0026lt;ThreadLocal\u0026lt;?\u0026gt;\u0026gt; { Object value; // ThreadLocalMap 中的 key 就是 ThreadLocal\u0026lt;T\u0026gt;，value 就是設置的值 Entry(ThreadLocal\u0026lt;?\u0026gt; k, Object v) { super(k); value = v; } } } public T get() { // 取得當前執行緒 Thread t = Thread.currentThread(); // 每個執行緒 都有一個自己的 ThreadLocalMap // ThreadLocalMap 裡就保存著所有的ThreadLocal\u0026lt;T\u0026gt;變數 ThreadLocalMap map = getMap(t); if (map != null) { // ThreadLocalMap 的 key 就是當前 ThreadLocal\u0026lt;T\u0026gt; 物件實例 // 多個 ThreadLocal\u0026lt;T\u0026gt; 變數都是放在這個 map 中的 ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) // 從 map 裡取出來的值就是我們需要的這個 ThreadLocal\u0026lt;T\u0026gt; 變數 T result = (T)e.value; return result; } } // 如果 map 沒有初始化，那麼在這裡初始化一下 return setInitialValue(); } public void set(T value) { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) { map.set(this, value); } else { createMap(t, value); } } public void remove() { ThreadLocalMap map = getMap(Thread.currentThread()); if (map != null) { map.remove(this); } } } ThreadLocal 常用方法 set(x) : 設置此執行緒的想要放的值 x get() : 取得此執行緒當初存放的值，如果沒有存放過則返回 null remove() : 刪除此執行緒的 key-value 對，也就是如果先執行 remove 再執行 get，會返回 null 可以創建多個 ThreadLocal\u0026lt;T\u0026gt; 物件，對每個 ThreadLocal\u0026lt;T\u0026gt; 都設置不同的值\n像是以下的例子，在 main 執行緒中的 ThreadLocalMap ，就有兩個 key-value 的映射，userIdThreadLocal -\u0026gt; 100、userNameThreadLocal -\u0026gt; hello public class Main { public static void main(String[] args){ ThreadLocal\u0026lt;Integer\u0026gt; userIdThreadLocal = new ThreadLocal\u0026lt;\u0026gt;(); ThreadLocal\u0026lt;String\u0026gt; userNameThreacLocal = new ThreadLocal\u0026lt;\u0026gt;(); userId.set(100); userName.set(\u0026#34;hello\u0026#34;); } } ThreadLocal 存在內存洩露 這邊不多去探討這個議題，內存洩漏是可以避免的，只要當前執行緒要結束前記得即時的remove()，也就是是使得 ThreadLocalMap 中不要存在這個 key-value 對，這樣才能確保 GC 能正確回收\n以下有更多的文章，仔細地談論 ThreadLocal 內存洩漏問題 與 Java 自身解決的方式，但都不治本！還是當前執行緒用完 ThreadLocal 記得呼叫remove()，才是確保線程安全的根本之道！\n參考資料：\nJava - ThreadLocal 類的使用\nThreadLocal使用與原理\nSimpleDateFormat 非線程安全？ 由於 SimpleDateFormat 本身非 synchronized ，所以如果在不同執行緒使用同一個 SimpleDateFormat ，就會導致輸出的時間異常，請看以下的例子\npublic static void main(String[] args) { DateFormat sdf = new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); Date date1 = new Date(1614820308016L); Date date2 = new Date(1615820309016L); System.out.println(\u0026#34;初始定義時間1 : \u0026#34; + sdf.format(date1)); System.out.println(\u0026#34;初始定義時間2 : \u0026#34; + sdf.format(date2)); Thread t1 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 100; i++) { String dateStr = sdf.format(date1); if (!\u0026#34;2021-03-04 09:11:48\u0026#34;.equals(dateStr)) { System.out.println(Thread.currentThread().getName() + \u0026#34;異常時間為 : \u0026#34; + dateStr); } } }, \u0026#34;thread 1\u0026#34;); Thread t2 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 100; i++) { String dateStr = sdf.format(date2); if (!\u0026#34;2021-03-15 22:58:29\u0026#34;.equals(dateStr)) { System.out.println(Thread.currentThread().getName() + \u0026#34;異常時間為 : \u0026#34; + dateStr); } } }, \u0026#34;Thread 2\u0026#34;); t1.start(); t2.start(); try { t1.join(); t2.join(); } catch (InterruptedException e) { e.printStackTrace(); } } 輸出異常：(Thread2 輸出了 Thread1 的時間)\n初始定義時間1 : 2021-03-04 09:11:48 初始定義時間2 : 2021-03-15 22:58:29 Thread 2異常時間為 : 2021-03-04 09:11:48 但是， ThreadLocal 可以解決非線程安全的問題，只要在各自的執行緒，持有各自的ThreadLocal\u0026lt;DateFormat\u0026gt;，就不會有問題了，請看下面的例子\npublic static void main(String[] args) { DateFormat sdf = new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); Date date1 = new Date(1614820308016L); Date date2 = new Date(1615820309016L); System.out.println(\u0026#34;初始定義時間1 : \u0026#34; + sdf.format(date1)); System.out.println(\u0026#34;初始定義時間2 : \u0026#34; + sdf.format(date2)); Thread t1 = new Thread(() -\u0026gt; { ThreadLocal\u0026lt;DateFormat\u0026gt; currentSDF = new ThreadLocal\u0026lt;\u0026gt;(); DateFormat df1 = new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); currentSDF.set(df1); DateFormat dateFormat1 = currentSDF.get(); for (int i = 0; i \u0026lt; 100; i++) { String dateStr = dateFormat1.format(date1); if (!\u0026#34;2021-03-04 09:11:48\u0026#34;.equals(dateStr)) { System.out.println(Thread.currentThread().getName() + \u0026#34;異常時間為 : \u0026#34; + dateStr); } } currentSDF.remove(); }, \u0026#34;thread 1\u0026#34;); Thread t2 = new Thread(() -\u0026gt; { ThreadLocal\u0026lt;DateFormat\u0026gt; currentSDF = new ThreadLocal\u0026lt;\u0026gt;(); DateFormat df2 = new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); currentSDF.set(df2); DateFormat dateFormat2 = currentSDF.get(); for (int i = 0; i \u0026lt; 100; i++) { String dateStr = dateFormat2.format(date2); if (!\u0026#34;2021-03-15 22:58:29\u0026#34;.equals(dateStr)) { System.out.println(Thread.currentThread().getName() + \u0026#34;異常時間為 : \u0026#34; + dateStr); } } currentSDF.remove(); }, \u0026#34;Thread 2\u0026#34;); t1.start(); t2.start(); try { t1.join(); t2.join(); } catch (InterruptedException e) { e.printStackTrace(); } } 輸出正常：\n初始定義時間1 : 2021-03-04 09:11:48 初始定義時間2 : 2021-03-15 22:58:29 參考來源\n","permalink":"https://sunwc2023.github.io/blog/thread-local/","tags":["Java"],"title":"Java - ThreadLocal 類的使用"}]